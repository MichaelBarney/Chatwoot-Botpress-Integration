import { AxiosRequestConfig, AxiosInstance, AxiosError } from 'axios';
import * as axios from 'axios';
export { axios };
import { IAxiosRetryConfig } from 'axios-retry';
import * as axiosRetry from 'axios-retry';
export { axiosRetry };

type Primitive = string | number | boolean;
type Value<P extends Primitive> = P | P[] | Record<string, P>;
type QueryValue = Value<string> | Value<boolean> | Value<number> | undefined;
type AnyQueryParams = Record<string, QueryValue>;
type HeaderValue = string | undefined;
type AnyHeaderParams = Record<string, HeaderValue>;
type AnyBodyParams = Record<string, any>;
type ParsedRequest = {
    method: string;
    path: string;
    query: AnyQueryParams;
    headers: AnyHeaderParams;
    body: AnyBodyParams;
};
declare const toAxiosRequest: (req: ParsedRequest) => AxiosRequestConfig;

interface CreateConversationRequestHeaders {
}
interface CreateConversationRequestQuery {
}
interface CreateConversationRequestParams {
}
interface CreateConversationRequestBody {
    /**
     * Channel name
     */
    channel: string;
    /**
     * Tags for the [Conversation](#schema_conversation)
     */
    tags: {
        [k: string]: string;
    };
    /**
     * @deprecated
     * [DEPRECATED] To create a conversation from within a bot, call an action of the integration instead.
     */
    integrationName?: string;
}
type CreateConversationInput = CreateConversationRequestBody & CreateConversationRequestHeaders & CreateConversationRequestQuery & CreateConversationRequestParams;
interface CreateConversationResponse {
    /**
     * The [Conversation](#schema_conversation) object represents an exchange of messages between one or more users. A [Conversation](#schema_conversation) is always linked to an integration's channels. For example, a Slack channel represents a conversation.
     */
    conversation: {
        /**
         * Id of the [Conversation](#schema_conversation)
         */
        id: string;
        /**
         * Id of the current [Task](#schema_task)
         */
        currentTaskId?: string;
        /**
         * Id of the current [Workflow](#schema_workflow)
         */
        currentWorkflowId?: string;
        /**
         * Creation date of the [Conversation](#schema_conversation) in ISO 8601 format
         */
        createdAt: string;
        /**
         * Updating date of the [Conversation](#schema_conversation) in ISO 8601 format
         */
        updatedAt: string;
        /**
         * Name of the channel where the [Conversation](#schema_conversation) is happening
         */
        channel: string;
        /**
         * Name of the integration that created the [Conversation](#schema_conversation)
         */
        integration: string;
        /**
         * Set of [Tags](/docs/developers/concepts/tags) that you can attach to a [Conversation](#schema_conversation). The set of [Tags](/docs/developers/concepts/tags) available on a [Conversation](#schema_conversation) is restricted by the list of [Tags](/docs/developers/concepts/tags) defined previously by the [Bot](#schema_bot). Individual keys can be unset by posting an empty value to them.
         */
        tags: {
            [k: string]: string;
        };
    };
}

interface GetConversationRequestHeaders {
}
interface GetConversationRequestQuery {
}
interface GetConversationRequestParams {
    id: string;
}
interface GetConversationRequestBody {
}
type GetConversationInput = GetConversationRequestBody & GetConversationRequestHeaders & GetConversationRequestQuery & GetConversationRequestParams;
interface GetConversationResponse {
    /**
     * The [Conversation](#schema_conversation) object represents an exchange of messages between one or more users. A [Conversation](#schema_conversation) is always linked to an integration's channels. For example, a Slack channel represents a conversation.
     */
    conversation: {
        /**
         * Id of the [Conversation](#schema_conversation)
         */
        id: string;
        /**
         * Id of the current [Task](#schema_task)
         */
        currentTaskId?: string;
        /**
         * Id of the current [Workflow](#schema_workflow)
         */
        currentWorkflowId?: string;
        /**
         * Creation date of the [Conversation](#schema_conversation) in ISO 8601 format
         */
        createdAt: string;
        /**
         * Updating date of the [Conversation](#schema_conversation) in ISO 8601 format
         */
        updatedAt: string;
        /**
         * Name of the channel where the [Conversation](#schema_conversation) is happening
         */
        channel: string;
        /**
         * Name of the integration that created the [Conversation](#schema_conversation)
         */
        integration: string;
        /**
         * Set of [Tags](/docs/developers/concepts/tags) that you can attach to a [Conversation](#schema_conversation). The set of [Tags](/docs/developers/concepts/tags) available on a [Conversation](#schema_conversation) is restricted by the list of [Tags](/docs/developers/concepts/tags) defined previously by the [Bot](#schema_bot). Individual keys can be unset by posting an empty value to them.
         */
        tags: {
            [k: string]: string;
        };
    };
}

interface ListConversationsRequestHeaders {
}
interface ListConversationsRequestQuery {
    nextToken?: string;
    sortField?: "createdAt" | "updatedAt";
    sortDirection?: "asc" | "desc";
    tags?: {
        [k: string]: string;
    };
    participantIds?: string[];
    integrationName?: string;
}
interface ListConversationsRequestParams {
}
interface ListConversationsRequestBody {
}
type ListConversationsInput = ListConversationsRequestBody & ListConversationsRequestHeaders & ListConversationsRequestQuery & ListConversationsRequestParams;
interface ListConversationsResponse {
    conversations: {
        /**
         * Id of the [Conversation](#schema_conversation)
         */
        id: string;
        /**
         * Id of the current [Task](#schema_task)
         */
        currentTaskId?: string;
        /**
         * Id of the current [Workflow](#schema_workflow)
         */
        currentWorkflowId?: string;
        /**
         * Creation date of the [Conversation](#schema_conversation) in ISO 8601 format
         */
        createdAt: string;
        /**
         * Updating date of the [Conversation](#schema_conversation) in ISO 8601 format
         */
        updatedAt: string;
        /**
         * Name of the channel where the [Conversation](#schema_conversation) is happening
         */
        channel: string;
        /**
         * Name of the integration that created the [Conversation](#schema_conversation)
         */
        integration: string;
        /**
         * Set of [Tags](/docs/developers/concepts/tags) that you can attach to a [Conversation](#schema_conversation). The set of [Tags](/docs/developers/concepts/tags) available on a [Conversation](#schema_conversation) is restricted by the list of [Tags](/docs/developers/concepts/tags) defined previously by the [Bot](#schema_bot). Individual keys can be unset by posting an empty value to them.
         */
        tags: {
            [k: string]: string;
        };
    }[];
    meta: {
        /**
         * The token to use to retrieve the next page of results, passed as a query string parameter (value should be URL-encoded) to this API endpoint.
         */
        nextToken?: string;
    };
}

interface GetOrCreateConversationRequestHeaders {
}
interface GetOrCreateConversationRequestQuery {
}
interface GetOrCreateConversationRequestParams {
}
interface GetOrCreateConversationRequestBody {
    /**
     * Channel name
     */
    channel: string;
    /**
     * Tags for the [Conversation](#schema_conversation)
     */
    tags: {
        [k: string]: string;
    };
    /**
     * @deprecated
     * [DEPRECATED] To create a conversation from within a bot, call an action of the integration instead.
     */
    integrationName?: string;
}
type GetOrCreateConversationInput = GetOrCreateConversationRequestBody & GetOrCreateConversationRequestHeaders & GetOrCreateConversationRequestQuery & GetOrCreateConversationRequestParams;
interface GetOrCreateConversationResponse {
    /**
     * The [Conversation](#schema_conversation) object represents an exchange of messages between one or more users. A [Conversation](#schema_conversation) is always linked to an integration's channels. For example, a Slack channel represents a conversation.
     */
    conversation: {
        /**
         * Id of the [Conversation](#schema_conversation)
         */
        id: string;
        /**
         * Id of the current [Task](#schema_task)
         */
        currentTaskId?: string;
        /**
         * Id of the current [Workflow](#schema_workflow)
         */
        currentWorkflowId?: string;
        /**
         * Creation date of the [Conversation](#schema_conversation) in ISO 8601 format
         */
        createdAt: string;
        /**
         * Updating date of the [Conversation](#schema_conversation) in ISO 8601 format
         */
        updatedAt: string;
        /**
         * Name of the channel where the [Conversation](#schema_conversation) is happening
         */
        channel: string;
        /**
         * Name of the integration that created the [Conversation](#schema_conversation)
         */
        integration: string;
        /**
         * Set of [Tags](/docs/developers/concepts/tags) that you can attach to a [Conversation](#schema_conversation). The set of [Tags](/docs/developers/concepts/tags) available on a [Conversation](#schema_conversation) is restricted by the list of [Tags](/docs/developers/concepts/tags) defined previously by the [Bot](#schema_bot). Individual keys can be unset by posting an empty value to them.
         */
        tags: {
            [k: string]: string;
        };
    };
}

interface UpdateConversationRequestHeaders {
}
interface UpdateConversationRequestQuery {
}
interface UpdateConversationRequestParams {
    id: string;
}
interface UpdateConversationRequestBody {
    currentTaskId?: string;
    /**
     * Tags for the [Conversation](#schema_conversation)
     */
    tags?: {
        [k: string]: string;
    };
}
type UpdateConversationInput = UpdateConversationRequestBody & UpdateConversationRequestHeaders & UpdateConversationRequestQuery & UpdateConversationRequestParams;
interface UpdateConversationResponse {
    /**
     * The [Conversation](#schema_conversation) object represents an exchange of messages between one or more users. A [Conversation](#schema_conversation) is always linked to an integration's channels. For example, a Slack channel represents a conversation.
     */
    conversation: {
        /**
         * Id of the [Conversation](#schema_conversation)
         */
        id: string;
        /**
         * Id of the current [Task](#schema_task)
         */
        currentTaskId?: string;
        /**
         * Id of the current [Workflow](#schema_workflow)
         */
        currentWorkflowId?: string;
        /**
         * Creation date of the [Conversation](#schema_conversation) in ISO 8601 format
         */
        createdAt: string;
        /**
         * Updating date of the [Conversation](#schema_conversation) in ISO 8601 format
         */
        updatedAt: string;
        /**
         * Name of the channel where the [Conversation](#schema_conversation) is happening
         */
        channel: string;
        /**
         * Name of the integration that created the [Conversation](#schema_conversation)
         */
        integration: string;
        /**
         * Set of [Tags](/docs/developers/concepts/tags) that you can attach to a [Conversation](#schema_conversation). The set of [Tags](/docs/developers/concepts/tags) available on a [Conversation](#schema_conversation) is restricted by the list of [Tags](/docs/developers/concepts/tags) defined previously by the [Bot](#schema_bot). Individual keys can be unset by posting an empty value to them.
         */
        tags: {
            [k: string]: string;
        };
    };
}

interface DeleteConversationRequestHeaders {
}
interface DeleteConversationRequestQuery {
}
interface DeleteConversationRequestParams {
    id: string;
}
interface DeleteConversationRequestBody {
}
type DeleteConversationInput = DeleteConversationRequestBody & DeleteConversationRequestHeaders & DeleteConversationRequestQuery & DeleteConversationRequestParams;
interface DeleteConversationResponse {
}

interface ListParticipantsRequestHeaders {
}
interface ListParticipantsRequestQuery {
    nextToken?: string;
}
interface ListParticipantsRequestParams {
    id: string;
}
interface ListParticipantsRequestBody {
}
type ListParticipantsInput = ListParticipantsRequestBody & ListParticipantsRequestHeaders & ListParticipantsRequestQuery & ListParticipantsRequestParams;
interface ListParticipantsResponse {
    participants: {
        /**
         * Id of the [User](#schema_user)
         */
        id: string;
        /**
         * Creation date of the [User](#schema_user) in ISO 8601 format
         */
        createdAt: string;
        /**
         * Updating date of the [User](#schema_user) in ISO 8601 format
         */
        updatedAt: string;
        /**
         * Set of [Tags](/docs/developers/concepts/tags) that you can attach to a [User](#schema_user). The set of [Tags](/docs/developers/concepts/tags) available on a [User](#schema_user) is restricted by the list of [Tags](/docs/developers/concepts/tags) defined previously by the [Bot](#schema_bot). Individual keys can be unset by posting an empty value to them.
         */
        tags: {
            [k: string]: string;
        };
        /**
         * Name of the [User](#schema_user)
         */
        name?: string;
        /**
         * Picture URL of the [User](#schema_user)
         */
        pictureUrl?: string;
    }[];
    meta: {
        /**
         * The token to use to retrieve the next page of results, passed as a query string parameter (value should be URL-encoded) to this API endpoint.
         */
        nextToken?: string;
    };
}

interface AddParticipantRequestHeaders {
}
interface AddParticipantRequestQuery {
}
interface AddParticipantRequestParams {
    id: string;
}
interface AddParticipantRequestBody {
    /**
     * User id
     */
    userId: string;
}
type AddParticipantInput = AddParticipantRequestBody & AddParticipantRequestHeaders & AddParticipantRequestQuery & AddParticipantRequestParams;
interface AddParticipantResponse {
    /**
     * The user object represents someone interacting with the bot within a specific integration. The same person interacting with a bot in slack and messenger will be represented with two different users.
     */
    participant: {
        /**
         * Id of the [User](#schema_user)
         */
        id: string;
        /**
         * Creation date of the [User](#schema_user) in ISO 8601 format
         */
        createdAt: string;
        /**
         * Updating date of the [User](#schema_user) in ISO 8601 format
         */
        updatedAt: string;
        /**
         * Set of [Tags](/docs/developers/concepts/tags) that you can attach to a [User](#schema_user). The set of [Tags](/docs/developers/concepts/tags) available on a [User](#schema_user) is restricted by the list of [Tags](/docs/developers/concepts/tags) defined previously by the [Bot](#schema_bot). Individual keys can be unset by posting an empty value to them.
         */
        tags: {
            [k: string]: string;
        };
        /**
         * Name of the [User](#schema_user)
         */
        name?: string;
        /**
         * Picture URL of the [User](#schema_user)
         */
        pictureUrl?: string;
    };
}

interface GetParticipantRequestHeaders {
}
interface GetParticipantRequestQuery {
}
interface GetParticipantRequestParams {
    id: string;
    userId: string;
}
interface GetParticipantRequestBody {
}
type GetParticipantInput = GetParticipantRequestBody & GetParticipantRequestHeaders & GetParticipantRequestQuery & GetParticipantRequestParams;
interface GetParticipantResponse {
    /**
     * The user object represents someone interacting with the bot within a specific integration. The same person interacting with a bot in slack and messenger will be represented with two different users.
     */
    participant: {
        /**
         * Id of the [User](#schema_user)
         */
        id: string;
        /**
         * Creation date of the [User](#schema_user) in ISO 8601 format
         */
        createdAt: string;
        /**
         * Updating date of the [User](#schema_user) in ISO 8601 format
         */
        updatedAt: string;
        /**
         * Set of [Tags](/docs/developers/concepts/tags) that you can attach to a [User](#schema_user). The set of [Tags](/docs/developers/concepts/tags) available on a [User](#schema_user) is restricted by the list of [Tags](/docs/developers/concepts/tags) defined previously by the [Bot](#schema_bot). Individual keys can be unset by posting an empty value to them.
         */
        tags: {
            [k: string]: string;
        };
        /**
         * Name of the [User](#schema_user)
         */
        name?: string;
        /**
         * Picture URL of the [User](#schema_user)
         */
        pictureUrl?: string;
    };
}

interface RemoveParticipantRequestHeaders {
}
interface RemoveParticipantRequestQuery {
}
interface RemoveParticipantRequestParams {
    id: string;
    userId: string;
}
interface RemoveParticipantRequestBody {
}
type RemoveParticipantInput = RemoveParticipantRequestBody & RemoveParticipantRequestHeaders & RemoveParticipantRequestQuery & RemoveParticipantRequestParams;
interface RemoveParticipantResponse {
}

interface CreateEventRequestHeaders {
}
interface CreateEventRequestQuery {
}
interface CreateEventRequestParams {
}
interface CreateEventRequestBody {
    /**
     * Type of the [Event](#schema_event).
     */
    type: string;
    /**
     * Payload is the content of the event defined by the integration installed on your bot or one of the default events created by our API.
     */
    payload: {
        [k: string]: any;
    };
    /**
     * Schedule the Event to be sent at a specific time. Either dateTime or delay must be provided.
     */
    schedule?: {
        /**
         * When the [Event](#schema_event) will be sent, in the ISO 8601 format
         */
        dateTime?: string;
        /**
         * Delay in milliseconds before sending the [Event](#schema_event)
         */
        delay?: number;
    };
    /**
     * ID of the [Conversation](#schema_conversation) to link the event to.
     */
    conversationId?: string;
    /**
     * ID of the [User](#schema_user) to link the event to.
     */
    userId?: string;
    /**
     * ID of the [Message](#schema_message) to link the event to.
     */
    messageId?: string;
}
type CreateEventInput = CreateEventRequestBody & CreateEventRequestHeaders & CreateEventRequestQuery & CreateEventRequestParams;
interface CreateEventResponse {
    /**
     * The event object represents an action or an occurrence.
     */
    event: {
        /**
         * Id of the [Event](#schema_event)
         */
        id: string;
        /**
         * Creation date of the [Event](#schema_event) in ISO 8601 format
         */
        createdAt: string;
        /**
         * Type of the [Event](#schema_event).
         */
        type: string;
        /**
         * Payload is the content of the event defined by the integration installed on your bot or one of the default events created by our api.
         */
        payload: {
            [k: string]: any;
        };
        /**
         * ID of the [Conversation](#schema_conversation) to link the event to.
         */
        conversationId?: string;
        /**
         * ID of the [User](#schema_user) to link the event to.
         */
        userId?: string;
        /**
         * ID of the [Message](#schema_message) to link the event to.
         */
        messageId?: string;
        status: "pending" | "processed" | "ignored" | "failed" | "scheduled";
        /**
         * Reason why the event failed to be processed
         */
        failureReason: string | null;
    };
}

interface GetEventRequestHeaders {
}
interface GetEventRequestQuery {
}
interface GetEventRequestParams {
    id: string;
}
interface GetEventRequestBody {
}
type GetEventInput = GetEventRequestBody & GetEventRequestHeaders & GetEventRequestQuery & GetEventRequestParams;
interface GetEventResponse {
    /**
     * The event object represents an action or an occurrence.
     */
    event: {
        /**
         * Id of the [Event](#schema_event)
         */
        id: string;
        /**
         * Creation date of the [Event](#schema_event) in ISO 8601 format
         */
        createdAt: string;
        /**
         * Type of the [Event](#schema_event).
         */
        type: string;
        /**
         * Payload is the content of the event defined by the integration installed on your bot or one of the default events created by our api.
         */
        payload: {
            [k: string]: any;
        };
        /**
         * ID of the [Conversation](#schema_conversation) to link the event to.
         */
        conversationId?: string;
        /**
         * ID of the [User](#schema_user) to link the event to.
         */
        userId?: string;
        /**
         * ID of the [Message](#schema_message) to link the event to.
         */
        messageId?: string;
        status: "pending" | "processed" | "ignored" | "failed" | "scheduled";
        /**
         * Reason why the event failed to be processed
         */
        failureReason: string | null;
    };
}

interface ListEventsRequestHeaders {
}
interface ListEventsRequestQuery {
    nextToken?: string;
    type?: string;
    conversationId?: string;
    userId?: string;
    messageId?: string;
    status?: "pending" | "ignored" | "processed" | "failed" | "scheduled";
}
interface ListEventsRequestParams {
}
interface ListEventsRequestBody {
}
type ListEventsInput = ListEventsRequestBody & ListEventsRequestHeaders & ListEventsRequestQuery & ListEventsRequestParams;
interface ListEventsResponse {
    events: {
        /**
         * Id of the [Event](#schema_event)
         */
        id: string;
        /**
         * Creation date of the [Event](#schema_event) in ISO 8601 format
         */
        createdAt: string;
        /**
         * Type of the [Event](#schema_event).
         */
        type: string;
        /**
         * Payload is the content of the event defined by the integration installed on your bot or one of the default events created by our api.
         */
        payload: {
            [k: string]: any;
        };
        /**
         * ID of the [Conversation](#schema_conversation) to link the event to.
         */
        conversationId?: string;
        /**
         * ID of the [User](#schema_user) to link the event to.
         */
        userId?: string;
        /**
         * ID of the [Message](#schema_message) to link the event to.
         */
        messageId?: string;
        status: "pending" | "processed" | "ignored" | "failed" | "scheduled";
        /**
         * Reason why the event failed to be processed
         */
        failureReason: string | null;
    }[];
    meta: {
        /**
         * The token to use to retrieve the next page of results, passed as a query string parameter (value should be URL-encoded) to this API endpoint.
         */
        nextToken?: string;
    };
}

interface CreateMessageRequestHeaders {
}
interface CreateMessageRequestQuery {
}
interface CreateMessageRequestParams {
}
interface CreateMessageRequestBody {
    /**
     * Payload is the content type of the message. Accepted payload options: Text, Image, Choice, Dropdown, Card, Carousel, File, Audio, Video, Location
     */
    payload: {
        [k: string]: any;
    };
    /**
     * ID of the [User](#schema_user)
     */
    userId: string;
    /**
     * ID of the [Conversation](#schema_conversation)
     */
    conversationId: string;
    /**
     * Type of the [Message](#schema_message) represents the resource type that the message is related to
     */
    type: string;
    /**
     * Set of [Tags](/docs/developers/concepts/tags) that you can attach to a [Message](#schema_message). The set of [Tags](/docs/developers/concepts/tags) available on a [Message](#schema_message) is restricted by the list of [Tags](/docs/developers/concepts/tags) defined previously by the [Bot](#schema_bot). Individual keys can be unset by posting an empty value to them.
     */
    tags: {
        [k: string]: string;
    };
    /**
     * Schedule the Message to be sent at a specific time. Either dateTime or delay must be provided.
     */
    schedule?: {
        /**
         * When the [Message](#schema_message) will be sent, in the ISO 8601 format
         */
        dateTime?: string;
        /**
         * Delay in milliseconds before sending the [Message](#schema_message)
         */
        delay?: number;
    };
}
type CreateMessageInput = CreateMessageRequestBody & CreateMessageRequestHeaders & CreateMessageRequestQuery & CreateMessageRequestParams;
interface CreateMessageResponse {
    /**
     * The Message object represents a message in a [Conversation](#schema_conversation) for a specific [User](#schema_user).
     */
    message: {
        /**
         * Id of the [Message](#schema_message)
         */
        id: string;
        /**
         * Creation date of the [Message](#schema_message) in ISO 8601 format
         */
        createdAt: string;
        /**
         * Type of the [Message](#schema_message) represents the resource type that the message is related to
         */
        type: string;
        /**
         * Payload is the content type of the message. Accepted payload options: Text, Image, Choice, Dropdown, Card, Carousel, File, Audio, Video, Location
         */
        payload: {
            [k: string]: any;
        };
        /**
         * Direction of the message (`incoming` or `outgoing`).
         */
        direction: "incoming" | "outgoing";
        /**
         * ID of the [User](#schema_user)
         */
        userId: string;
        /**
         * ID of the [Conversation](#schema_conversation)
         */
        conversationId: string;
        /**
         * Set of [Tags](/docs/developers/concepts/tags) that you can attach to a [Conversation](#schema_conversation). The set of [Tags](/docs/developers/concepts/tags) available on a [Conversation](#schema_conversation) is restricted by the list of [Tags](/docs/developers/concepts/tags) defined previously by the [Bot](#schema_bot). Individual keys can be unset by posting an empty value to them.
         */
        tags: {
            [k: string]: string;
        };
    };
}

interface GetOrCreateMessageRequestHeaders {
}
interface GetOrCreateMessageRequestQuery {
}
interface GetOrCreateMessageRequestParams {
}
interface GetOrCreateMessageRequestBody {
    /**
     * Payload is the content type of the message. Accepted payload options: Text, Image, Choice, Dropdown, Card, Carousel, File, Audio, Video, Location
     */
    payload: {
        [k: string]: any;
    };
    /**
     * ID of the [User](#schema_user)
     */
    userId: string;
    /**
     * ID of the [Conversation](#schema_conversation)
     */
    conversationId: string;
    /**
     * Type of the [Message](#schema_message) represents the resource type that the message is related to
     */
    type: string;
    /**
     * Set of [Tags](/docs/developers/concepts/tags) that you can attach to a [Message](#schema_message). The set of [Tags](/docs/developers/concepts/tags) available on a [Message](#schema_message) is restricted by the list of [Tags](/docs/developers/concepts/tags) defined previously by the [Bot](#schema_bot). Individual keys can be unset by posting an empty value to them.
     */
    tags: {
        [k: string]: string;
    };
    /**
     * Schedule the Message to be sent at a specific time. Either dateTime or delay must be provided.
     */
    schedule?: {
        /**
         * When the [Message](#schema_message) will be sent, in the ISO 8601 format
         */
        dateTime?: string;
        /**
         * Delay in milliseconds before sending the [Message](#schema_message)
         */
        delay?: number;
    };
}
type GetOrCreateMessageInput = GetOrCreateMessageRequestBody & GetOrCreateMessageRequestHeaders & GetOrCreateMessageRequestQuery & GetOrCreateMessageRequestParams;
interface GetOrCreateMessageResponse {
    /**
     * The Message object represents a message in a [Conversation](#schema_conversation) for a specific [User](#schema_user).
     */
    message: {
        /**
         * Id of the [Message](#schema_message)
         */
        id: string;
        /**
         * Creation date of the [Message](#schema_message) in ISO 8601 format
         */
        createdAt: string;
        /**
         * Type of the [Message](#schema_message) represents the resource type that the message is related to
         */
        type: string;
        /**
         * Payload is the content type of the message. Accepted payload options: Text, Image, Choice, Dropdown, Card, Carousel, File, Audio, Video, Location
         */
        payload: {
            [k: string]: any;
        };
        /**
         * Direction of the message (`incoming` or `outgoing`).
         */
        direction: "incoming" | "outgoing";
        /**
         * ID of the [User](#schema_user)
         */
        userId: string;
        /**
         * ID of the [Conversation](#schema_conversation)
         */
        conversationId: string;
        /**
         * Set of [Tags](/docs/developers/concepts/tags) that you can attach to a [Conversation](#schema_conversation). The set of [Tags](/docs/developers/concepts/tags) available on a [Conversation](#schema_conversation) is restricted by the list of [Tags](/docs/developers/concepts/tags) defined previously by the [Bot](#schema_bot). Individual keys can be unset by posting an empty value to them.
         */
        tags: {
            [k: string]: string;
        };
    };
}

interface GetMessageRequestHeaders {
}
interface GetMessageRequestQuery {
}
interface GetMessageRequestParams {
    id: string;
}
interface GetMessageRequestBody {
}
type GetMessageInput = GetMessageRequestBody & GetMessageRequestHeaders & GetMessageRequestQuery & GetMessageRequestParams;
interface GetMessageResponse {
    /**
     * The Message object represents a message in a [Conversation](#schema_conversation) for a specific [User](#schema_user).
     */
    message: {
        /**
         * Id of the [Message](#schema_message)
         */
        id: string;
        /**
         * Creation date of the [Message](#schema_message) in ISO 8601 format
         */
        createdAt: string;
        /**
         * Type of the [Message](#schema_message) represents the resource type that the message is related to
         */
        type: string;
        /**
         * Payload is the content type of the message. Accepted payload options: Text, Image, Choice, Dropdown, Card, Carousel, File, Audio, Video, Location
         */
        payload: {
            [k: string]: any;
        };
        /**
         * Direction of the message (`incoming` or `outgoing`).
         */
        direction: "incoming" | "outgoing";
        /**
         * ID of the [User](#schema_user)
         */
        userId: string;
        /**
         * ID of the [Conversation](#schema_conversation)
         */
        conversationId: string;
        /**
         * Set of [Tags](/docs/developers/concepts/tags) that you can attach to a [Conversation](#schema_conversation). The set of [Tags](/docs/developers/concepts/tags) available on a [Conversation](#schema_conversation) is restricted by the list of [Tags](/docs/developers/concepts/tags) defined previously by the [Bot](#schema_bot). Individual keys can be unset by posting an empty value to them.
         */
        tags: {
            [k: string]: string;
        };
    };
}

interface UpdateMessageRequestHeaders {
}
interface UpdateMessageRequestQuery {
}
interface UpdateMessageRequestParams {
    id: string;
}
interface UpdateMessageRequestBody {
    /**
     * Set of [Tags](/docs/developers/concepts/tags) that you can attach to a [Conversation](#schema_conversation). The set of [Tags](/docs/developers/concepts/tags) available on a [Conversation](#schema_conversation) is restricted by the list of [Tags](/docs/developers/concepts/tags) defined previously by the [Bot](#schema_bot). Individual keys can be unset by posting an empty value to them.
     */
    tags: {
        [k: string]: string;
    };
}
type UpdateMessageInput = UpdateMessageRequestBody & UpdateMessageRequestHeaders & UpdateMessageRequestQuery & UpdateMessageRequestParams;
interface UpdateMessageResponse {
    /**
     * The Message object represents a message in a [Conversation](#schema_conversation) for a specific [User](#schema_user).
     */
    message: {
        /**
         * Id of the [Message](#schema_message)
         */
        id: string;
        /**
         * Creation date of the [Message](#schema_message) in ISO 8601 format
         */
        createdAt: string;
        /**
         * Type of the [Message](#schema_message) represents the resource type that the message is related to
         */
        type: string;
        /**
         * Payload is the content type of the message. Accepted payload options: Text, Image, Choice, Dropdown, Card, Carousel, File, Audio, Video, Location
         */
        payload: {
            [k: string]: any;
        };
        /**
         * Direction of the message (`incoming` or `outgoing`).
         */
        direction: "incoming" | "outgoing";
        /**
         * ID of the [User](#schema_user)
         */
        userId: string;
        /**
         * ID of the [Conversation](#schema_conversation)
         */
        conversationId: string;
        /**
         * Set of [Tags](/docs/developers/concepts/tags) that you can attach to a [Conversation](#schema_conversation). The set of [Tags](/docs/developers/concepts/tags) available on a [Conversation](#schema_conversation) is restricted by the list of [Tags](/docs/developers/concepts/tags) defined previously by the [Bot](#schema_bot). Individual keys can be unset by posting an empty value to them.
         */
        tags: {
            [k: string]: string;
        };
    };
}

interface ListMessagesRequestHeaders {
}
interface ListMessagesRequestQuery {
    nextToken?: string;
    conversationId?: string;
    tags?: {
        [k: string]: string;
    };
}
interface ListMessagesRequestParams {
}
interface ListMessagesRequestBody {
}
type ListMessagesInput = ListMessagesRequestBody & ListMessagesRequestHeaders & ListMessagesRequestQuery & ListMessagesRequestParams;
interface ListMessagesResponse {
    messages: {
        /**
         * Id of the [Message](#schema_message)
         */
        id: string;
        /**
         * Creation date of the [Message](#schema_message) in ISO 8601 format
         */
        createdAt: string;
        /**
         * Type of the [Message](#schema_message) represents the resource type that the message is related to
         */
        type: string;
        /**
         * Payload is the content type of the message. Accepted payload options: Text, Image, Choice, Dropdown, Card, Carousel, File, Audio, Video, Location
         */
        payload: {
            [k: string]: any;
        };
        /**
         * Direction of the message (`incoming` or `outgoing`).
         */
        direction: "incoming" | "outgoing";
        /**
         * ID of the [User](#schema_user)
         */
        userId: string;
        /**
         * ID of the [Conversation](#schema_conversation)
         */
        conversationId: string;
        /**
         * Set of [Tags](/docs/developers/concepts/tags) that you can attach to a [Conversation](#schema_conversation). The set of [Tags](/docs/developers/concepts/tags) available on a [Conversation](#schema_conversation) is restricted by the list of [Tags](/docs/developers/concepts/tags) defined previously by the [Bot](#schema_bot). Individual keys can be unset by posting an empty value to them.
         */
        tags: {
            [k: string]: string;
        };
    }[];
    meta: {
        /**
         * The token to use to retrieve the next page of results, passed as a query string parameter (value should be URL-encoded) to this API endpoint.
         */
        nextToken?: string;
    };
}

interface DeleteMessageRequestHeaders {
}
interface DeleteMessageRequestQuery {
}
interface DeleteMessageRequestParams {
    id: string;
}
interface DeleteMessageRequestBody {
}
type DeleteMessageInput = DeleteMessageRequestBody & DeleteMessageRequestHeaders & DeleteMessageRequestQuery & DeleteMessageRequestParams;
interface DeleteMessageResponse {
}

interface CreateUserRequestHeaders {
}
interface CreateUserRequestQuery {
}
interface CreateUserRequestParams {
}
interface CreateUserRequestBody {
    /**
     * Tags for the [User](#schema_user)
     */
    tags: {
        [k: string]: string;
    };
    /**
     * @deprecated
     * [DEPRECATED] To create a [User](#schema_user) from within a bot, call an action of the integration instead.
     */
    integrationName?: string;
    /**
     * Name of the user
     */
    name?: string;
    /**
     * URI of the user picture
     */
    pictureUrl?: string;
}
type CreateUserInput = CreateUserRequestBody & CreateUserRequestHeaders & CreateUserRequestQuery & CreateUserRequestParams;
interface CreateUserResponse {
    /**
     * The user object represents someone interacting with the bot within a specific integration. The same person interacting with a bot in slack and messenger will be represented with two different users.
     */
    user: {
        /**
         * Id of the [User](#schema_user)
         */
        id: string;
        /**
         * Creation date of the [User](#schema_user) in ISO 8601 format
         */
        createdAt: string;
        /**
         * Updating date of the [User](#schema_user) in ISO 8601 format
         */
        updatedAt: string;
        /**
         * Set of [Tags](/docs/developers/concepts/tags) that you can attach to a [User](#schema_user). The set of [Tags](/docs/developers/concepts/tags) available on a [User](#schema_user) is restricted by the list of [Tags](/docs/developers/concepts/tags) defined previously by the [Bot](#schema_bot). Individual keys can be unset by posting an empty value to them.
         */
        tags: {
            [k: string]: string;
        };
        /**
         * Name of the [User](#schema_user)
         */
        name?: string;
        /**
         * Picture URL of the [User](#schema_user)
         */
        pictureUrl?: string;
    };
}

interface GetUserRequestHeaders {
}
interface GetUserRequestQuery {
}
interface GetUserRequestParams {
    id: string;
}
interface GetUserRequestBody {
}
type GetUserInput = GetUserRequestBody & GetUserRequestHeaders & GetUserRequestQuery & GetUserRequestParams;
interface GetUserResponse {
    /**
     * The user object represents someone interacting with the bot within a specific integration. The same person interacting with a bot in slack and messenger will be represented with two different users.
     */
    user: {
        /**
         * Id of the [User](#schema_user)
         */
        id: string;
        /**
         * Creation date of the [User](#schema_user) in ISO 8601 format
         */
        createdAt: string;
        /**
         * Updating date of the [User](#schema_user) in ISO 8601 format
         */
        updatedAt: string;
        /**
         * Set of [Tags](/docs/developers/concepts/tags) that you can attach to a [User](#schema_user). The set of [Tags](/docs/developers/concepts/tags) available on a [User](#schema_user) is restricted by the list of [Tags](/docs/developers/concepts/tags) defined previously by the [Bot](#schema_bot). Individual keys can be unset by posting an empty value to them.
         */
        tags: {
            [k: string]: string;
        };
        /**
         * Name of the [User](#schema_user)
         */
        name?: string;
        /**
         * Picture URL of the [User](#schema_user)
         */
        pictureUrl?: string;
    };
}

interface ListUsersRequestHeaders {
}
interface ListUsersRequestQuery {
    nextToken?: string;
    conversationId?: string;
    tags?: {
        [k: string]: string;
    };
}
interface ListUsersRequestParams {
}
interface ListUsersRequestBody {
}
type ListUsersInput = ListUsersRequestBody & ListUsersRequestHeaders & ListUsersRequestQuery & ListUsersRequestParams;
interface ListUsersResponse {
    users: {
        /**
         * Id of the [User](#schema_user)
         */
        id: string;
        /**
         * Creation date of the [User](#schema_user) in ISO 8601 format
         */
        createdAt: string;
        /**
         * Updating date of the [User](#schema_user) in ISO 8601 format
         */
        updatedAt: string;
        /**
         * Set of [Tags](/docs/developers/concepts/tags) that you can attach to a [User](#schema_user). The set of [Tags](/docs/developers/concepts/tags) available on a [User](#schema_user) is restricted by the list of [Tags](/docs/developers/concepts/tags) defined previously by the [Bot](#schema_bot). Individual keys can be unset by posting an empty value to them.
         */
        tags: {
            [k: string]: string;
        };
        /**
         * Name of the [User](#schema_user)
         */
        name?: string;
        /**
         * Picture URL of the [User](#schema_user)
         */
        pictureUrl?: string;
    }[];
    meta: {
        /**
         * The token to use to retrieve the next page of results, passed as a query string parameter (value should be URL-encoded) to this API endpoint.
         */
        nextToken?: string;
    };
}

interface GetOrCreateUserRequestHeaders {
}
interface GetOrCreateUserRequestQuery {
}
interface GetOrCreateUserRequestParams {
}
interface GetOrCreateUserRequestBody {
    /**
     * Tags for the [User](#schema_user)
     */
    tags: {
        [k: string]: string;
    };
    /**
     * @deprecated
     * [DEPRECATED] To create a [User](#schema_user) from within a bot, call an action of the integration instead.
     */
    integrationName?: string;
    /**
     * Name of the user
     */
    name?: string;
    /**
     * URI of the user picture
     */
    pictureUrl?: string;
}
type GetOrCreateUserInput = GetOrCreateUserRequestBody & GetOrCreateUserRequestHeaders & GetOrCreateUserRequestQuery & GetOrCreateUserRequestParams;
interface GetOrCreateUserResponse {
    /**
     * The user object represents someone interacting with the bot within a specific integration. The same person interacting with a bot in slack and messenger will be represented with two different users.
     */
    user: {
        /**
         * Id of the [User](#schema_user)
         */
        id: string;
        /**
         * Creation date of the [User](#schema_user) in ISO 8601 format
         */
        createdAt: string;
        /**
         * Updating date of the [User](#schema_user) in ISO 8601 format
         */
        updatedAt: string;
        /**
         * Set of [Tags](/docs/developers/concepts/tags) that you can attach to a [User](#schema_user). The set of [Tags](/docs/developers/concepts/tags) available on a [User](#schema_user) is restricted by the list of [Tags](/docs/developers/concepts/tags) defined previously by the [Bot](#schema_bot). Individual keys can be unset by posting an empty value to them.
         */
        tags: {
            [k: string]: string;
        };
        /**
         * Name of the [User](#schema_user)
         */
        name?: string;
        /**
         * Picture URL of the [User](#schema_user)
         */
        pictureUrl?: string;
    };
}

interface UpdateUserRequestHeaders {
}
interface UpdateUserRequestQuery {
}
interface UpdateUserRequestParams {
    id: string;
}
interface UpdateUserRequestBody {
    /**
     * Tags for the [User](#schema_user)
     */
    tags?: {
        [k: string]: string;
    };
    /**
     * Name of the user
     */
    name?: string;
    /**
     * URI of the user picture
     */
    pictureUrl?: string | null;
}
type UpdateUserInput = UpdateUserRequestBody & UpdateUserRequestHeaders & UpdateUserRequestQuery & UpdateUserRequestParams;
interface UpdateUserResponse {
    /**
     * The user object represents someone interacting with the bot within a specific integration. The same person interacting with a bot in slack and messenger will be represented with two different users.
     */
    user: {
        /**
         * Id of the [User](#schema_user)
         */
        id: string;
        /**
         * Creation date of the [User](#schema_user) in ISO 8601 format
         */
        createdAt: string;
        /**
         * Updating date of the [User](#schema_user) in ISO 8601 format
         */
        updatedAt: string;
        /**
         * Set of [Tags](/docs/developers/concepts/tags) that you can attach to a [User](#schema_user). The set of [Tags](/docs/developers/concepts/tags) available on a [User](#schema_user) is restricted by the list of [Tags](/docs/developers/concepts/tags) defined previously by the [Bot](#schema_bot). Individual keys can be unset by posting an empty value to them.
         */
        tags: {
            [k: string]: string;
        };
        /**
         * Name of the [User](#schema_user)
         */
        name?: string;
        /**
         * Picture URL of the [User](#schema_user)
         */
        pictureUrl?: string;
    };
}

interface DeleteUserRequestHeaders {
}
interface DeleteUserRequestQuery {
}
interface DeleteUserRequestParams {
    id: string;
}
interface DeleteUserRequestBody {
}
type DeleteUserInput = DeleteUserRequestBody & DeleteUserRequestHeaders & DeleteUserRequestQuery & DeleteUserRequestParams;
interface DeleteUserResponse {
}

interface SetStateExpiryRequestHeaders {
}
interface SetStateExpiryRequestQuery {
}
interface SetStateExpiryRequestParams {
    type: "conversation" | "user" | "bot" | "integration" | "task" | "workflow";
    id: string;
    name: string;
}
interface SetStateExpiryRequestBody {
    /**
     * Expiry of the [State](#schema_state) in milliseconds. The state will expire if it is idle for the configured value. By default, a state doesn't expire.
     */
    expiry: number | null;
}
type SetStateExpiryInput = SetStateExpiryRequestBody & SetStateExpiryRequestHeaders & SetStateExpiryRequestQuery & SetStateExpiryRequestParams;
interface SetStateExpiryResponse {
    /**
     * The state object represents the current payload. A state is always linked to either a bot, a conversation or a user.
     */
    state: {
        /**
         * Id of the [State](#schema_state)
         */
        id: string;
        /**
         * Creation date of the [State](#schema_state) in ISO 8601 format
         */
        createdAt: string;
        /**
         * Updating date of the [State](#schema_state) in ISO 8601 format
         */
        updatedAt: string;
        /**
         * Id of the [Bot](#schema_bot)
         */
        botId: string;
        /**
         * Id of the [Conversation](#schema_conversation)
         */
        conversationId?: string;
        /**
         * Id of the [User](#schema_user)
         */
        userId?: string;
        /**
         * Name of the [State](#schema_state) which is declared inside the bot definition
         */
        name: string;
        /**
         * Type of the [State](#schema_state) represents the resource type (`conversation`, `user`, `bot`, `task`, `integration` or `workflow`) that the state is related to
         */
        type: "conversation" | "user" | "bot" | "task" | "integration" | "workflow";
        /**
         * Payload is the content of the state defined by your bot.
         */
        payload: {
            [k: string]: any;
        };
    };
}

interface GetStateRequestHeaders {
}
interface GetStateRequestQuery {
}
interface GetStateRequestParams {
    type: "conversation" | "user" | "bot" | "integration" | "task" | "workflow";
    id: string;
    name: string;
}
interface GetStateRequestBody {
}
type GetStateInput = GetStateRequestBody & GetStateRequestHeaders & GetStateRequestQuery & GetStateRequestParams;
interface GetStateResponse {
    /**
     * The state object represents the current payload. A state is always linked to either a bot, a conversation or a user.
     */
    state: {
        /**
         * Id of the [State](#schema_state)
         */
        id: string;
        /**
         * Creation date of the [State](#schema_state) in ISO 8601 format
         */
        createdAt: string;
        /**
         * Updating date of the [State](#schema_state) in ISO 8601 format
         */
        updatedAt: string;
        /**
         * Id of the [Bot](#schema_bot)
         */
        botId: string;
        /**
         * Id of the [Conversation](#schema_conversation)
         */
        conversationId?: string;
        /**
         * Id of the [User](#schema_user)
         */
        userId?: string;
        /**
         * Name of the [State](#schema_state) which is declared inside the bot definition
         */
        name: string;
        /**
         * Type of the [State](#schema_state) represents the resource type (`conversation`, `user`, `bot`, `task`, `integration` or `workflow`) that the state is related to
         */
        type: "conversation" | "user" | "bot" | "task" | "integration" | "workflow";
        /**
         * Payload is the content of the state defined by your bot.
         */
        payload: {
            [k: string]: any;
        };
    };
    meta: {
        cached: boolean;
    };
}

interface SetStateRequestHeaders {
}
interface SetStateRequestQuery {
}
interface SetStateRequestParams {
    type: "conversation" | "user" | "bot" | "integration" | "task" | "workflow";
    id: string;
    name: string;
}
interface SetStateRequestBody {
    /**
     * Payload is the content of the state defined by your bot.
     */
    payload: {
        [k: string]: any;
    } | null;
    /**
     * Expiry of the [State](#schema_state) in milliseconds. The state will expire if it is idle for the configured value. By default, a state doesn't expire.
     */
    expiry?: number | null;
}
type SetStateInput = SetStateRequestBody & SetStateRequestHeaders & SetStateRequestQuery & SetStateRequestParams;
interface SetStateResponse {
    /**
     * The state object represents the current payload. A state is always linked to either a bot, a conversation or a user.
     */
    state: {
        /**
         * Id of the [State](#schema_state)
         */
        id: string;
        /**
         * Creation date of the [State](#schema_state) in ISO 8601 format
         */
        createdAt: string;
        /**
         * Updating date of the [State](#schema_state) in ISO 8601 format
         */
        updatedAt: string;
        /**
         * Id of the [Bot](#schema_bot)
         */
        botId: string;
        /**
         * Id of the [Conversation](#schema_conversation)
         */
        conversationId?: string;
        /**
         * Id of the [User](#schema_user)
         */
        userId?: string;
        /**
         * Name of the [State](#schema_state) which is declared inside the bot definition
         */
        name: string;
        /**
         * Type of the [State](#schema_state) represents the resource type (`conversation`, `user`, `bot`, `task`, `integration` or `workflow`) that the state is related to
         */
        type: "conversation" | "user" | "bot" | "task" | "integration" | "workflow";
        /**
         * Payload is the content of the state defined by your bot.
         */
        payload: {
            [k: string]: any;
        };
    };
}

interface GetOrSetStateRequestHeaders {
}
interface GetOrSetStateRequestQuery {
}
interface GetOrSetStateRequestParams {
    type: "conversation" | "user" | "bot" | "integration" | "task" | "workflow";
    id: string;
    name: string;
}
interface GetOrSetStateRequestBody {
    /**
     * Payload is the content of the state defined by your bot.
     */
    payload: {
        [k: string]: any;
    };
    /**
     * Expiry of the [State](#schema_state) in milliseconds. The state will expire if it is idle for the configured value. By default, a state doesn't expire.
     */
    expiry?: number | null;
}
type GetOrSetStateInput = GetOrSetStateRequestBody & GetOrSetStateRequestHeaders & GetOrSetStateRequestQuery & GetOrSetStateRequestParams;
interface GetOrSetStateResponse {
    /**
     * The state object represents the current payload. A state is always linked to either a bot, a conversation or a user.
     */
    state: {
        /**
         * Id of the [State](#schema_state)
         */
        id: string;
        /**
         * Creation date of the [State](#schema_state) in ISO 8601 format
         */
        createdAt: string;
        /**
         * Updating date of the [State](#schema_state) in ISO 8601 format
         */
        updatedAt: string;
        /**
         * Id of the [Bot](#schema_bot)
         */
        botId: string;
        /**
         * Id of the [Conversation](#schema_conversation)
         */
        conversationId?: string;
        /**
         * Id of the [User](#schema_user)
         */
        userId?: string;
        /**
         * Name of the [State](#schema_state) which is declared inside the bot definition
         */
        name: string;
        /**
         * Type of the [State](#schema_state) represents the resource type (`conversation`, `user`, `bot`, `task`, `integration` or `workflow`) that the state is related to
         */
        type: "conversation" | "user" | "bot" | "task" | "integration" | "workflow";
        /**
         * Payload is the content of the state defined by your bot.
         */
        payload: {
            [k: string]: any;
        };
    };
    meta: {
        cached: boolean;
    };
}

interface PatchStateRequestHeaders {
}
interface PatchStateRequestQuery {
}
interface PatchStateRequestParams {
    type: "conversation" | "user" | "bot" | "integration" | "task" | "workflow";
    id: string;
    name: string;
}
interface PatchStateRequestBody {
    /**
     * Payload is the content of the state defined by your bot.
     */
    payload: {
        [k: string]: any;
    };
}
type PatchStateInput = PatchStateRequestBody & PatchStateRequestHeaders & PatchStateRequestQuery & PatchStateRequestParams;
interface PatchStateResponse {
    /**
     * The state object represents the current payload. A state is always linked to either a bot, a conversation or a user.
     */
    state: {
        /**
         * Id of the [State](#schema_state)
         */
        id: string;
        /**
         * Creation date of the [State](#schema_state) in ISO 8601 format
         */
        createdAt: string;
        /**
         * Updating date of the [State](#schema_state) in ISO 8601 format
         */
        updatedAt: string;
        /**
         * Id of the [Bot](#schema_bot)
         */
        botId: string;
        /**
         * Id of the [Conversation](#schema_conversation)
         */
        conversationId?: string;
        /**
         * Id of the [User](#schema_user)
         */
        userId?: string;
        /**
         * Name of the [State](#schema_state) which is declared inside the bot definition
         */
        name: string;
        /**
         * Type of the [State](#schema_state) represents the resource type (`conversation`, `user`, `bot`, `task`, `integration` or `workflow`) that the state is related to
         */
        type: "conversation" | "user" | "bot" | "task" | "integration" | "workflow";
        /**
         * Payload is the content of the state defined by your bot.
         */
        payload: {
            [k: string]: any;
        };
    };
}

interface CallActionRequestHeaders {
}
interface CallActionRequestQuery {
}
interface CallActionRequestParams {
}
interface CallActionRequestBody {
    /**
     * Type of the action
     */
    type: string;
    /**
     * Input of the action
     */
    input: {
        [k: string]: any;
    };
}
type CallActionInput = CallActionRequestBody & CallActionRequestHeaders & CallActionRequestQuery & CallActionRequestParams;
interface CallActionResponse {
    /**
     * Input of the action
     */
    output: {
        [k: string]: any;
    };
    meta: {
        cached: boolean;
    };
}

interface ConfigureIntegrationRequestHeaders {
}
interface ConfigureIntegrationRequestQuery {
}
interface ConfigureIntegrationRequestParams {
}
interface ConfigureIntegrationRequestBody {
    /**
     * Unique identifier of the integration that was installed on the bot
     */
    identifier: string;
}
type ConfigureIntegrationInput = ConfigureIntegrationRequestBody & ConfigureIntegrationRequestHeaders & ConfigureIntegrationRequestQuery & ConfigureIntegrationRequestParams;
interface ConfigureIntegrationResponse {
}

interface GetTaskRequestHeaders {
}
interface GetTaskRequestQuery {
}
interface GetTaskRequestParams {
    id: string;
}
interface GetTaskRequestBody {
}
type GetTaskInput = GetTaskRequestBody & GetTaskRequestHeaders & GetTaskRequestQuery & GetTaskRequestParams;
interface GetTaskResponse {
    /**
     * Task definition
     */
    task: {
        /**
         * Id of the [Task](#schema_task)
         */
        id: string;
        /**
         * Title describing the task
         */
        title: string;
        /**
         * All the notes related to the execution of the current task
         */
        description: string;
        /**
         * Type of the task
         */
        type: string;
        /**
         * Content related to the task
         */
        data: {
            [k: string]: any;
        };
        /**
         * Status of the task
         */
        status: "pending" | "in_progress" | "failed" | "completed" | "blocked" | "paused" | "timeout" | "cancelled";
        /**
         * Parent task id is the parent task that created this task
         */
        parentTaskId?: string;
        /**
         * Conversation id related to this task
         */
        conversationId?: string;
        /**
         * Specific user related to this task
         */
        userId?: string;
        /**
         * The timeout date where the task should be failed in the ISO 8601 format
         */
        timeoutAt: string;
        /**
         * Creation date of the task in ISO 8601 format
         */
        createdAt: string;
        /**
         * Updating date of the task in ISO 8601 format
         */
        updatedAt: string;
        /**
         * If the task fails this is the reason behind it
         */
        failureReason?: string;
        /**
         * Set of [Tags](/docs/developers/concepts/tags) that you can attach to a [Task](#schema_task). Individual keys can be unset by posting an empty value to them.
         */
        tags: {
            [k: string]: string;
        };
    };
}

interface CreateTaskRequestHeaders {
}
interface CreateTaskRequestQuery {
}
interface CreateTaskRequestParams {
}
interface CreateTaskRequestBody {
    /**
     * Title describing the task
     */
    title?: string;
    /**
     * All the notes related to the execution of the current task
     */
    description?: string;
    /**
     * Type of the task
     */
    type: string;
    /**
     * Content related to the task
     */
    data?: {
        [k: string]: any;
    };
    /**
     * Parent task id is the parent task that created this task
     */
    parentTaskId?: string;
    /**
     * Conversation id related to this task
     */
    conversationId: string;
    /**
     * Specific user related to this task
     */
    userId?: string;
    /**
     * The timeout date where the task should be failed in the ISO 8601 format
     */
    timeoutAt?: string;
    /**
     * Tags for the [Task](#schema_task)
     */
    tags?: {
        [k: string]: string;
    };
}
type CreateTaskInput = CreateTaskRequestBody & CreateTaskRequestHeaders & CreateTaskRequestQuery & CreateTaskRequestParams;
interface CreateTaskResponse {
    /**
     * Task definition
     */
    task: {
        /**
         * Id of the [Task](#schema_task)
         */
        id: string;
        /**
         * Title describing the task
         */
        title: string;
        /**
         * All the notes related to the execution of the current task
         */
        description: string;
        /**
         * Type of the task
         */
        type: string;
        /**
         * Content related to the task
         */
        data: {
            [k: string]: any;
        };
        /**
         * Status of the task
         */
        status: "pending" | "in_progress" | "failed" | "completed" | "blocked" | "paused" | "timeout" | "cancelled";
        /**
         * Parent task id is the parent task that created this task
         */
        parentTaskId?: string;
        /**
         * Conversation id related to this task
         */
        conversationId?: string;
        /**
         * Specific user related to this task
         */
        userId?: string;
        /**
         * The timeout date where the task should be failed in the ISO 8601 format
         */
        timeoutAt: string;
        /**
         * Creation date of the task in ISO 8601 format
         */
        createdAt: string;
        /**
         * Updating date of the task in ISO 8601 format
         */
        updatedAt: string;
        /**
         * If the task fails this is the reason behind it
         */
        failureReason?: string;
        /**
         * Set of [Tags](/docs/developers/concepts/tags) that you can attach to a [Task](#schema_task). Individual keys can be unset by posting an empty value to them.
         */
        tags: {
            [k: string]: string;
        };
    };
}

interface UpdateTaskRequestHeaders {
}
interface UpdateTaskRequestQuery {
}
interface UpdateTaskRequestParams {
    id: string;
}
interface UpdateTaskRequestBody {
    /**
     * Title describing the task
     */
    title?: string;
    /**
     * All the notes related to the execution of the current task
     */
    description?: string;
    /**
     * Content related to the task
     */
    data?: {
        [k: string]: any;
    };
    /**
     * The timeout date where the task should be failed in the ISO 8601 format
     */
    timeoutAt?: string;
    /**
     * Status of the task
     */
    status?: "pending" | "in_progress" | "failed" | "completed" | "blocked" | "paused" | "timeout" | "cancelled";
    /**
     * Tags for the [Task](#schema_task)
     */
    tags?: {
        [k: string]: string;
    };
}
type UpdateTaskInput = UpdateTaskRequestBody & UpdateTaskRequestHeaders & UpdateTaskRequestQuery & UpdateTaskRequestParams;
interface UpdateTaskResponse {
    /**
     * Task definition
     */
    task: {
        /**
         * Id of the [Task](#schema_task)
         */
        id: string;
        /**
         * Title describing the task
         */
        title: string;
        /**
         * All the notes related to the execution of the current task
         */
        description: string;
        /**
         * Type of the task
         */
        type: string;
        /**
         * Content related to the task
         */
        data: {
            [k: string]: any;
        };
        /**
         * Status of the task
         */
        status: "pending" | "in_progress" | "failed" | "completed" | "blocked" | "paused" | "timeout" | "cancelled";
        /**
         * Parent task id is the parent task that created this task
         */
        parentTaskId?: string;
        /**
         * Conversation id related to this task
         */
        conversationId?: string;
        /**
         * Specific user related to this task
         */
        userId?: string;
        /**
         * The timeout date where the task should be failed in the ISO 8601 format
         */
        timeoutAt: string;
        /**
         * Creation date of the task in ISO 8601 format
         */
        createdAt: string;
        /**
         * Updating date of the task in ISO 8601 format
         */
        updatedAt: string;
        /**
         * If the task fails this is the reason behind it
         */
        failureReason?: string;
        /**
         * Set of [Tags](/docs/developers/concepts/tags) that you can attach to a [Task](#schema_task). Individual keys can be unset by posting an empty value to them.
         */
        tags: {
            [k: string]: string;
        };
    };
}

interface DeleteTaskRequestHeaders {
}
interface DeleteTaskRequestQuery {
}
interface DeleteTaskRequestParams {
    id: string;
}
interface DeleteTaskRequestBody {
}
type DeleteTaskInput = DeleteTaskRequestBody & DeleteTaskRequestHeaders & DeleteTaskRequestQuery & DeleteTaskRequestParams;
interface DeleteTaskResponse {
}

interface ListTasksRequestHeaders {
}
interface ListTasksRequestQuery {
    nextToken?: string;
    tags?: {
        [k: string]: string;
    };
    conversationId?: string;
    userId?: string;
    parentTaskId?: string;
    status?: ("pending" | "in_progress" | "failed" | "completed" | "blocked" | "paused" | "timeout" | "cancelled")[];
    type?: string;
}
interface ListTasksRequestParams {
}
interface ListTasksRequestBody {
}
type ListTasksInput = ListTasksRequestBody & ListTasksRequestHeaders & ListTasksRequestQuery & ListTasksRequestParams;
interface ListTasksResponse {
    tasks: {
        /**
         * Id of the [Task](#schema_task)
         */
        id: string;
        /**
         * Title describing the task
         */
        title: string;
        /**
         * All the notes related to the execution of the current task
         */
        description: string;
        /**
         * Type of the task
         */
        type: string;
        /**
         * Content related to the task
         */
        data: {
            [k: string]: any;
        };
        /**
         * Status of the task
         */
        status: "pending" | "in_progress" | "failed" | "completed" | "blocked" | "paused" | "timeout" | "cancelled";
        /**
         * Parent task id is the parent task that created this task
         */
        parentTaskId?: string;
        /**
         * Conversation id related to this task
         */
        conversationId?: string;
        /**
         * Specific user related to this task
         */
        userId?: string;
        /**
         * The timeout date where the task should be failed in the ISO 8601 format
         */
        timeoutAt: string;
        /**
         * Creation date of the task in ISO 8601 format
         */
        createdAt: string;
        /**
         * Updating date of the task in ISO 8601 format
         */
        updatedAt: string;
        /**
         * If the task fails this is the reason behind it
         */
        failureReason?: string;
        /**
         * Set of [Tags](/docs/developers/concepts/tags) that you can attach to a [Task](#schema_task). Individual keys can be unset by posting an empty value to them.
         */
        tags: {
            [k: string]: string;
        };
    }[];
    meta: {
        /**
         * The token to use to retrieve the next page of results, passed as a query string parameter (value should be URL-encoded) to this API endpoint.
         */
        nextToken?: string;
    };
}

interface CreateWorkflowRequestHeaders {
}
interface CreateWorkflowRequestQuery {
}
interface CreateWorkflowRequestParams {
}
interface CreateWorkflowRequestBody {
    /**
     * Name of the workflow
     */
    name: string;
    /**
     * Content related to the workflow
     */
    input?: {
        [k: string]: any;
    };
    /**
     * Parent workflow id is the parent workflow that created this workflow
     */
    parentWorkflowId?: string;
    /**
     * Conversation id related to this workflow
     */
    conversationId?: string;
    /**
     * Specific user related to this workflow
     */
    userId?: string;
    /**
     * The timeout date where the workflow should be failed in the ISO 8601 format
     */
    timeoutAt?: string;
    /**
     * Tags for the [Workflow](#schema_workflow)
     */
    tags?: {
        [k: string]: string;
    };
    status: "pending" | "in_progress";
    /**
     * Event id must be specified if the workflow is created with the status in_progress
     */
    eventId?: string;
}
type CreateWorkflowInput = CreateWorkflowRequestBody & CreateWorkflowRequestHeaders & CreateWorkflowRequestQuery & CreateWorkflowRequestParams;
interface CreateWorkflowResponse {
    /**
     * Workflow definition
     */
    workflow: {
        /**
         * Id of the [Workflow](#schema_workflow)
         */
        id: string;
        /**
         * Name of the workflow
         */
        name: string;
        /**
         * Status of the [Workflow](#schema_workflow)
         */
        status: "pending" | "in_progress" | "failed" | "completed" | "listening" | "paused" | "timedout" | "cancelled";
        /**
         * Input provided to the [Workflow](#schema_workflow)
         */
        input: {
            [k: string]: any;
        };
        /**
         * Data returned by the [Workflow](#schema_workflow) output
         */
        output: {
            [k: string]: any;
        };
        /**
         * Parent [Workflow](#schema_workflow) id is the parent [Workflow](#schema_workflow) that created this [Workflow](#schema_workflow)
         */
        parentWorkflowId?: string;
        /**
         * Conversation id related to this [Workflow](#schema_workflow)
         */
        conversationId?: string;
        /**
         * User id related to this [Workflow](#schema_workflow)
         */
        userId?: string;
        /**
         * Creation date of the [Workflow](#schema_workflow) in ISO 8601 format
         */
        createdAt: string;
        /**
         * Updating date of the [Workflow](#schema_workflow) in ISO 8601 format
         */
        updatedAt: string;
        /**
         * The date when the [Workflow](#schema_workflow) completed in ISO 8601 format
         */
        completedAt?: string;
        /**
         * If the [Workflow](#schema_workflow) fails this is the reason behind it
         */
        failureReason?: string;
        /**
         * The timeout date when the [Workflow](#schema_workflow) will fail in the ISO 8601 format
         */
        timeoutAt: string;
        /**
         * Set of [Tags](/docs/developers/concepts/tags) that you can attach to a [Workflow](#schema_workflow). Individual keys can be unset by posting an empty value to them.
         */
        tags: {
            [k: string]: string;
        };
    };
}

interface GetWorkflowRequestHeaders {
}
interface GetWorkflowRequestQuery {
}
interface GetWorkflowRequestParams {
    id: string;
}
interface GetWorkflowRequestBody {
}
type GetWorkflowInput = GetWorkflowRequestBody & GetWorkflowRequestHeaders & GetWorkflowRequestQuery & GetWorkflowRequestParams;
interface GetWorkflowResponse {
    /**
     * Workflow definition
     */
    workflow: {
        /**
         * Id of the [Workflow](#schema_workflow)
         */
        id: string;
        /**
         * Name of the workflow
         */
        name: string;
        /**
         * Status of the [Workflow](#schema_workflow)
         */
        status: "pending" | "in_progress" | "failed" | "completed" | "listening" | "paused" | "timedout" | "cancelled";
        /**
         * Input provided to the [Workflow](#schema_workflow)
         */
        input: {
            [k: string]: any;
        };
        /**
         * Data returned by the [Workflow](#schema_workflow) output
         */
        output: {
            [k: string]: any;
        };
        /**
         * Parent [Workflow](#schema_workflow) id is the parent [Workflow](#schema_workflow) that created this [Workflow](#schema_workflow)
         */
        parentWorkflowId?: string;
        /**
         * Conversation id related to this [Workflow](#schema_workflow)
         */
        conversationId?: string;
        /**
         * User id related to this [Workflow](#schema_workflow)
         */
        userId?: string;
        /**
         * Creation date of the [Workflow](#schema_workflow) in ISO 8601 format
         */
        createdAt: string;
        /**
         * Updating date of the [Workflow](#schema_workflow) in ISO 8601 format
         */
        updatedAt: string;
        /**
         * The date when the [Workflow](#schema_workflow) completed in ISO 8601 format
         */
        completedAt?: string;
        /**
         * If the [Workflow](#schema_workflow) fails this is the reason behind it
         */
        failureReason?: string;
        /**
         * The timeout date when the [Workflow](#schema_workflow) will fail in the ISO 8601 format
         */
        timeoutAt: string;
        /**
         * Set of [Tags](/docs/developers/concepts/tags) that you can attach to a [Workflow](#schema_workflow). Individual keys can be unset by posting an empty value to them.
         */
        tags: {
            [k: string]: string;
        };
    };
}

interface UpdateWorkflowRequestHeaders {
}
interface UpdateWorkflowRequestQuery {
}
interface UpdateWorkflowRequestParams {
    id: string;
}
interface UpdateWorkflowRequestBody {
    /**
     * Content related to the workflow
     */
    output?: {
        [k: string]: any;
    };
    /**
     * The timeout date where the workflow should be failed in the ISO 8601 format
     */
    timeoutAt?: string;
    /**
     * Status of the workflow
     */
    status?: "completed" | "cancelled" | "listening" | "paused" | "failed";
    /**
     * Reason why the workflow failed
     */
    failureReason?: string;
    /**
     * Tags for the [Workflow](#schema_workflow)
     */
    tags?: {
        [k: string]: string;
    };
    /**
     * Specific user related to this workflow
     */
    userId?: string;
}
type UpdateWorkflowInput = UpdateWorkflowRequestBody & UpdateWorkflowRequestHeaders & UpdateWorkflowRequestQuery & UpdateWorkflowRequestParams;
interface UpdateWorkflowResponse {
    /**
     * Workflow definition
     */
    workflow: {
        /**
         * Id of the [Workflow](#schema_workflow)
         */
        id: string;
        /**
         * Name of the workflow
         */
        name: string;
        /**
         * Status of the [Workflow](#schema_workflow)
         */
        status: "pending" | "in_progress" | "failed" | "completed" | "listening" | "paused" | "timedout" | "cancelled";
        /**
         * Input provided to the [Workflow](#schema_workflow)
         */
        input: {
            [k: string]: any;
        };
        /**
         * Data returned by the [Workflow](#schema_workflow) output
         */
        output: {
            [k: string]: any;
        };
        /**
         * Parent [Workflow](#schema_workflow) id is the parent [Workflow](#schema_workflow) that created this [Workflow](#schema_workflow)
         */
        parentWorkflowId?: string;
        /**
         * Conversation id related to this [Workflow](#schema_workflow)
         */
        conversationId?: string;
        /**
         * User id related to this [Workflow](#schema_workflow)
         */
        userId?: string;
        /**
         * Creation date of the [Workflow](#schema_workflow) in ISO 8601 format
         */
        createdAt: string;
        /**
         * Updating date of the [Workflow](#schema_workflow) in ISO 8601 format
         */
        updatedAt: string;
        /**
         * The date when the [Workflow](#schema_workflow) completed in ISO 8601 format
         */
        completedAt?: string;
        /**
         * If the [Workflow](#schema_workflow) fails this is the reason behind it
         */
        failureReason?: string;
        /**
         * The timeout date when the [Workflow](#schema_workflow) will fail in the ISO 8601 format
         */
        timeoutAt: string;
        /**
         * Set of [Tags](/docs/developers/concepts/tags) that you can attach to a [Workflow](#schema_workflow). Individual keys can be unset by posting an empty value to them.
         */
        tags: {
            [k: string]: string;
        };
    };
}

interface DeleteWorkflowRequestHeaders {
}
interface DeleteWorkflowRequestQuery {
}
interface DeleteWorkflowRequestParams {
    id: string;
}
interface DeleteWorkflowRequestBody {
}
type DeleteWorkflowInput = DeleteWorkflowRequestBody & DeleteWorkflowRequestHeaders & DeleteWorkflowRequestQuery & DeleteWorkflowRequestParams;
interface DeleteWorkflowResponse {
}

interface ListWorkflowsRequestHeaders {
}
interface ListWorkflowsRequestQuery {
    nextToken?: string;
    tags?: {
        [k: string]: string;
    };
    conversationId?: string;
    userId?: string;
    parentWorkflowId?: string;
    statuses?: ("pending" | "in_progress" | "failed" | "completed" | "listening" | "paused" | "timedout" | "cancelled")[];
    name?: string;
}
interface ListWorkflowsRequestParams {
}
interface ListWorkflowsRequestBody {
}
type ListWorkflowsInput = ListWorkflowsRequestBody & ListWorkflowsRequestHeaders & ListWorkflowsRequestQuery & ListWorkflowsRequestParams;
interface ListWorkflowsResponse {
    workflows: {
        /**
         * Id of the [Workflow](#schema_workflow)
         */
        id: string;
        /**
         * Name of the workflow
         */
        name: string;
        /**
         * Status of the [Workflow](#schema_workflow)
         */
        status: "pending" | "in_progress" | "failed" | "completed" | "listening" | "paused" | "timedout" | "cancelled";
        /**
         * Input provided to the [Workflow](#schema_workflow)
         */
        input: {
            [k: string]: any;
        };
        /**
         * Data returned by the [Workflow](#schema_workflow) output
         */
        output: {
            [k: string]: any;
        };
        /**
         * Parent [Workflow](#schema_workflow) id is the parent [Workflow](#schema_workflow) that created this [Workflow](#schema_workflow)
         */
        parentWorkflowId?: string;
        /**
         * Conversation id related to this [Workflow](#schema_workflow)
         */
        conversationId?: string;
        /**
         * User id related to this [Workflow](#schema_workflow)
         */
        userId?: string;
        /**
         * Creation date of the [Workflow](#schema_workflow) in ISO 8601 format
         */
        createdAt: string;
        /**
         * Updating date of the [Workflow](#schema_workflow) in ISO 8601 format
         */
        updatedAt: string;
        /**
         * The date when the [Workflow](#schema_workflow) completed in ISO 8601 format
         */
        completedAt?: string;
        /**
         * If the [Workflow](#schema_workflow) fails this is the reason behind it
         */
        failureReason?: string;
        /**
         * The timeout date when the [Workflow](#schema_workflow) will fail in the ISO 8601 format
         */
        timeoutAt: string;
        /**
         * Set of [Tags](/docs/developers/concepts/tags) that you can attach to a [Workflow](#schema_workflow). Individual keys can be unset by posting an empty value to them.
         */
        tags: {
            [k: string]: string;
        };
    }[];
    meta: {
        /**
         * The token to use to retrieve the next page of results, passed as a query string parameter (value should be URL-encoded) to this API endpoint.
         */
        nextToken?: string;
    };
}

interface GetOrCreateWorkflowRequestHeaders {
}
interface GetOrCreateWorkflowRequestQuery {
}
interface GetOrCreateWorkflowRequestParams {
}
interface GetOrCreateWorkflowRequestBody {
    /**
     * Name of the workflow
     */
    name: string;
    /**
     * Content related to the workflow
     */
    input?: {
        [k: string]: any;
    };
    /**
     * Parent workflow id is the parent workflow that created this workflow
     */
    parentWorkflowId?: string;
    /**
     * Conversation id related to this workflow
     */
    conversationId?: string;
    /**
     * Specific user related to this workflow
     */
    userId?: string;
    /**
     * The timeout date where the workflow should be failed in the ISO 8601 format
     */
    timeoutAt?: string;
    /**
     * Tags for the [Workflow](#schema_workflow)
     */
    tags?: {
        [k: string]: string;
    };
    status: "pending" | "in_progress";
    /**
     * Event id must be specified if the workflow is created with the status in_progress
     */
    eventId?: string;
}
type GetOrCreateWorkflowInput = GetOrCreateWorkflowRequestBody & GetOrCreateWorkflowRequestHeaders & GetOrCreateWorkflowRequestQuery & GetOrCreateWorkflowRequestParams;
interface GetOrCreateWorkflowResponse {
    /**
     * Workflow definition
     */
    workflow: {
        /**
         * Id of the [Workflow](#schema_workflow)
         */
        id: string;
        /**
         * Name of the workflow
         */
        name: string;
        /**
         * Status of the [Workflow](#schema_workflow)
         */
        status: "pending" | "in_progress" | "failed" | "completed" | "listening" | "paused" | "timedout" | "cancelled";
        /**
         * Input provided to the [Workflow](#schema_workflow)
         */
        input: {
            [k: string]: any;
        };
        /**
         * Data returned by the [Workflow](#schema_workflow) output
         */
        output: {
            [k: string]: any;
        };
        /**
         * Parent [Workflow](#schema_workflow) id is the parent [Workflow](#schema_workflow) that created this [Workflow](#schema_workflow)
         */
        parentWorkflowId?: string;
        /**
         * Conversation id related to this [Workflow](#schema_workflow)
         */
        conversationId?: string;
        /**
         * User id related to this [Workflow](#schema_workflow)
         */
        userId?: string;
        /**
         * Creation date of the [Workflow](#schema_workflow) in ISO 8601 format
         */
        createdAt: string;
        /**
         * Updating date of the [Workflow](#schema_workflow) in ISO 8601 format
         */
        updatedAt: string;
        /**
         * The date when the [Workflow](#schema_workflow) completed in ISO 8601 format
         */
        completedAt?: string;
        /**
         * If the [Workflow](#schema_workflow) fails this is the reason behind it
         */
        failureReason?: string;
        /**
         * The timeout date when the [Workflow](#schema_workflow) will fail in the ISO 8601 format
         */
        timeoutAt: string;
        /**
         * Set of [Tags](/docs/developers/concepts/tags) that you can attach to a [Workflow](#schema_workflow). Individual keys can be unset by posting an empty value to them.
         */
        tags: {
            [k: string]: string;
        };
    };
}

interface TrackAnalyticsRequestHeaders {
}
interface TrackAnalyticsRequestQuery {
}
interface TrackAnalyticsRequestParams {
}
interface TrackAnalyticsRequestBody {
    name: string;
    count: number;
}
type TrackAnalyticsInput = TrackAnalyticsRequestBody & TrackAnalyticsRequestHeaders & TrackAnalyticsRequestQuery & TrackAnalyticsRequestParams;
interface TrackAnalyticsResponse {
}

interface RunVrlRequestHeaders {
}
interface RunVrlRequestQuery {
}
interface RunVrlRequestParams {
}
interface RunVrlRequestBody {
    data: {
        [k: string]: any;
    };
    script: string;
}
type RunVrlInput = RunVrlRequestBody & RunVrlRequestHeaders & RunVrlRequestQuery & RunVrlRequestParams;
interface RunVrlResponse {
    data: {
        [k: string]: any;
    };
    result?: any;
}

interface GetAccountRequestHeaders {
}
interface GetAccountRequestQuery {
}
interface GetAccountRequestParams {
}
interface GetAccountRequestBody {
}
type GetAccountInput = GetAccountRequestBody & GetAccountRequestHeaders & GetAccountRequestQuery & GetAccountRequestParams;
interface GetAccountResponse {
    account: {
        id: string;
        email: string;
        displayName?: string;
        emailVerified: boolean;
        profilePicture?: string;
        /**
         * Creation date of the [Account](#schema_account) in ISO 8601 format
         */
        createdAt: string;
    };
}

interface UpdateAccountRequestHeaders {
}
interface UpdateAccountRequestQuery {
}
interface UpdateAccountRequestParams {
}
interface UpdateAccountRequestBody {
    displayName?: string;
    profilePicture?: string;
    refresh?: boolean;
}
type UpdateAccountInput = UpdateAccountRequestBody & UpdateAccountRequestHeaders & UpdateAccountRequestQuery & UpdateAccountRequestParams;
interface UpdateAccountResponse {
    account: {
        id: string;
        email: string;
        displayName?: string;
        emailVerified: boolean;
        profilePicture?: string;
        /**
         * Creation date of the [Account](#schema_account) in ISO 8601 format
         */
        createdAt: string;
    };
}

interface ListPersonalAccessTokensRequestHeaders {
}
interface ListPersonalAccessTokensRequestQuery {
}
interface ListPersonalAccessTokensRequestParams {
}
interface ListPersonalAccessTokensRequestBody {
}
type ListPersonalAccessTokensInput = ListPersonalAccessTokensRequestBody & ListPersonalAccessTokensRequestHeaders & ListPersonalAccessTokensRequestQuery & ListPersonalAccessTokensRequestParams;
interface ListPersonalAccessTokensResponse {
    pats: {
        id: string;
        createdAt: string;
        note: string;
    }[];
}

interface CreatePersonalAccessTokenRequestHeaders {
}
interface CreatePersonalAccessTokenRequestQuery {
}
interface CreatePersonalAccessTokenRequestParams {
}
interface CreatePersonalAccessTokenRequestBody {
    /**
     * Note to identify the PAT
     */
    note: string;
}
type CreatePersonalAccessTokenInput = CreatePersonalAccessTokenRequestBody & CreatePersonalAccessTokenRequestHeaders & CreatePersonalAccessTokenRequestQuery & CreatePersonalAccessTokenRequestParams;
interface CreatePersonalAccessTokenResponse {
    pat: {
        id: string;
        createdAt: string;
        note: string;
        /**
         * The PAT value. This will only be returned here when created and cannot be retrieved later.
         */
        value: string;
    };
}

interface DeletePersonalAccessTokenRequestHeaders {
}
interface DeletePersonalAccessTokenRequestQuery {
}
interface DeletePersonalAccessTokenRequestParams {
    id: string;
}
interface DeletePersonalAccessTokenRequestBody {
}
type DeletePersonalAccessTokenInput = DeletePersonalAccessTokenRequestBody & DeletePersonalAccessTokenRequestHeaders & DeletePersonalAccessTokenRequestQuery & DeletePersonalAccessTokenRequestParams;
interface DeletePersonalAccessTokenResponse {
}

interface SetAccountPreferenceRequestHeaders {
}
interface SetAccountPreferenceRequestQuery {
}
interface SetAccountPreferenceRequestParams {
    key: string;
}
interface SetAccountPreferenceRequestBody {
    value?: any;
}
type SetAccountPreferenceInput = SetAccountPreferenceRequestBody & SetAccountPreferenceRequestHeaders & SetAccountPreferenceRequestQuery & SetAccountPreferenceRequestParams;
interface SetAccountPreferenceResponse {
}

interface GetAccountPreferenceRequestHeaders {
}
interface GetAccountPreferenceRequestQuery {
}
interface GetAccountPreferenceRequestParams {
    key: string;
}
interface GetAccountPreferenceRequestBody {
}
type GetAccountPreferenceInput = GetAccountPreferenceRequestBody & GetAccountPreferenceRequestHeaders & GetAccountPreferenceRequestQuery & GetAccountPreferenceRequestParams;
interface GetAccountPreferenceResponse {
    value?: any;
}

interface ListPublicIntegrationsRequestHeaders {
}
interface ListPublicIntegrationsRequestQuery {
    nextToken?: string;
    name?: string;
    version?: string;
}
interface ListPublicIntegrationsRequestParams {
}
interface ListPublicIntegrationsRequestBody {
}
type ListPublicIntegrationsInput = ListPublicIntegrationsRequestBody & ListPublicIntegrationsRequestHeaders & ListPublicIntegrationsRequestQuery & ListPublicIntegrationsRequestParams;
interface ListPublicIntegrationsResponse {
    integrations: {
        /**
         * ID of the [Integration](#schema_integration)
         */
        id: string;
        /**
         * Name of the [Integration](#schema_integration)
         */
        name: string;
        /**
         * Version of the [Integration](#schema_integration)
         */
        version: string;
        /**
         * Creation date of the [Integration](#schema_integration) in ISO 8601 format
         */
        createdAt: string;
        /**
         * Updating date of the [Integration](#schema_integration) in ISO 8601 format
         */
        updatedAt: string;
        /**
         * Title of the integration. This is the name that will be displayed in the UI
         */
        title: string;
        /**
         * Description of the integration. This is the description that will be displayed in the UI
         */
        description: string;
        /**
         * URL of the icon of the integration. This is the icon that will be displayed in the UI
         */
        iconUrl: string;
        /**
         * Idicates if the integration is public. Public integrations are available to all and cannot be updated without creating a new version.
         */
        public: boolean;
        /**
         * Status of the integration version verification
         */
        verificationStatus: "unapproved" | "pending" | "approved" | "rejected";
        ownerWorkspace: {
            id: string;
            handle: string | null;
            name: string;
        };
    }[];
    meta: {
        /**
         * The token to use to retrieve the next page of results, passed as a query string parameter (value should be URL-encoded) to this API endpoint.
         */
        nextToken?: string;
    };
}

interface GetPublicIntegrationByIdRequestHeaders {
}
interface GetPublicIntegrationByIdRequestQuery {
}
interface GetPublicIntegrationByIdRequestParams {
    id: string;
}
interface GetPublicIntegrationByIdRequestBody {
}
type GetPublicIntegrationByIdInput = GetPublicIntegrationByIdRequestBody & GetPublicIntegrationByIdRequestHeaders & GetPublicIntegrationByIdRequestQuery & GetPublicIntegrationByIdRequestParams;
interface GetPublicIntegrationByIdResponse {
    integration: {
        /**
         * ID of the [Integration](#schema_integration)
         */
        id: string;
        /**
         * Creation date of the [Integration](#schema_integration) in ISO 8601 format
         */
        createdAt: string;
        /**
         * Updating date of the [Integration](#schema_integration) in ISO 8601 format
         */
        updatedAt: string;
        /**
         * Global identifier configuration of the [Integration](#schema_integration)
         */
        identifier: {
            /**
             * VRL Script of the [Integration](#schema_integration) to handle incoming requests for a request that doesn't have an identifier
             */
            fallbackHandlerScript?: string;
            /**
             * VRL Script of the [Integration](#schema_integration) to extract the identifier from an incoming webhook often use for OAuth
             */
            extractScript?: string;
        };
        /**
         * URL of the [Integration](#schema_integration)
         */
        url: string;
        /**
         * Name of the [Integration](#schema_integration)
         */
        name: string;
        /**
         * Version of the [Integration](#schema_integration)
         */
        version: string;
        interfaces: {
            [k: string]: {
                id: string;
                /**
                 * Name of the interface
                 */
                name: string;
                entities: {
                    [k: string]: {
                        name: string;
                    };
                };
                actions: {
                    [k: string]: {
                        name: string;
                    };
                };
                events: {
                    [k: string]: {
                        name: string;
                    };
                };
            };
        };
        /**
         * Configuration definition
         */
        configuration: {
            /**
             * Title of the configuration
             */
            title?: string;
            /**
             * Description of the configuration
             */
            description?: string;
            /**
             * Identifier configuration of the [Integration](#schema_integration)
             */
            identifier: {
                linkTemplateScript?: string;
                required: boolean;
            };
            /**
             * Schema of the configuration in the `JSON schema` format. The configuration data is validated against this `JSON schema`.
             */
            schema?: {
                [k: string]: any;
            };
        };
        configurations: {
            /**
             * Configuration definition
             */
            [k: string]: {
                /**
                 * Title of the configuration
                 */
                title?: string;
                /**
                 * Description of the configuration
                 */
                description?: string;
                /**
                 * Identifier configuration of the [Integration](#schema_integration)
                 */
                identifier: {
                    linkTemplateScript?: string;
                    required: boolean;
                };
                /**
                 * Schema of the configuration in the `JSON schema` format. The configuration data is validated against this `JSON schema`.
                 */
                schema?: {
                    [k: string]: any;
                };
            };
        };
        channels: {
            /**
             * Channel definition
             */
            [k: string]: {
                /**
                 * Title of the channel
                 */
                title?: string;
                /**
                 * Description of the channel
                 */
                description?: string;
                messages: {
                    /**
                     * Message definition
                     */
                    [k: string]: {
                        schema: {
                            [k: string]: any;
                        };
                    };
                };
                /**
                 * Conversation object configuration
                 */
                conversation: {
                    tags: {
                        /**
                         * Definition of a tag that can be provided on the object
                         */
                        [k: string]: {
                            /**
                             * Title of the tag
                             */
                            title?: string;
                            /**
                             * Description of the tag
                             */
                            description?: string;
                        };
                    };
                    /**
                     * The conversation creation setting determines how to create a conversation through the API directly. The integration will have to implement the `createConversation` functionality to support this setting.
                     */
                    creation: {
                        /**
                         * Enable conversation creation
                         */
                        enabled: boolean;
                        /**
                         * The list of tags that are required to be specified when calling the API directly to create a conversation.
                         */
                        requiredTags: string[];
                    };
                };
                /**
                 * Message object configuration
                 */
                message: {
                    tags: {
                        /**
                         * Definition of a tag that can be provided on the object
                         */
                        [k: string]: {
                            /**
                             * Title of the tag
                             */
                            title?: string;
                            /**
                             * Description of the tag
                             */
                            description?: string;
                        };
                    };
                };
            };
        };
        states: {
            /**
             * State definition
             */
            [k: string]: {
                /**
                 * Type of the [State](#schema_state) (`conversation`, `user` or `integration`)
                 */
                type: "conversation" | "user" | "integration";
                /**
                 * Schema of the [State](#schema_state) in the `JSON schema` format. This `JSON schema` is going to be used for validating the state data.
                 */
                schema: {
                    [k: string]: any;
                };
            };
        };
        events: {
            /**
             * Event Definition
             */
            [k: string]: {
                /**
                 * Title of the event
                 */
                title?: string;
                /**
                 * Description of the event
                 */
                description?: string;
                schema: {
                    [k: string]: any;
                };
            };
        };
        actions: {
            /**
             * Action definition
             */
            [k: string]: {
                /**
                 * Title of the action
                 */
                title?: string;
                /**
                 * Description of the action
                 */
                description?: string;
                billable?: boolean;
                cacheable?: boolean;
                input: {
                    schema: {
                        [k: string]: any;
                    };
                };
                output: {
                    schema: {
                        [k: string]: any;
                    };
                };
            };
        };
        /**
         * User object configuration
         */
        user: {
            tags: {
                /**
                 * Definition of a tag that can be provided on the object
                 */
                [k: string]: {
                    /**
                     * Title of the tag
                     */
                    title?: string;
                    /**
                     * Description of the tag
                     */
                    description?: string;
                };
            };
            /**
             * The user creation setting determines how to create a user through the API directly. The integration will have to implement the `createUser` functionality to support this setting.
             */
            creation: {
                /**
                 * Enable user creation
                 */
                enabled: boolean;
                /**
                 * The list of tags that are required to be specified when calling the API directly to create a user.
                 */
                requiredTags: string[];
            };
        };
        entities: {
            /**
             * Entity definition
             */
            [k: string]: {
                /**
                 * Title of the entity
                 */
                title?: string;
                /**
                 * Description of the entity
                 */
                description?: string;
                schema: {
                    [k: string]: any;
                };
            };
        };
        /**
         * Indicates if the integration is a development integration; Dev integrations run locally
         */
        dev: boolean;
        /**
         * Title of the integration. This is the name that will be displayed in the UI
         */
        title: string;
        /**
         * Description of the integration. This is the description that will be displayed in the UI
         */
        description: string;
        /**
         * URL of the icon of the integration. This is the icon that will be displayed in the UI
         */
        iconUrl: string;
        /**
         * URL of the readme of the integration. This is the readme that will be displayed in the UI
         */
        readmeUrl: string;
        /**
         * Idicates if the integration is public. Public integrations are available to all and cannot be updated without creating a new version.
         */
        public: boolean;
        /**
         * Status of the integration version verification
         */
        verificationStatus: "unapproved" | "pending" | "approved" | "rejected";
        /**
         * Secrets are integration-wide values available in the code via environment variables formatted with a SECRET_ prefix followed by your secret name. A secret name must respect SCREAMING_SNAKE casing.
         */
        secrets: string[];
        ownerWorkspace: {
            id: string;
            handle: string | null;
            name: string;
        };
    };
}

interface GetPublicIntegrationRequestHeaders {
}
interface GetPublicIntegrationRequestQuery {
}
interface GetPublicIntegrationRequestParams {
    name: string;
    version: string;
}
interface GetPublicIntegrationRequestBody {
}
type GetPublicIntegrationInput = GetPublicIntegrationRequestBody & GetPublicIntegrationRequestHeaders & GetPublicIntegrationRequestQuery & GetPublicIntegrationRequestParams;
interface GetPublicIntegrationResponse {
    integration: {
        /**
         * ID of the [Integration](#schema_integration)
         */
        id: string;
        /**
         * Creation date of the [Integration](#schema_integration) in ISO 8601 format
         */
        createdAt: string;
        /**
         * Updating date of the [Integration](#schema_integration) in ISO 8601 format
         */
        updatedAt: string;
        /**
         * Global identifier configuration of the [Integration](#schema_integration)
         */
        identifier: {
            /**
             * VRL Script of the [Integration](#schema_integration) to handle incoming requests for a request that doesn't have an identifier
             */
            fallbackHandlerScript?: string;
            /**
             * VRL Script of the [Integration](#schema_integration) to extract the identifier from an incoming webhook often use for OAuth
             */
            extractScript?: string;
        };
        /**
         * URL of the [Integration](#schema_integration)
         */
        url: string;
        /**
         * Name of the [Integration](#schema_integration)
         */
        name: string;
        /**
         * Version of the [Integration](#schema_integration)
         */
        version: string;
        interfaces: {
            [k: string]: {
                id: string;
                /**
                 * Name of the interface
                 */
                name: string;
                entities: {
                    [k: string]: {
                        name: string;
                    };
                };
                actions: {
                    [k: string]: {
                        name: string;
                    };
                };
                events: {
                    [k: string]: {
                        name: string;
                    };
                };
            };
        };
        /**
         * Configuration definition
         */
        configuration: {
            /**
             * Title of the configuration
             */
            title?: string;
            /**
             * Description of the configuration
             */
            description?: string;
            /**
             * Identifier configuration of the [Integration](#schema_integration)
             */
            identifier: {
                linkTemplateScript?: string;
                required: boolean;
            };
            /**
             * Schema of the configuration in the `JSON schema` format. The configuration data is validated against this `JSON schema`.
             */
            schema?: {
                [k: string]: any;
            };
        };
        configurations: {
            /**
             * Configuration definition
             */
            [k: string]: {
                /**
                 * Title of the configuration
                 */
                title?: string;
                /**
                 * Description of the configuration
                 */
                description?: string;
                /**
                 * Identifier configuration of the [Integration](#schema_integration)
                 */
                identifier: {
                    linkTemplateScript?: string;
                    required: boolean;
                };
                /**
                 * Schema of the configuration in the `JSON schema` format. The configuration data is validated against this `JSON schema`.
                 */
                schema?: {
                    [k: string]: any;
                };
            };
        };
        channels: {
            /**
             * Channel definition
             */
            [k: string]: {
                /**
                 * Title of the channel
                 */
                title?: string;
                /**
                 * Description of the channel
                 */
                description?: string;
                messages: {
                    /**
                     * Message definition
                     */
                    [k: string]: {
                        schema: {
                            [k: string]: any;
                        };
                    };
                };
                /**
                 * Conversation object configuration
                 */
                conversation: {
                    tags: {
                        /**
                         * Definition of a tag that can be provided on the object
                         */
                        [k: string]: {
                            /**
                             * Title of the tag
                             */
                            title?: string;
                            /**
                             * Description of the tag
                             */
                            description?: string;
                        };
                    };
                    /**
                     * The conversation creation setting determines how to create a conversation through the API directly. The integration will have to implement the `createConversation` functionality to support this setting.
                     */
                    creation: {
                        /**
                         * Enable conversation creation
                         */
                        enabled: boolean;
                        /**
                         * The list of tags that are required to be specified when calling the API directly to create a conversation.
                         */
                        requiredTags: string[];
                    };
                };
                /**
                 * Message object configuration
                 */
                message: {
                    tags: {
                        /**
                         * Definition of a tag that can be provided on the object
                         */
                        [k: string]: {
                            /**
                             * Title of the tag
                             */
                            title?: string;
                            /**
                             * Description of the tag
                             */
                            description?: string;
                        };
                    };
                };
            };
        };
        states: {
            /**
             * State definition
             */
            [k: string]: {
                /**
                 * Type of the [State](#schema_state) (`conversation`, `user` or `integration`)
                 */
                type: "conversation" | "user" | "integration";
                /**
                 * Schema of the [State](#schema_state) in the `JSON schema` format. This `JSON schema` is going to be used for validating the state data.
                 */
                schema: {
                    [k: string]: any;
                };
            };
        };
        events: {
            /**
             * Event Definition
             */
            [k: string]: {
                /**
                 * Title of the event
                 */
                title?: string;
                /**
                 * Description of the event
                 */
                description?: string;
                schema: {
                    [k: string]: any;
                };
            };
        };
        actions: {
            /**
             * Action definition
             */
            [k: string]: {
                /**
                 * Title of the action
                 */
                title?: string;
                /**
                 * Description of the action
                 */
                description?: string;
                billable?: boolean;
                cacheable?: boolean;
                input: {
                    schema: {
                        [k: string]: any;
                    };
                };
                output: {
                    schema: {
                        [k: string]: any;
                    };
                };
            };
        };
        /**
         * User object configuration
         */
        user: {
            tags: {
                /**
                 * Definition of a tag that can be provided on the object
                 */
                [k: string]: {
                    /**
                     * Title of the tag
                     */
                    title?: string;
                    /**
                     * Description of the tag
                     */
                    description?: string;
                };
            };
            /**
             * The user creation setting determines how to create a user through the API directly. The integration will have to implement the `createUser` functionality to support this setting.
             */
            creation: {
                /**
                 * Enable user creation
                 */
                enabled: boolean;
                /**
                 * The list of tags that are required to be specified when calling the API directly to create a user.
                 */
                requiredTags: string[];
            };
        };
        entities: {
            /**
             * Entity definition
             */
            [k: string]: {
                /**
                 * Title of the entity
                 */
                title?: string;
                /**
                 * Description of the entity
                 */
                description?: string;
                schema: {
                    [k: string]: any;
                };
            };
        };
        /**
         * Indicates if the integration is a development integration; Dev integrations run locally
         */
        dev: boolean;
        /**
         * Title of the integration. This is the name that will be displayed in the UI
         */
        title: string;
        /**
         * Description of the integration. This is the description that will be displayed in the UI
         */
        description: string;
        /**
         * URL of the icon of the integration. This is the icon that will be displayed in the UI
         */
        iconUrl: string;
        /**
         * URL of the readme of the integration. This is the readme that will be displayed in the UI
         */
        readmeUrl: string;
        /**
         * Idicates if the integration is public. Public integrations are available to all and cannot be updated without creating a new version.
         */
        public: boolean;
        /**
         * Status of the integration version verification
         */
        verificationStatus: "unapproved" | "pending" | "approved" | "rejected";
        /**
         * Secrets are integration-wide values available in the code via environment variables formatted with a SECRET_ prefix followed by your secret name. A secret name must respect SCREAMING_SNAKE casing.
         */
        secrets: string[];
        ownerWorkspace: {
            id: string;
            handle: string | null;
            name: string;
        };
    };
}

interface CreateBotRequestHeaders {
}
interface CreateBotRequestQuery {
}
interface CreateBotRequestParams {
}
interface CreateBotRequestBody {
    /**
     * A mapping of states to their definition
     */
    states?: {
        [k: string]: {
            /**
             * Type of the [State](#schema_state) (`conversation`, `user`, `bot` or `task`)
             */
            type: "conversation" | "user" | "bot" | "task";
            /**
             * Schema of the [State](#schema_state) in the `JSON schema` format. This `JSON schema` is going to be used for validating the state data.
             */
            schema: {
                [k: string]: any;
            };
            /**
             * Expiry of the [State](#schema_state) in milliseconds. The state will expire if it is idle for the configured value. By default, a state doesn't expire.
             */
            expiry?: number;
        };
    };
    /**
     * Events definition
     */
    events?: {
        /**
         * Event Definition
         */
        [k: string]: {
            /**
             * Title of the event
             */
            title?: string;
            /**
             * Description of the event
             */
            description?: string;
            schema: {
                [k: string]: any;
            };
        };
    };
    recurringEvents?: {
        [k: string]: {
            schedule: {
                cron: string;
            };
            type: string;
            payload: {
                [k: string]: any;
            };
        };
    };
    /**
     * Subscriptions of the bot
     */
    subscriptions?: {
        /**
         * Events that the bot is currently subscribed on (ex: "slack:reactionAdded"). If null, the bot is subscribed to all events.
         */
        events: {
            [k: string]: {};
        } | null;
    };
    /**
     * Actions definition
     */
    actions?: {
        /**
         * Action definition
         */
        [k: string]: {
            /**
             * Title of the action
             */
            title?: string;
            /**
             * Description of the action
             */
            description?: string;
            billable?: boolean;
            cacheable?: boolean;
            input: {
                schema: {
                    [k: string]: any;
                };
            };
            output: {
                schema: {
                    [k: string]: any;
                };
            };
        };
    };
    configuration?: {
        /**
         * Configuration data
         */
        data?: {
            [k: string]: any;
        };
        /**
         * Schema of the configuration in the `JSON schema` format. The configuration data is validated against this `JSON schema`.
         */
        schema?: {
            [k: string]: any;
        };
    };
    user?: {
        tags?: {
            /**
             * Definition of a tag that can be provided on the object
             */
            [k: string]: {
                /**
                 * Title of the tag
                 */
                title?: string;
                /**
                 * Description of the tag
                 */
                description?: string;
            };
        };
    };
    conversation?: {
        tags?: {
            /**
             * Definition of a tag that can be provided on the object
             */
            [k: string]: {
                /**
                 * Title of the tag
                 */
                title?: string;
                /**
                 * Description of the tag
                 */
                description?: string;
            };
        };
    };
    message?: {
        tags?: {
            /**
             * Definition of a tag that can be provided on the object
             */
            [k: string]: {
                /**
                 * Title of the tag
                 */
                title?: string;
                /**
                 * Description of the tag
                 */
                description?: string;
            };
        };
    };
    /**
     * JavaScript code of the bot
     */
    code?: string;
    /**
     * Optional name for the bot, if not provided will be auto-generated
     */
    name?: string;
    /**
     * Media files associated with the [Bot](#schema_bot)
     */
    medias?: {
        url: string;
        name: string;
    }[];
    /**
     * URL of the [Bot](#schema_bot); Only available for dev bots
     */
    url?: string;
    /**
     * Indicates if the [Bot](#schema_bot) is a development bot; Development bots run locally and can install dev integrations
     */
    dev?: boolean;
}
type CreateBotInput = CreateBotRequestBody & CreateBotRequestHeaders & CreateBotRequestQuery & CreateBotRequestParams;
interface CreateBotResponse {
    bot: {
        /**
         * Id of the [Bot](#schema_bot)
         */
        id: string;
        /**
         * Creation date of the [Bot](#schema_bot) in ISO 8601 format
         */
        createdAt: string;
        /**
         * Updating date of the [Bot](#schema_bot) in ISO 8601 format
         */
        updatedAt: string;
        /**
         * Signing secret of the [Bot](#schema_bot)
         */
        signingSecret: string;
        /**
         * A mapping of integrations to their configuration
         */
        integrations: {
            [k: string]: {
                enabled: boolean;
                /**
                 * Name of the [Integration](#schema_integration)
                 */
                name: string;
                /**
                 * Version of the [Integration](#schema_integration)
                 */
                version: string;
                webhookUrl: string;
                webhookId: string;
                identifier?: string;
                configurationType: string | null;
                configuration: {
                    [k: string]: any;
                };
                status: "registration_pending" | "registered" | "registration_failed" | "unregistration_pending" | "unregistered" | "unregistration_failed";
                statusReason: string | null;
                /**
                 * ID of the [Integration](#schema_integration)
                 */
                id: string;
                /**
                 * Creation date of the [Integration](#schema_integration) in ISO 8601 format
                 */
                createdAt: string;
                /**
                 * Updating date of the [Integration](#schema_integration) in ISO 8601 format
                 */
                updatedAt: string;
                /**
                 * Title of the integration. This is the name that will be displayed in the UI
                 */
                title: string;
                /**
                 * Description of the integration. This is the description that will be displayed in the UI
                 */
                description: string;
                /**
                 * URL of the icon of the integration. This is the icon that will be displayed in the UI
                 */
                iconUrl: string;
                /**
                 * Idicates if the integration is public. Public integrations are available to all and cannot be updated without creating a new version.
                 */
                public: boolean;
                /**
                 * Status of the integration version verification
                 */
                verificationStatus: "unapproved" | "pending" | "approved" | "rejected";
            };
        };
        /**
         * User object configuration
         */
        user: {
            tags: {
                /**
                 * Definition of a tag that can be provided on the object
                 */
                [k: string]: {
                    /**
                     * Title of the tag
                     */
                    title?: string;
                    /**
                     * Description of the tag
                     */
                    description?: string;
                };
            };
        };
        /**
         * Conversation object configuration
         */
        conversation: {
            tags: {
                /**
                 * Definition of a tag that can be provided on the object
                 */
                [k: string]: {
                    /**
                     * Title of the tag
                     */
                    title?: string;
                    /**
                     * Description of the tag
                     */
                    description?: string;
                };
            };
        };
        /**
         * Message object configuration
         */
        message: {
            tags: {
                /**
                 * Definition of a tag that can be provided on the object
                 */
                [k: string]: {
                    /**
                     * Title of the tag
                     */
                    title?: string;
                    /**
                     * Description of the tag
                     */
                    description?: string;
                };
            };
        };
        /**
         * A mapping of states to their definition
         */
        states: {
            [k: string]: {
                /**
                 * Type of the [State](#schema_state) (`conversation`, `user`, `bot` or `task`)
                 */
                type: "conversation" | "user" | "bot" | "task";
                /**
                 * Schema of the [State](#schema_state) in the `JSON schema` format. This `JSON schema` is going to be used for validating the state data.
                 */
                schema: {
                    [k: string]: any;
                };
                /**
                 * Expiry of the [State](#schema_state) in milliseconds. The state will expire if it is idle for the configured value. By default, a state doesn't expire.
                 */
                expiry?: number;
            };
        };
        /**
         * Configuration of the bot
         */
        configuration: {
            /**
             * Configuration data
             */
            data: {
                [k: string]: any;
            };
            /**
             * Schema of the configuration in the `JSON schema` format. The configuration data is validated against this `JSON schema`.
             */
            schema: {
                [k: string]: any;
            };
        };
        /**
         * Events definition
         */
        events: {
            /**
             * Event Definition
             */
            [k: string]: {
                /**
                 * Title of the event
                 */
                title?: string;
                /**
                 * Description of the event
                 */
                description?: string;
                schema: {
                    [k: string]: any;
                };
            };
        };
        /**
         * Recurring events
         */
        recurringEvents: {
            [k: string]: {
                schedule: {
                    cron: string;
                };
                type: string;
                payload: {
                    [k: string]: any;
                };
                /**
                 * The number of times the recurring event failed to run. This counter resets once the recurring event runs successfully.
                 */
                failedAttempts: number;
                /**
                 * The reason why the recurring event failed to run in the last attempt.
                 */
                lastFailureReason: string | null;
            };
        };
        /**
         * Subscriptions of the bot
         */
        subscriptions: {
            /**
             * Events that the bot is currently subscribed on (ex: "slack:reactionAdded"). If null, the bot is subscribed to all events.
             */
            events: {
                [k: string]: {};
            } | null;
        };
        /**
         * Actions definition
         */
        actions: {
            /**
             * Action definition
             */
            [k: string]: {
                /**
                 * Title of the action
                 */
                title?: string;
                /**
                 * Description of the action
                 */
                description?: string;
                billable?: boolean;
                cacheable?: boolean;
                input: {
                    schema: {
                        [k: string]: any;
                    };
                };
                output: {
                    schema: {
                        [k: string]: any;
                    };
                };
            };
        };
        /**
         * Name of the [Bot](#schema_bot)
         */
        name: string;
        /**
         * Last deployment date of the [Bot](#schema_bot) in the ISO 8601 format
         */
        deployedAt?: string;
        /**
         * Indicates if the [Bot](#schema_bot) is a development bot; Development bots run locally and can install dev integrations
         */
        dev: boolean;
        /**
         * Id of the user that created the bot
         */
        createdBy?: string;
        /**
         * Indicates if the [Bot](#schema_bot) should be in always alive mode
         */
        alwaysAlive: boolean;
        /**
         * Status of the bot
         */
        status: "active" | "deploying";
        /**
         * Media files associated with the [Bot](#schema_bot)
         */
        medias: {
            /**
             * URL of the media file
             */
            url: string;
            /**
             * Name of the media file
             */
            name: string;
        }[];
    };
}

interface UpdateBotRequestHeaders {
}
interface UpdateBotRequestQuery {
}
interface UpdateBotRequestParams {
    id: string;
}
interface UpdateBotRequestBody {
    /**
     * URL of the [Bot](#schema_bot); Only available for dev bots
     */
    url?: string;
    /**
     * Type of the [Bot](#schema_bot) authentication (`iam`)
     */
    authentication?: "iam";
    configuration?: {
        /**
         * Configuration data
         */
        data?: {
            [k: string]: any;
        };
        /**
         * Schema of the configuration in the `JSON schema` format. The configuration data is validated against this `JSON schema`.
         */
        schema?: {
            [k: string]: any;
        };
    };
    blocked?: boolean;
    /**
     * Indicates if the [Bot](#schema_bot) should be in always alive mode
     */
    alwaysAlive?: boolean;
    user?: {
        tags?: {
            /**
             * Definition of a tag that can be provided on the object
             */
            [k: string]: {
                /**
                 * Title of the tag
                 */
                title?: string;
                /**
                 * Description of the tag
                 */
                description?: string;
            } | null;
        };
    };
    message?: {
        tags?: {
            /**
             * Definition of a tag that can be provided on the object
             */
            [k: string]: {
                /**
                 * Title of the tag
                 */
                title?: string;
                /**
                 * Description of the tag
                 */
                description?: string;
            } | null;
        };
    };
    conversation?: {
        tags?: {
            /**
             * Definition of a tag that can be provided on the object
             */
            [k: string]: {
                /**
                 * Title of the tag
                 */
                title?: string;
                /**
                 * Description of the tag
                 */
                description?: string;
            } | null;
        };
    };
    events?: {
        /**
         * Event Definition
         */
        [k: string]: {
            /**
             * Title of the event
             */
            title?: string;
            /**
             * Description of the event
             */
            description?: string;
            schema: {
                [k: string]: any;
            };
        } | null;
    };
    actions?: {
        /**
         * Action definition
         */
        [k: string]: {
            /**
             * Title of the action
             */
            title?: string;
            /**
             * Description of the action
             */
            description?: string;
            billable?: boolean;
            cacheable?: boolean;
            input: {
                schema: {
                    [k: string]: any;
                };
            };
            output: {
                schema: {
                    [k: string]: any;
                };
            };
        } | null;
    };
    states?: {
        [k: string]: {
            /**
             * Type of the [State](#schema_state) (`conversation`, `user`, `bot` or `task`)
             */
            type: "conversation" | "user" | "bot" | "task";
            /**
             * Schema of the [State](#schema_state) in the `JSON schema` format. This `JSON schema` is going to be used for validating the state data.
             */
            schema: {
                [k: string]: any;
            };
            /**
             * Expiry of the [State](#schema_state) in milliseconds. The state will expire if it is idle for the configured value. By default, a state doesn't expire.
             */
            expiry?: number;
        } | null;
    };
    recurringEvents?: {
        [k: string]: {
            schedule: {
                cron: string;
            };
            type: string;
            payload: {
                [k: string]: any;
            };
        } | null;
    };
    integrations?: {
        [k: string]: {
            enabled?: boolean;
            /**
             * Integration's configuration type. Set to default if null.
             */
            configurationType?: string | null;
            configuration?: {
                [k: string]: any;
            };
        } | null;
    };
    subscriptions?: {
        events: {
            [k: string]: {} | null;
        } | null;
    };
    /**
     * JavaScript code of the bot
     */
    code?: string;
    /**
     * Optional name for the bot, if not provided will be auto-generated
     */
    name?: string;
    /**
     * Media files associated with the [Bot](#schema_bot)
     */
    medias?: {
        url: string;
        name: string;
    }[];
}
type UpdateBotInput = UpdateBotRequestBody & UpdateBotRequestHeaders & UpdateBotRequestQuery & UpdateBotRequestParams;
interface UpdateBotResponse {
    bot: {
        /**
         * Id of the [Bot](#schema_bot)
         */
        id: string;
        /**
         * Creation date of the [Bot](#schema_bot) in ISO 8601 format
         */
        createdAt: string;
        /**
         * Updating date of the [Bot](#schema_bot) in ISO 8601 format
         */
        updatedAt: string;
        /**
         * Signing secret of the [Bot](#schema_bot)
         */
        signingSecret: string;
        /**
         * A mapping of integrations to their configuration
         */
        integrations: {
            [k: string]: {
                enabled: boolean;
                /**
                 * Name of the [Integration](#schema_integration)
                 */
                name: string;
                /**
                 * Version of the [Integration](#schema_integration)
                 */
                version: string;
                webhookUrl: string;
                webhookId: string;
                identifier?: string;
                configurationType: string | null;
                configuration: {
                    [k: string]: any;
                };
                status: "registration_pending" | "registered" | "registration_failed" | "unregistration_pending" | "unregistered" | "unregistration_failed";
                statusReason: string | null;
                /**
                 * ID of the [Integration](#schema_integration)
                 */
                id: string;
                /**
                 * Creation date of the [Integration](#schema_integration) in ISO 8601 format
                 */
                createdAt: string;
                /**
                 * Updating date of the [Integration](#schema_integration) in ISO 8601 format
                 */
                updatedAt: string;
                /**
                 * Title of the integration. This is the name that will be displayed in the UI
                 */
                title: string;
                /**
                 * Description of the integration. This is the description that will be displayed in the UI
                 */
                description: string;
                /**
                 * URL of the icon of the integration. This is the icon that will be displayed in the UI
                 */
                iconUrl: string;
                /**
                 * Idicates if the integration is public. Public integrations are available to all and cannot be updated without creating a new version.
                 */
                public: boolean;
                /**
                 * Status of the integration version verification
                 */
                verificationStatus: "unapproved" | "pending" | "approved" | "rejected";
            };
        };
        /**
         * User object configuration
         */
        user: {
            tags: {
                /**
                 * Definition of a tag that can be provided on the object
                 */
                [k: string]: {
                    /**
                     * Title of the tag
                     */
                    title?: string;
                    /**
                     * Description of the tag
                     */
                    description?: string;
                };
            };
        };
        /**
         * Conversation object configuration
         */
        conversation: {
            tags: {
                /**
                 * Definition of a tag that can be provided on the object
                 */
                [k: string]: {
                    /**
                     * Title of the tag
                     */
                    title?: string;
                    /**
                     * Description of the tag
                     */
                    description?: string;
                };
            };
        };
        /**
         * Message object configuration
         */
        message: {
            tags: {
                /**
                 * Definition of a tag that can be provided on the object
                 */
                [k: string]: {
                    /**
                     * Title of the tag
                     */
                    title?: string;
                    /**
                     * Description of the tag
                     */
                    description?: string;
                };
            };
        };
        /**
         * A mapping of states to their definition
         */
        states: {
            [k: string]: {
                /**
                 * Type of the [State](#schema_state) (`conversation`, `user`, `bot` or `task`)
                 */
                type: "conversation" | "user" | "bot" | "task";
                /**
                 * Schema of the [State](#schema_state) in the `JSON schema` format. This `JSON schema` is going to be used for validating the state data.
                 */
                schema: {
                    [k: string]: any;
                };
                /**
                 * Expiry of the [State](#schema_state) in milliseconds. The state will expire if it is idle for the configured value. By default, a state doesn't expire.
                 */
                expiry?: number;
            };
        };
        /**
         * Configuration of the bot
         */
        configuration: {
            /**
             * Configuration data
             */
            data: {
                [k: string]: any;
            };
            /**
             * Schema of the configuration in the `JSON schema` format. The configuration data is validated against this `JSON schema`.
             */
            schema: {
                [k: string]: any;
            };
        };
        /**
         * Events definition
         */
        events: {
            /**
             * Event Definition
             */
            [k: string]: {
                /**
                 * Title of the event
                 */
                title?: string;
                /**
                 * Description of the event
                 */
                description?: string;
                schema: {
                    [k: string]: any;
                };
            };
        };
        /**
         * Recurring events
         */
        recurringEvents: {
            [k: string]: {
                schedule: {
                    cron: string;
                };
                type: string;
                payload: {
                    [k: string]: any;
                };
                /**
                 * The number of times the recurring event failed to run. This counter resets once the recurring event runs successfully.
                 */
                failedAttempts: number;
                /**
                 * The reason why the recurring event failed to run in the last attempt.
                 */
                lastFailureReason: string | null;
            };
        };
        /**
         * Subscriptions of the bot
         */
        subscriptions: {
            /**
             * Events that the bot is currently subscribed on (ex: "slack:reactionAdded"). If null, the bot is subscribed to all events.
             */
            events: {
                [k: string]: {};
            } | null;
        };
        /**
         * Actions definition
         */
        actions: {
            /**
             * Action definition
             */
            [k: string]: {
                /**
                 * Title of the action
                 */
                title?: string;
                /**
                 * Description of the action
                 */
                description?: string;
                billable?: boolean;
                cacheable?: boolean;
                input: {
                    schema: {
                        [k: string]: any;
                    };
                };
                output: {
                    schema: {
                        [k: string]: any;
                    };
                };
            };
        };
        /**
         * Name of the [Bot](#schema_bot)
         */
        name: string;
        /**
         * Last deployment date of the [Bot](#schema_bot) in the ISO 8601 format
         */
        deployedAt?: string;
        /**
         * Indicates if the [Bot](#schema_bot) is a development bot; Development bots run locally and can install dev integrations
         */
        dev: boolean;
        /**
         * Id of the user that created the bot
         */
        createdBy?: string;
        /**
         * Indicates if the [Bot](#schema_bot) should be in always alive mode
         */
        alwaysAlive: boolean;
        /**
         * Status of the bot
         */
        status: "active" | "deploying";
        /**
         * Media files associated with the [Bot](#schema_bot)
         */
        medias: {
            /**
             * URL of the media file
             */
            url: string;
            /**
             * Name of the media file
             */
            name: string;
        }[];
    };
}

interface TransferBotRequestHeaders {
}
interface TransferBotRequestQuery {
}
interface TransferBotRequestParams {
    id: string;
}
interface TransferBotRequestBody {
    /**
     * The ID of the workspace you want to transfer the bot to.
     */
    targetWorkspaceId: string;
}
type TransferBotInput = TransferBotRequestBody & TransferBotRequestHeaders & TransferBotRequestQuery & TransferBotRequestParams;
interface TransferBotResponse {
}

interface ListBotsRequestHeaders {
}
interface ListBotsRequestQuery {
    dev?: boolean;
    nextToken?: string;
    sortField?: "createdAt" | "updatedAt";
    sortDirection?: "asc" | "desc";
}
interface ListBotsRequestParams {
}
interface ListBotsRequestBody {
}
type ListBotsInput = ListBotsRequestBody & ListBotsRequestHeaders & ListBotsRequestQuery & ListBotsRequestParams;
interface ListBotsResponse {
    bots: {
        /**
         * Id of the [Bot](#schema_bot)
         */
        id: string;
        /**
         * Creation date of the [Bot](#schema_bot) in ISO 8601 format
         */
        createdAt: string;
        /**
         * Updating date of the [Bot](#schema_bot) in ISO 8601 format
         */
        updatedAt: string;
        name: string;
        deployedAt?: string;
    }[];
    meta: {
        /**
         * The token to use to retrieve the next page of results, passed as a query string parameter (value should be URL-encoded) to this API endpoint.
         */
        nextToken?: string;
    };
}

interface GetBotRequestHeaders {
}
interface GetBotRequestQuery {
}
interface GetBotRequestParams {
    id: string;
}
interface GetBotRequestBody {
}
type GetBotInput = GetBotRequestBody & GetBotRequestHeaders & GetBotRequestQuery & GetBotRequestParams;
interface GetBotResponse {
    bot: {
        /**
         * Id of the [Bot](#schema_bot)
         */
        id: string;
        /**
         * Creation date of the [Bot](#schema_bot) in ISO 8601 format
         */
        createdAt: string;
        /**
         * Updating date of the [Bot](#schema_bot) in ISO 8601 format
         */
        updatedAt: string;
        /**
         * Signing secret of the [Bot](#schema_bot)
         */
        signingSecret: string;
        /**
         * A mapping of integrations to their configuration
         */
        integrations: {
            [k: string]: {
                enabled: boolean;
                /**
                 * Name of the [Integration](#schema_integration)
                 */
                name: string;
                /**
                 * Version of the [Integration](#schema_integration)
                 */
                version: string;
                webhookUrl: string;
                webhookId: string;
                identifier?: string;
                configurationType: string | null;
                configuration: {
                    [k: string]: any;
                };
                status: "registration_pending" | "registered" | "registration_failed" | "unregistration_pending" | "unregistered" | "unregistration_failed";
                statusReason: string | null;
                /**
                 * ID of the [Integration](#schema_integration)
                 */
                id: string;
                /**
                 * Creation date of the [Integration](#schema_integration) in ISO 8601 format
                 */
                createdAt: string;
                /**
                 * Updating date of the [Integration](#schema_integration) in ISO 8601 format
                 */
                updatedAt: string;
                /**
                 * Title of the integration. This is the name that will be displayed in the UI
                 */
                title: string;
                /**
                 * Description of the integration. This is the description that will be displayed in the UI
                 */
                description: string;
                /**
                 * URL of the icon of the integration. This is the icon that will be displayed in the UI
                 */
                iconUrl: string;
                /**
                 * Idicates if the integration is public. Public integrations are available to all and cannot be updated without creating a new version.
                 */
                public: boolean;
                /**
                 * Status of the integration version verification
                 */
                verificationStatus: "unapproved" | "pending" | "approved" | "rejected";
            };
        };
        /**
         * User object configuration
         */
        user: {
            tags: {
                /**
                 * Definition of a tag that can be provided on the object
                 */
                [k: string]: {
                    /**
                     * Title of the tag
                     */
                    title?: string;
                    /**
                     * Description of the tag
                     */
                    description?: string;
                };
            };
        };
        /**
         * Conversation object configuration
         */
        conversation: {
            tags: {
                /**
                 * Definition of a tag that can be provided on the object
                 */
                [k: string]: {
                    /**
                     * Title of the tag
                     */
                    title?: string;
                    /**
                     * Description of the tag
                     */
                    description?: string;
                };
            };
        };
        /**
         * Message object configuration
         */
        message: {
            tags: {
                /**
                 * Definition of a tag that can be provided on the object
                 */
                [k: string]: {
                    /**
                     * Title of the tag
                     */
                    title?: string;
                    /**
                     * Description of the tag
                     */
                    description?: string;
                };
            };
        };
        /**
         * A mapping of states to their definition
         */
        states: {
            [k: string]: {
                /**
                 * Type of the [State](#schema_state) (`conversation`, `user`, `bot` or `task`)
                 */
                type: "conversation" | "user" | "bot" | "task";
                /**
                 * Schema of the [State](#schema_state) in the `JSON schema` format. This `JSON schema` is going to be used for validating the state data.
                 */
                schema: {
                    [k: string]: any;
                };
                /**
                 * Expiry of the [State](#schema_state) in milliseconds. The state will expire if it is idle for the configured value. By default, a state doesn't expire.
                 */
                expiry?: number;
            };
        };
        /**
         * Configuration of the bot
         */
        configuration: {
            /**
             * Configuration data
             */
            data: {
                [k: string]: any;
            };
            /**
             * Schema of the configuration in the `JSON schema` format. The configuration data is validated against this `JSON schema`.
             */
            schema: {
                [k: string]: any;
            };
        };
        /**
         * Events definition
         */
        events: {
            /**
             * Event Definition
             */
            [k: string]: {
                /**
                 * Title of the event
                 */
                title?: string;
                /**
                 * Description of the event
                 */
                description?: string;
                schema: {
                    [k: string]: any;
                };
            };
        };
        /**
         * Recurring events
         */
        recurringEvents: {
            [k: string]: {
                schedule: {
                    cron: string;
                };
                type: string;
                payload: {
                    [k: string]: any;
                };
                /**
                 * The number of times the recurring event failed to run. This counter resets once the recurring event runs successfully.
                 */
                failedAttempts: number;
                /**
                 * The reason why the recurring event failed to run in the last attempt.
                 */
                lastFailureReason: string | null;
            };
        };
        /**
         * Subscriptions of the bot
         */
        subscriptions: {
            /**
             * Events that the bot is currently subscribed on (ex: "slack:reactionAdded"). If null, the bot is subscribed to all events.
             */
            events: {
                [k: string]: {};
            } | null;
        };
        /**
         * Actions definition
         */
        actions: {
            /**
             * Action definition
             */
            [k: string]: {
                /**
                 * Title of the action
                 */
                title?: string;
                /**
                 * Description of the action
                 */
                description?: string;
                billable?: boolean;
                cacheable?: boolean;
                input: {
                    schema: {
                        [k: string]: any;
                    };
                };
                output: {
                    schema: {
                        [k: string]: any;
                    };
                };
            };
        };
        /**
         * Name of the [Bot](#schema_bot)
         */
        name: string;
        /**
         * Last deployment date of the [Bot](#schema_bot) in the ISO 8601 format
         */
        deployedAt?: string;
        /**
         * Indicates if the [Bot](#schema_bot) is a development bot; Development bots run locally and can install dev integrations
         */
        dev: boolean;
        /**
         * Id of the user that created the bot
         */
        createdBy?: string;
        /**
         * Indicates if the [Bot](#schema_bot) should be in always alive mode
         */
        alwaysAlive: boolean;
        /**
         * Status of the bot
         */
        status: "active" | "deploying";
        /**
         * Media files associated with the [Bot](#schema_bot)
         */
        medias: {
            /**
             * URL of the media file
             */
            url: string;
            /**
             * Name of the media file
             */
            name: string;
        }[];
    };
}

interface DeleteBotRequestHeaders {
}
interface DeleteBotRequestQuery {
}
interface DeleteBotRequestParams {
    id: string;
}
interface DeleteBotRequestBody {
}
type DeleteBotInput = DeleteBotRequestBody & DeleteBotRequestHeaders & DeleteBotRequestQuery & DeleteBotRequestParams;
interface DeleteBotResponse {
}

interface GetBotLogsRequestHeaders {
}
interface GetBotLogsRequestQuery {
    timeStart: string;
    timeEnd: string;
    nextToken?: string;
}
interface GetBotLogsRequestParams {
    id: string;
}
interface GetBotLogsRequestBody {
}
type GetBotLogsInput = GetBotLogsRequestBody & GetBotLogsRequestHeaders & GetBotLogsRequestQuery & GetBotLogsRequestParams;
interface GetBotLogsResponse {
    logs: {
        timestamp: string;
        level: string;
        message: string;
    }[];
    nextToken?: string;
}

interface GetBotWebchatRequestHeaders {
}
interface GetBotWebchatRequestQuery {
    type: "preconfigured" | "configurable" | "fullscreen" | "sharableUrl";
}
interface GetBotWebchatRequestParams {
    id: string;
}
interface GetBotWebchatRequestBody {
}
type GetBotWebchatInput = GetBotWebchatRequestBody & GetBotWebchatRequestHeaders & GetBotWebchatRequestQuery & GetBotWebchatRequestParams;
interface GetBotWebchatResponse {
    code: string;
}

interface GetBotAnalyticsRequestHeaders {
}
interface GetBotAnalyticsRequestQuery {
    startDate: string;
    endDate: string;
}
interface GetBotAnalyticsRequestParams {
    id: string;
}
interface GetBotAnalyticsRequestBody {
}
type GetBotAnalyticsInput = GetBotAnalyticsRequestBody & GetBotAnalyticsRequestHeaders & GetBotAnalyticsRequestQuery & GetBotAnalyticsRequestParams;
interface GetBotAnalyticsResponse {
    records: {
        /**
         * ISO 8601 date string of the beginning (inclusive) of the period
         */
        startDateTimeUtc: string;
        /**
         * ISO 8601 date string of the end (exclusive) of the period
         */
        endDateTimeUtc: string;
        returningUsers: number;
        newUsers: number;
        sessions: number;
        /**
         * Deprecated. Use `userMessages` instead.
         */
        messages: number;
        userMessages: number;
        botMessages: number;
        events: number;
        eventTypes: {
            [k: string]: number;
        };
        customEvents: {
            [k: string]: number;
        };
    }[];
}

interface GetBotIssueRequestHeaders {
}
interface GetBotIssueRequestQuery {
}
interface GetBotIssueRequestParams {
    id: string;
    issueId: string;
}
interface GetBotIssueRequestBody {
}
type GetBotIssueInput = GetBotIssueRequestBody & GetBotIssueRequestHeaders & GetBotIssueRequestQuery & GetBotIssueRequestParams;
interface GetBotIssueResponse {
    issue: {
        id: string;
        code: string;
        createdAt: string;
        lastSeenAt: string;
        title: string;
        description: string;
        groupedData: {
            [k: string]: {
                raw: string;
                pretty?: string;
            };
        };
        eventsCount: number;
        category: "user_code" | "limits" | "configuration" | "other";
        resolutionLink: string | null;
    };
}

interface ListBotIssuesRequestHeaders {
}
interface ListBotIssuesRequestQuery {
    nextToken?: string;
}
interface ListBotIssuesRequestParams {
    id: string;
}
interface ListBotIssuesRequestBody {
}
type ListBotIssuesInput = ListBotIssuesRequestBody & ListBotIssuesRequestHeaders & ListBotIssuesRequestQuery & ListBotIssuesRequestParams;
interface ListBotIssuesResponse {
    issues: {
        id: string;
        code: string;
        createdAt: string;
        lastSeenAt: string;
        title: string;
        description: string;
        groupedData: {
            [k: string]: {
                raw: string;
                pretty?: string;
            };
        };
        eventsCount: number;
        category: "user_code" | "limits" | "configuration" | "other";
        resolutionLink: string | null;
    }[];
    meta: {
        /**
         * The token to use to retrieve the next page of results, passed as a query string parameter (value should be URL-encoded) to this API endpoint.
         */
        nextToken?: string;
    };
}

interface DeleteBotIssueRequestHeaders {
}
interface DeleteBotIssueRequestQuery {
}
interface DeleteBotIssueRequestParams {
    id: string;
    issueId: string;
}
interface DeleteBotIssueRequestBody {
}
type DeleteBotIssueInput = DeleteBotIssueRequestBody & DeleteBotIssueRequestHeaders & DeleteBotIssueRequestQuery & DeleteBotIssueRequestParams;
interface DeleteBotIssueResponse {
}

interface ListBotIssueEventsRequestHeaders {
}
interface ListBotIssueEventsRequestQuery {
}
interface ListBotIssueEventsRequestParams {
    id: string;
    issueId: string;
}
interface ListBotIssueEventsRequestBody {
}
type ListBotIssueEventsInput = ListBotIssueEventsRequestBody & ListBotIssueEventsRequestHeaders & ListBotIssueEventsRequestQuery & ListBotIssueEventsRequestParams;
interface ListBotIssueEventsResponse {
    issueEvents: {
        id: string;
        createdAt: string;
        data: {
            [k: string]: {
                raw: string;
                pretty?: string;
            };
        };
    }[];
}

interface ListBotVersionsRequestHeaders {
}
interface ListBotVersionsRequestQuery {
}
interface ListBotVersionsRequestParams {
    id: string;
}
interface ListBotVersionsRequestBody {
}
type ListBotVersionsInput = ListBotVersionsRequestBody & ListBotVersionsRequestHeaders & ListBotVersionsRequestQuery & ListBotVersionsRequestParams;
interface ListBotVersionsResponse {
    versions: {
        id: string;
        name: string;
        description?: string;
    }[];
}

interface GetBotVersionRequestHeaders {
}
interface GetBotVersionRequestQuery {
}
interface GetBotVersionRequestParams {
    id: string;
    versionId: string;
}
interface GetBotVersionRequestBody {
}
type GetBotVersionInput = GetBotVersionRequestBody & GetBotVersionRequestHeaders & GetBotVersionRequestQuery & GetBotVersionRequestParams;
interface GetBotVersionResponse {
    url: string;
}

interface CreateBotVersionRequestHeaders {
}
interface CreateBotVersionRequestQuery {
}
interface CreateBotVersionRequestParams {
    id: string;
}
interface CreateBotVersionRequestBody {
    name: string;
    description?: string;
}
type CreateBotVersionInput = CreateBotVersionRequestBody & CreateBotVersionRequestHeaders & CreateBotVersionRequestQuery & CreateBotVersionRequestParams;
interface CreateBotVersionResponse {
    version: {
        id: string;
        name: string;
        description?: string;
    };
}

interface DeployBotVersionRequestHeaders {
}
interface DeployBotVersionRequestQuery {
}
interface DeployBotVersionRequestParams {
    id: string;
}
interface DeployBotVersionRequestBody {
    versionId: string;
}
type DeployBotVersionInput = DeployBotVersionRequestBody & DeployBotVersionRequestHeaders & DeployBotVersionRequestQuery & DeployBotVersionRequestParams;
interface DeployBotVersionResponse {
}

interface SetWorkspacePaymentMethodRequestHeaders {
}
interface SetWorkspacePaymentMethodRequestQuery {
}
interface SetWorkspacePaymentMethodRequestParams {
    id: string;
}
interface SetWorkspacePaymentMethodRequestBody {
    /**
     * ID of the Stripe PaymentMethod to attach to the workspace.
     */
    stripePaymentMethodId: string;
}
type SetWorkspacePaymentMethodInput = SetWorkspacePaymentMethodRequestBody & SetWorkspacePaymentMethodRequestHeaders & SetWorkspacePaymentMethodRequestQuery & SetWorkspacePaymentMethodRequestParams;
interface SetWorkspacePaymentMethodResponse {
    stripePaymentMethodId: string;
    paymentMethod: {
        type: string;
        lastDigits: string;
    } | null;
    status: "succeeded" | "processing" | "canceled" | "requires_confirmation" | "requires_action" | "requires_payment_method";
    /**
     * If the payment needs to be confirmed, this will contain a URL to redirect the user to so they can complete the verification process to confirm it.
     */
    nextAction?: {
        redirectToUrl: string;
    };
}

interface ListWorkspaceInvoicesRequestHeaders {
}
interface ListWorkspaceInvoicesRequestQuery {
}
interface ListWorkspaceInvoicesRequestParams {
    id: string;
}
interface ListWorkspaceInvoicesRequestBody {
}
type ListWorkspaceInvoicesInput = ListWorkspaceInvoicesRequestBody & ListWorkspaceInvoicesRequestHeaders & ListWorkspaceInvoicesRequestQuery & ListWorkspaceInvoicesRequestParams;
interface ListWorkspaceInvoicesResponse {
    invoices: {
        id: string;
        period: {
            month: number;
            year: number;
        };
        /**
         * Date on which the invoice was generated.
         */
        date: string;
        /**
         * Total amount to pay of the invoice.
         */
        amount: number;
        /**
         * Currency of the invoice amount.
         */
        currency: string;
        paymentStatus: ("deleted" | "draft" | "open" | "paid" | "uncollectible" | "void") | null;
        /**
         * Date on which the invoice is due.
         */
        dueDate?: string;
        /**
         * Number of times payment has been unsuccessfully attempted on the invoice.
         */
        paymentAttemptCount: number | null;
        /**
         * Date on which the next payment attempt will be made.
         */
        nextPaymentAttemptDate: string | null;
        /**
         * URL to download the PDF file of the invoice.
         */
        pdfUrl: string;
    }[];
}

interface GetUpcomingInvoiceRequestHeaders {
}
interface GetUpcomingInvoiceRequestQuery {
}
interface GetUpcomingInvoiceRequestParams {
    id: string;
}
interface GetUpcomingInvoiceRequestBody {
}
type GetUpcomingInvoiceInput = GetUpcomingInvoiceRequestBody & GetUpcomingInvoiceRequestHeaders & GetUpcomingInvoiceRequestQuery & GetUpcomingInvoiceRequestParams;
interface GetUpcomingInvoiceResponse {
    /**
     * Total amount to pay of the invoice.
     */
    total: number;
}

interface ChargeWorkspaceUnpaidInvoicesRequestHeaders {
}
interface ChargeWorkspaceUnpaidInvoicesRequestQuery {
}
interface ChargeWorkspaceUnpaidInvoicesRequestParams {
    id: string;
}
interface ChargeWorkspaceUnpaidInvoicesRequestBody {
    /**
     * @minItems 1
     */
    invoiceIds?: string[];
}
type ChargeWorkspaceUnpaidInvoicesInput = ChargeWorkspaceUnpaidInvoicesRequestBody & ChargeWorkspaceUnpaidInvoicesRequestHeaders & ChargeWorkspaceUnpaidInvoicesRequestQuery & ChargeWorkspaceUnpaidInvoicesRequestParams;
interface ChargeWorkspaceUnpaidInvoicesResponse {
    /**
     * Invoices that were successfully charged by this request.
     */
    chargedInvoices: {
        id: string;
        amount: number;
    }[];
    /**
     * Invoices that failed to be charged by this request.
     */
    failedInvoices: {
        id: string;
        amount: number;
        failedReason: string;
    }[];
}

interface CreateWorkspaceRequestHeaders {
}
interface CreateWorkspaceRequestQuery {
}
interface CreateWorkspaceRequestParams {
}
interface CreateWorkspaceRequestBody {
    name: string;
}
type CreateWorkspaceInput = CreateWorkspaceRequestBody & CreateWorkspaceRequestHeaders & CreateWorkspaceRequestQuery & CreateWorkspaceRequestParams;
interface CreateWorkspaceResponse {
    id: string;
    name: string;
    ownerId: string;
    createdAt: string;
    updatedAt: string;
    botCount: number;
    billingVersion: "v1" | "v2";
    plan: "community" | "team" | "enterprise";
    blocked: boolean;
    spendingLimit: number;
    about?: string;
    profilePicture?: string;
    contactEmail?: string;
    website?: string;
    socialAccounts?: string[];
    isPublic?: boolean;
    handle?: string;
}

interface GetPublicWorkspaceRequestHeaders {
}
interface GetPublicWorkspaceRequestQuery {
}
interface GetPublicWorkspaceRequestParams {
    id: string;
}
interface GetPublicWorkspaceRequestBody {
}
type GetPublicWorkspaceInput = GetPublicWorkspaceRequestBody & GetPublicWorkspaceRequestHeaders & GetPublicWorkspaceRequestQuery & GetPublicWorkspaceRequestParams;
interface GetPublicWorkspaceResponse$1 {
    id: string;
    name: string;
    createdAt: string;
    updatedAt: string;
    about?: string;
    profilePicture?: string;
    contactEmail?: string;
    website?: string;
    socialAccounts?: string[];
    handle?: string;
}

interface GetWorkspaceRequestHeaders {
}
interface GetWorkspaceRequestQuery {
}
interface GetWorkspaceRequestParams {
    id: string;
}
interface GetWorkspaceRequestBody {
}
type GetWorkspaceInput = GetWorkspaceRequestBody & GetWorkspaceRequestHeaders & GetWorkspaceRequestQuery & GetWorkspaceRequestParams;
interface GetWorkspaceResponse {
    id: string;
    name: string;
    ownerId: string;
    createdAt: string;
    updatedAt: string;
    botCount: number;
    billingVersion: "v1" | "v2";
    plan: "community" | "team" | "enterprise";
    blocked: boolean;
    spendingLimit: number;
    about?: string;
    profilePicture?: string;
    contactEmail?: string;
    website?: string;
    socialAccounts?: string[];
    isPublic?: boolean;
    handle?: string;
}

interface ListWorkspaceUsagesRequestHeaders {
}
interface ListWorkspaceUsagesRequestQuery {
    type: "invocation_timeout" | "invocation_calls" | "storage_count" | "bot_count" | "knowledgebase_vector_storage" | "workspace_ratelimit" | "table_row_count" | "workspace_member_count" | "integrations_owned_count" | "ai_spend" | "openai_spend" | "bing_search_spend" | "always_alive";
    period?: string;
}
interface ListWorkspaceUsagesRequestParams {
    id: string;
}
interface ListWorkspaceUsagesRequestBody {
}
type ListWorkspaceUsagesInput = ListWorkspaceUsagesRequestBody & ListWorkspaceUsagesRequestHeaders & ListWorkspaceUsagesRequestQuery & ListWorkspaceUsagesRequestParams;
interface ListWorkspaceUsagesResponse {
    usages: {
        /**
         * Id of the usage that it is linked to. It can either be a workspace id or a bot id
         */
        id: string;
        /**
         * Period of the quota that it is applied to
         */
        period: string;
        /**
         * Value of the current usage
         */
        value: number;
        /**
         * Quota of the current usage
         */
        quota: number;
        /**
         * Usage type that can be used
         */
        type: "invocation_timeout" | "invocation_calls" | "storage_count" | "bot_count" | "knowledgebase_vector_storage" | "workspace_ratelimit" | "table_row_count" | "workspace_member_count" | "integrations_owned_count" | "ai_spend" | "openai_spend" | "bing_search_spend" | "always_alive";
    }[];
}

interface BreakDownWorkspaceUsageByBotRequestHeaders {
}
interface BreakDownWorkspaceUsageByBotRequestQuery {
    type: "invocation_timeout" | "invocation_calls" | "storage_count" | "bot_count" | "knowledgebase_vector_storage" | "workspace_ratelimit" | "table_row_count" | "workspace_member_count" | "integrations_owned_count" | "ai_spend" | "openai_spend" | "bing_search_spend" | "always_alive";
    period?: string;
}
interface BreakDownWorkspaceUsageByBotRequestParams {
    id: string;
}
interface BreakDownWorkspaceUsageByBotRequestBody {
}
type BreakDownWorkspaceUsageByBotInput = BreakDownWorkspaceUsageByBotRequestBody & BreakDownWorkspaceUsageByBotRequestHeaders & BreakDownWorkspaceUsageByBotRequestQuery & BreakDownWorkspaceUsageByBotRequestParams;
interface BreakDownWorkspaceUsageByBotResponse {
    data: {
        botId: string;
        value: number;
    }[];
}

interface GetAllWorkspaceQuotaCompletionRequestHeaders {
}
interface GetAllWorkspaceQuotaCompletionRequestQuery {
}
interface GetAllWorkspaceQuotaCompletionRequestParams {
}
interface GetAllWorkspaceQuotaCompletionRequestBody {
}
type GetAllWorkspaceQuotaCompletionInput = GetAllWorkspaceQuotaCompletionRequestBody & GetAllWorkspaceQuotaCompletionRequestHeaders & GetAllWorkspaceQuotaCompletionRequestQuery & GetAllWorkspaceQuotaCompletionRequestParams;
interface GetAllWorkspaceQuotaCompletionResponse {
    [k: string]: {
        type: "invocation_timeout" | "invocation_calls" | "storage_count" | "bot_count" | "knowledgebase_vector_storage" | "workspace_ratelimit" | "table_row_count" | "workspace_member_count" | "integrations_owned_count" | "ai_spend" | "openai_spend" | "bing_search_spend" | "always_alive";
        completion: number;
    };
}

interface GetWorkspaceQuotaRequestHeaders {
}
interface GetWorkspaceQuotaRequestQuery {
    type: "invocation_timeout" | "invocation_calls" | "storage_count" | "bot_count" | "knowledgebase_vector_storage" | "workspace_ratelimit" | "table_row_count" | "workspace_member_count" | "integrations_owned_count" | "ai_spend" | "openai_spend" | "bing_search_spend" | "always_alive";
    period?: string;
}
interface GetWorkspaceQuotaRequestParams {
    id: string;
}
interface GetWorkspaceQuotaRequestBody {
}
type GetWorkspaceQuotaInput = GetWorkspaceQuotaRequestBody & GetWorkspaceQuotaRequestHeaders & GetWorkspaceQuotaRequestQuery & GetWorkspaceQuotaRequestParams;
interface GetWorkspaceQuotaResponse {
    quota: {
        /**
         * Period of the quota that it is applied to
         */
        period: string;
        /**
         * Value of the quota that is used
         */
        value: number;
        /**
         * Usage type that can be used
         */
        type: "invocation_timeout" | "invocation_calls" | "storage_count" | "bot_count" | "knowledgebase_vector_storage" | "workspace_ratelimit" | "table_row_count" | "workspace_member_count" | "integrations_owned_count" | "ai_spend" | "openai_spend" | "bing_search_spend" | "always_alive";
    };
}

interface ListWorkspaceQuotasRequestHeaders {
}
interface ListWorkspaceQuotasRequestQuery {
    period?: string;
}
interface ListWorkspaceQuotasRequestParams {
    id: string;
}
interface ListWorkspaceQuotasRequestBody {
}
type ListWorkspaceQuotasInput = ListWorkspaceQuotasRequestBody & ListWorkspaceQuotasRequestHeaders & ListWorkspaceQuotasRequestQuery & ListWorkspaceQuotasRequestParams;
interface ListWorkspaceQuotasResponse {
    quotas: {
        /**
         * Period of the quota that it is applied to
         */
        period: string;
        /**
         * Value of the quota that is used
         */
        value: number;
        /**
         * Usage type that can be used
         */
        type: "invocation_timeout" | "invocation_calls" | "storage_count" | "bot_count" | "knowledgebase_vector_storage" | "workspace_ratelimit" | "table_row_count" | "workspace_member_count" | "integrations_owned_count" | "ai_spend" | "openai_spend" | "bing_search_spend" | "always_alive";
    }[];
}

interface UpdateWorkspaceRequestHeaders {
}
interface UpdateWorkspaceRequestQuery {
}
interface UpdateWorkspaceRequestParams {
    id: string;
}
interface UpdateWorkspaceRequestBody {
    name?: string;
    spendingLimit?: number;
    about?: string;
    profilePicture?: string;
    contactEmail?: string;
    website?: string;
    /**
     * @maxItems 5
     */
    socialAccounts?: string[];
    isPublic?: boolean;
    handle?: string;
}
type UpdateWorkspaceInput = UpdateWorkspaceRequestBody & UpdateWorkspaceRequestHeaders & UpdateWorkspaceRequestQuery & UpdateWorkspaceRequestParams;
interface UpdateWorkspaceResponse$1 {
    id: string;
    name: string;
    ownerId: string;
    createdAt: string;
    updatedAt: string;
    botCount: number;
    billingVersion: "v1" | "v2";
    plan: "community" | "team" | "enterprise";
    blocked: boolean;
    spendingLimit: number;
    about?: string;
    profilePicture?: string;
    contactEmail?: string;
    website?: string;
    socialAccounts?: string[];
    isPublic?: boolean;
    handle?: string;
}

interface CheckHandleAvailabilityRequestHeaders {
}
interface CheckHandleAvailabilityRequestQuery {
}
interface CheckHandleAvailabilityRequestParams {
}
interface CheckHandleAvailabilityRequestBody {
    handle: string;
}
type CheckHandleAvailabilityInput = CheckHandleAvailabilityRequestBody & CheckHandleAvailabilityRequestHeaders & CheckHandleAvailabilityRequestQuery & CheckHandleAvailabilityRequestParams;
interface CheckHandleAvailabilityResponse {
    available: boolean;
    suggestions: string[];
    usedBy?: string;
}

interface ListWorkspacesRequestHeaders {
}
interface ListWorkspacesRequestQuery {
    nextToken?: string;
}
interface ListWorkspacesRequestParams {
}
interface ListWorkspacesRequestBody {
}
type ListWorkspacesInput = ListWorkspacesRequestBody & ListWorkspacesRequestHeaders & ListWorkspacesRequestQuery & ListWorkspacesRequestParams;
interface ListWorkspacesResponse {
    workspaces: UpdateWorkspaceResponse[];
    meta: {
        /**
         * The token to use to retrieve the next page of results, passed as a query string parameter (value should be URL-encoded) to this API endpoint.
         */
        nextToken?: string;
    };
}
interface UpdateWorkspaceResponse {
    id: string;
    name: string;
    ownerId: string;
    createdAt: string;
    updatedAt: string;
    botCount: number;
    billingVersion: "v1" | "v2";
    plan: "community" | "team" | "enterprise";
    blocked: boolean;
    spendingLimit: number;
    about?: string;
    profilePicture?: string;
    contactEmail?: string;
    website?: string;
    socialAccounts?: string[];
    isPublic?: boolean;
    handle?: string;
}

interface ListPublicWorkspacesRequestHeaders {
}
interface ListPublicWorkspacesRequestQuery {
    nextToken?: string;
    workspaceIds?: string[];
    search?: string;
}
interface ListPublicWorkspacesRequestParams {
}
interface ListPublicWorkspacesRequestBody {
}
type ListPublicWorkspacesInput = ListPublicWorkspacesRequestBody & ListPublicWorkspacesRequestHeaders & ListPublicWorkspacesRequestQuery & ListPublicWorkspacesRequestParams;
interface ListPublicWorkspacesResponse {
    workspaces: GetPublicWorkspaceResponse[];
    meta: {
        /**
         * The token to use to retrieve the next page of results, passed as a query string parameter (value should be URL-encoded) to this API endpoint.
         */
        nextToken?: string;
    };
}
interface GetPublicWorkspaceResponse {
    id: string;
    name: string;
    createdAt: string;
    updatedAt: string;
    about?: string;
    profilePicture?: string;
    contactEmail?: string;
    website?: string;
    socialAccounts?: string[];
    handle?: string;
}

interface DeleteWorkspaceRequestHeaders {
}
interface DeleteWorkspaceRequestQuery {
}
interface DeleteWorkspaceRequestParams {
    id: string;
}
interface DeleteWorkspaceRequestBody {
}
type DeleteWorkspaceInput = DeleteWorkspaceRequestBody & DeleteWorkspaceRequestHeaders & DeleteWorkspaceRequestQuery & DeleteWorkspaceRequestParams;
interface DeleteWorkspaceResponse {
}

interface GetAuditRecordsRequestHeaders {
}
interface GetAuditRecordsRequestQuery {
    nextToken?: string;
}
interface GetAuditRecordsRequestParams {
    id: string;
}
interface GetAuditRecordsRequestBody {
}
type GetAuditRecordsInput = GetAuditRecordsRequestBody & GetAuditRecordsRequestHeaders & GetAuditRecordsRequestQuery & GetAuditRecordsRequestParams;
interface GetAuditRecordsResponse {
    records: {
        id: string;
        recordedAt: string;
        userId: string | null;
        userEmail?: string | null;
        resourceId: string | null;
        resourceName?: string | null;
        value?: string | null;
        action: "UNKNOWN" | "ADD_WORKSPACE_MEMBER" | "REMOVE_WORKSPACE_MEMBER" | "UPDATE_WORKSPACE_MEMBER" | "CLOSE_WORKSPACE" | "CREATE_BOT" | "CREATE_WORKSPACE" | "DELETE_BOT" | "DEPLOY_BOT" | "TRANSFER_BOT" | "DOWNLOAD_BOT_ARCHIVE" | "UPDATE_BOT" | "UPDATE_BOT_CHANNEL" | "UPDATE_BOT_CONFIG" | "UPDATE_PAYMENT_METHOD" | "UPDATE_WORKSPACE" | "SET_SPENDING_LIMIT" | "SET_AI_SPENDING_LIMIT" | "UPDATE_WORKSPACE_BILLING_READONLY";
    }[];
    meta: {
        /**
         * The token to use to retrieve the next page of results, passed as a query string parameter (value should be URL-encoded) to this API endpoint.
         */
        nextToken?: string;
    };
}

interface ListWorkspaceMembersRequestHeaders {
}
interface ListWorkspaceMembersRequestQuery {
    nextToken?: string;
}
interface ListWorkspaceMembersRequestParams {
}
interface ListWorkspaceMembersRequestBody {
}
type ListWorkspaceMembersInput = ListWorkspaceMembersRequestBody & ListWorkspaceMembersRequestHeaders & ListWorkspaceMembersRequestQuery & ListWorkspaceMembersRequestParams;
interface ListWorkspaceMembersResponse {
    members: {
        id: string;
        userId?: string;
        email: string;
        createdAt: string;
        role: "viewer" | "billing" | "developer" | "manager" | "administrator" | "owner";
        profilePicture?: string;
        displayName?: string;
    }[];
    meta: {
        /**
         * The token to use to retrieve the next page of results, passed as a query string parameter (value should be URL-encoded) to this API endpoint.
         */
        nextToken?: string;
    };
}

interface GetWorkspaceMemberRequestHeaders {
}
interface GetWorkspaceMemberRequestQuery {
}
interface GetWorkspaceMemberRequestParams {
}
interface GetWorkspaceMemberRequestBody {
}
type GetWorkspaceMemberInput = GetWorkspaceMemberRequestBody & GetWorkspaceMemberRequestHeaders & GetWorkspaceMemberRequestQuery & GetWorkspaceMemberRequestParams;
interface GetWorkspaceMemberResponse {
    id: string;
    userId?: string;
    email: string;
    createdAt: string;
    role: "viewer" | "billing" | "developer" | "manager" | "administrator" | "owner";
    profilePicture?: string;
    displayName?: string;
}

interface DeleteWorkspaceMemberRequestHeaders {
}
interface DeleteWorkspaceMemberRequestQuery {
}
interface DeleteWorkspaceMemberRequestParams {
    id: string;
}
interface DeleteWorkspaceMemberRequestBody {
}
type DeleteWorkspaceMemberInput = DeleteWorkspaceMemberRequestBody & DeleteWorkspaceMemberRequestHeaders & DeleteWorkspaceMemberRequestQuery & DeleteWorkspaceMemberRequestParams;
interface DeleteWorkspaceMemberResponse {
}

interface CreateWorkspaceMemberRequestHeaders {
}
interface CreateWorkspaceMemberRequestQuery {
}
interface CreateWorkspaceMemberRequestParams {
}
interface CreateWorkspaceMemberRequestBody {
    email: string;
    role: "viewer" | "billing" | "developer" | "manager" | "administrator" | "owner";
}
type CreateWorkspaceMemberInput = CreateWorkspaceMemberRequestBody & CreateWorkspaceMemberRequestHeaders & CreateWorkspaceMemberRequestQuery & CreateWorkspaceMemberRequestParams;
interface CreateWorkspaceMemberResponse {
    id: string;
    userId?: string;
    email: string;
    createdAt: string;
    role: "viewer" | "billing" | "developer" | "manager" | "administrator" | "owner";
    profilePicture?: string;
    displayName?: string;
}

interface UpdateWorkspaceMemberRequestHeaders {
}
interface UpdateWorkspaceMemberRequestQuery {
}
interface UpdateWorkspaceMemberRequestParams {
    id: string;
}
interface UpdateWorkspaceMemberRequestBody {
    role?: "viewer" | "billing" | "developer" | "manager" | "administrator" | "owner";
}
type UpdateWorkspaceMemberInput = UpdateWorkspaceMemberRequestBody & UpdateWorkspaceMemberRequestHeaders & UpdateWorkspaceMemberRequestQuery & UpdateWorkspaceMemberRequestParams;
interface UpdateWorkspaceMemberResponse {
    id: string;
    userId?: string;
    email: string;
    createdAt: string;
    role: "viewer" | "billing" | "developer" | "manager" | "administrator" | "owner";
    profilePicture?: string;
    displayName?: string;
}

interface ListIntegrationApiKeysRequestHeaders {
}
interface ListIntegrationApiKeysRequestQuery {
    integrationId: string;
}
interface ListIntegrationApiKeysRequestParams {
}
interface ListIntegrationApiKeysRequestBody {
}
type ListIntegrationApiKeysInput = ListIntegrationApiKeysRequestBody & ListIntegrationApiKeysRequestHeaders & ListIntegrationApiKeysRequestQuery & ListIntegrationApiKeysRequestParams;
interface ListIntegrationApiKeysResponse {
    iaks: {
        id: string;
        createdAt: string;
        note: string;
    }[];
}

interface CreateIntegrationApiKeyRequestHeaders {
}
interface CreateIntegrationApiKeyRequestQuery {
}
interface CreateIntegrationApiKeyRequestParams {
}
interface CreateIntegrationApiKeyRequestBody {
    integrationId: string;
    note?: string;
}
type CreateIntegrationApiKeyInput = CreateIntegrationApiKeyRequestBody & CreateIntegrationApiKeyRequestHeaders & CreateIntegrationApiKeyRequestQuery & CreateIntegrationApiKeyRequestParams;
interface CreateIntegrationApiKeyResponse {
    id: string;
    createdAt: string;
    note: string;
    /**
     * The IAK value. This will only be returned here when created and cannot be retrieved later.
     */
    value: string;
}

interface DeleteIntegrationApiKeyRequestHeaders {
}
interface DeleteIntegrationApiKeyRequestQuery {
}
interface DeleteIntegrationApiKeyRequestParams {
    id: string;
}
interface DeleteIntegrationApiKeyRequestBody {
}
type DeleteIntegrationApiKeyInput = DeleteIntegrationApiKeyRequestBody & DeleteIntegrationApiKeyRequestHeaders & DeleteIntegrationApiKeyRequestQuery & DeleteIntegrationApiKeyRequestParams;
interface DeleteIntegrationApiKeyResponse {
}

interface CreateIntegrationRequestHeaders {
}
interface CreateIntegrationRequestQuery {
}
interface CreateIntegrationRequestParams {
}
interface CreateIntegrationRequestBody {
    /**
     * Name of the [Integration](#schema_integration)
     */
    name: string;
    /**
     * Version of the [Integration](#schema_integration)
     */
    version: string;
    /**
     * Default configuration definition of the integration
     */
    configuration?: {
        /**
         * Title of the configuration
         */
        title?: string;
        /**
         * Description of the configuration
         */
        description?: string;
        /**
         * Schema of the configuration in the `JSON schema` format. The configuration data is validated against this `JSON schema`.
         */
        schema?: {
            [k: string]: any;
        };
        identifier?: {
            required?: boolean;
            linkTemplateScript?: string;
        };
    };
    /**
     * Additional configuration definitions of the integration
     */
    configurations?: {
        [k: string]: {
            /**
             * Title of the configuration
             */
            title?: string;
            /**
             * Description of the configuration
             */
            description?: string;
            /**
             * Schema of the configuration in the `JSON schema` format. The configuration data is validated against this `JSON schema`.
             */
            schema?: {
                [k: string]: any;
            };
            identifier?: {
                required?: boolean;
                linkTemplateScript?: string;
            };
        };
    };
    states?: {
        /**
         * State definition
         */
        [k: string]: {
            /**
             * Type of the [State](#schema_state) (`conversation`, `user` or `integration`)
             */
            type: "conversation" | "user" | "integration";
            /**
             * Schema of the [State](#schema_state) in the `JSON schema` format. This `JSON schema` is going to be used for validating the state data.
             */
            schema: {
                [k: string]: any;
            };
        };
    };
    events?: {
        /**
         * Event Definition
         */
        [k: string]: {
            /**
             * Title of the event
             */
            title?: string;
            /**
             * Description of the event
             */
            description?: string;
            schema: {
                [k: string]: any;
            };
        };
    };
    actions?: {
        /**
         * Action definition
         */
        [k: string]: {
            /**
             * Title of the action
             */
            title?: string;
            /**
             * Description of the action
             */
            description?: string;
            billable?: boolean;
            cacheable?: boolean;
            input: {
                schema: {
                    [k: string]: any;
                };
            };
            output: {
                schema: {
                    [k: string]: any;
                };
            };
        };
    };
    entities?: {
        /**
         * Entity definition
         */
        [k: string]: {
            /**
             * Title of the entity
             */
            title?: string;
            /**
             * Description of the entity
             */
            description?: string;
            schema: {
                [k: string]: any;
            };
        };
    };
    identifier?: {
        fallbackHandlerScript?: string;
        extractScript?: string;
    };
    channels?: {
        [k: string]: {
            /**
             * Title of the channel
             */
            title?: string;
            /**
             * Description of the channel
             */
            description?: string;
            messages: {
                /**
                 * Message definition
                 */
                [k: string]: {
                    schema: {
                        [k: string]: any;
                    };
                };
            };
            conversation?: {
                /**
                 * The conversation creation setting determines how to create a conversation through the API directly. The integration will have to implement the `createConversation` functionality to support this setting.
                 */
                creation?: {
                    /**
                     * Enable conversation creation
                     */
                    enabled: boolean;
                    /**
                     * The list of tags that are required to be specified when calling the API directly to create a conversation.
                     */
                    requiredTags: string[];
                };
                tags?: {
                    /**
                     * Definition of a tag that can be provided on the object
                     */
                    [k: string]: {
                        /**
                         * Title of the tag
                         */
                        title?: string;
                        /**
                         * Description of the tag
                         */
                        description?: string;
                    };
                };
            };
            message?: {
                tags?: {
                    /**
                     * Definition of a tag that can be provided on the object
                     */
                    [k: string]: {
                        /**
                         * Title of the tag
                         */
                        title?: string;
                        /**
                         * Description of the tag
                         */
                        description?: string;
                    };
                };
            };
        };
    };
    user?: {
        /**
         * The user creation setting determines how to create a user through the API directly. The integration will have to implement the `createUser` functionality to support this setting.
         */
        creation?: {
            /**
             * Enable user creation
             */
            enabled: boolean;
            /**
             * The list of tags that are required to be specified when calling the API directly to create a user.
             */
            requiredTags: string[];
        };
        tags?: {
            /**
             * Definition of a tag that can be provided on the object
             */
            [k: string]: {
                /**
                 * Title of the tag
                 */
                title?: string;
                /**
                 * Description of the tag
                 */
                description?: string;
            };
        };
    };
    interfaces?: {
        [k: string]: {
            id: string;
            entities: {
                [k: string]: {
                    name: string;
                };
            };
            actions: {
                [k: string]: {
                    name: string;
                };
            };
            events: {
                [k: string]: {
                    name: string;
                };
            };
        };
    };
    /**
     * Secrets are integration-wide values available in the code via environment variables formatted with a SECRET_ prefix followed by your secret name. A secret name must respect SCREAMING_SNAKE casing.
     */
    secrets?: {
        [k: string]: string;
    };
    /**
     * JavaScript code of the integration
     */
    code?: string;
    /**
     * URL of the integration
     */
    url?: string;
    /**
     * Indicates if the integration is a development integration; Dev integrations run locally
     */
    dev?: boolean;
    /**
     * Base64 encoded svg of the integration icon. This icon is global to the integration each versions will be updated when this changes.
     */
    icon?: string;
    /**
     * Base64 encoded markdown of the integration readme. The readme is specific to each integration versions.
     */
    readme?: string;
    /**
     * Title of the integration. This is the name that will be displayed in the UI
     */
    title?: string;
    /**
     * Description of the integration. This is the description that will be displayed in the UI
     */
    description?: string;
    /**
     * Idicates if the integration is public. Public integrations are available to all and cannot be updated without creating a new version.
     */
    public?: boolean;
}
type CreateIntegrationInput = CreateIntegrationRequestBody & CreateIntegrationRequestHeaders & CreateIntegrationRequestQuery & CreateIntegrationRequestParams;
interface CreateIntegrationResponse {
    integration: {
        /**
         * ID of the [Integration](#schema_integration)
         */
        id: string;
        /**
         * Creation date of the [Integration](#schema_integration) in ISO 8601 format
         */
        createdAt: string;
        /**
         * Updating date of the [Integration](#schema_integration) in ISO 8601 format
         */
        updatedAt: string;
        /**
         * Global identifier configuration of the [Integration](#schema_integration)
         */
        identifier: {
            /**
             * VRL Script of the [Integration](#schema_integration) to handle incoming requests for a request that doesn't have an identifier
             */
            fallbackHandlerScript?: string;
            /**
             * VRL Script of the [Integration](#schema_integration) to extract the identifier from an incoming webhook often use for OAuth
             */
            extractScript?: string;
        };
        /**
         * URL of the [Integration](#schema_integration)
         */
        url: string;
        /**
         * Name of the [Integration](#schema_integration)
         */
        name: string;
        /**
         * Version of the [Integration](#schema_integration)
         */
        version: string;
        interfaces: {
            [k: string]: {
                id: string;
                /**
                 * Name of the interface
                 */
                name: string;
                entities: {
                    [k: string]: {
                        name: string;
                    };
                };
                actions: {
                    [k: string]: {
                        name: string;
                    };
                };
                events: {
                    [k: string]: {
                        name: string;
                    };
                };
            };
        };
        /**
         * Configuration definition
         */
        configuration: {
            /**
             * Title of the configuration
             */
            title?: string;
            /**
             * Description of the configuration
             */
            description?: string;
            /**
             * Identifier configuration of the [Integration](#schema_integration)
             */
            identifier: {
                linkTemplateScript?: string;
                required: boolean;
            };
            /**
             * Schema of the configuration in the `JSON schema` format. The configuration data is validated against this `JSON schema`.
             */
            schema?: {
                [k: string]: any;
            };
        };
        configurations: {
            /**
             * Configuration definition
             */
            [k: string]: {
                /**
                 * Title of the configuration
                 */
                title?: string;
                /**
                 * Description of the configuration
                 */
                description?: string;
                /**
                 * Identifier configuration of the [Integration](#schema_integration)
                 */
                identifier: {
                    linkTemplateScript?: string;
                    required: boolean;
                };
                /**
                 * Schema of the configuration in the `JSON schema` format. The configuration data is validated against this `JSON schema`.
                 */
                schema?: {
                    [k: string]: any;
                };
            };
        };
        channels: {
            /**
             * Channel definition
             */
            [k: string]: {
                /**
                 * Title of the channel
                 */
                title?: string;
                /**
                 * Description of the channel
                 */
                description?: string;
                messages: {
                    /**
                     * Message definition
                     */
                    [k: string]: {
                        schema: {
                            [k: string]: any;
                        };
                    };
                };
                /**
                 * Conversation object configuration
                 */
                conversation: {
                    tags: {
                        /**
                         * Definition of a tag that can be provided on the object
                         */
                        [k: string]: {
                            /**
                             * Title of the tag
                             */
                            title?: string;
                            /**
                             * Description of the tag
                             */
                            description?: string;
                        };
                    };
                    /**
                     * The conversation creation setting determines how to create a conversation through the API directly. The integration will have to implement the `createConversation` functionality to support this setting.
                     */
                    creation: {
                        /**
                         * Enable conversation creation
                         */
                        enabled: boolean;
                        /**
                         * The list of tags that are required to be specified when calling the API directly to create a conversation.
                         */
                        requiredTags: string[];
                    };
                };
                /**
                 * Message object configuration
                 */
                message: {
                    tags: {
                        /**
                         * Definition of a tag that can be provided on the object
                         */
                        [k: string]: {
                            /**
                             * Title of the tag
                             */
                            title?: string;
                            /**
                             * Description of the tag
                             */
                            description?: string;
                        };
                    };
                };
            };
        };
        states: {
            /**
             * State definition
             */
            [k: string]: {
                /**
                 * Type of the [State](#schema_state) (`conversation`, `user` or `integration`)
                 */
                type: "conversation" | "user" | "integration";
                /**
                 * Schema of the [State](#schema_state) in the `JSON schema` format. This `JSON schema` is going to be used for validating the state data.
                 */
                schema: {
                    [k: string]: any;
                };
            };
        };
        events: {
            /**
             * Event Definition
             */
            [k: string]: {
                /**
                 * Title of the event
                 */
                title?: string;
                /**
                 * Description of the event
                 */
                description?: string;
                schema: {
                    [k: string]: any;
                };
            };
        };
        actions: {
            /**
             * Action definition
             */
            [k: string]: {
                /**
                 * Title of the action
                 */
                title?: string;
                /**
                 * Description of the action
                 */
                description?: string;
                billable?: boolean;
                cacheable?: boolean;
                input: {
                    schema: {
                        [k: string]: any;
                    };
                };
                output: {
                    schema: {
                        [k: string]: any;
                    };
                };
            };
        };
        /**
         * User object configuration
         */
        user: {
            tags: {
                /**
                 * Definition of a tag that can be provided on the object
                 */
                [k: string]: {
                    /**
                     * Title of the tag
                     */
                    title?: string;
                    /**
                     * Description of the tag
                     */
                    description?: string;
                };
            };
            /**
             * The user creation setting determines how to create a user through the API directly. The integration will have to implement the `createUser` functionality to support this setting.
             */
            creation: {
                /**
                 * Enable user creation
                 */
                enabled: boolean;
                /**
                 * The list of tags that are required to be specified when calling the API directly to create a user.
                 */
                requiredTags: string[];
            };
        };
        entities: {
            /**
             * Entity definition
             */
            [k: string]: {
                /**
                 * Title of the entity
                 */
                title?: string;
                /**
                 * Description of the entity
                 */
                description?: string;
                schema: {
                    [k: string]: any;
                };
            };
        };
        /**
         * Indicates if the integration is a development integration; Dev integrations run locally
         */
        dev: boolean;
        /**
         * Title of the integration. This is the name that will be displayed in the UI
         */
        title: string;
        /**
         * Description of the integration. This is the description that will be displayed in the UI
         */
        description: string;
        /**
         * URL of the icon of the integration. This is the icon that will be displayed in the UI
         */
        iconUrl: string;
        /**
         * URL of the readme of the integration. This is the readme that will be displayed in the UI
         */
        readmeUrl: string;
        /**
         * Idicates if the integration is public. Public integrations are available to all and cannot be updated without creating a new version.
         */
        public: boolean;
        /**
         * Status of the integration version verification
         */
        verificationStatus: "unapproved" | "pending" | "approved" | "rejected";
        /**
         * Secrets are integration-wide values available in the code via environment variables formatted with a SECRET_ prefix followed by your secret name. A secret name must respect SCREAMING_SNAKE casing.
         */
        secrets: string[];
    };
}

interface UpdateIntegrationRequestHeaders {
}
interface UpdateIntegrationRequestQuery {
}
interface UpdateIntegrationRequestParams {
    id: string;
}
interface UpdateIntegrationRequestBody {
    /**
     * Default configuration definition of the integration
     */
    configuration?: {
        /**
         * Title of the configuration
         */
        title?: string;
        /**
         * Description of the configuration
         */
        description?: string;
        /**
         * Schema of the configuration in the `JSON schema` format. The configuration data is validated against this `JSON schema`.
         */
        schema?: {
            [k: string]: any;
        };
        identifier?: {
            linkTemplateScript?: string | null;
            required?: boolean;
        };
    };
    /**
     * Additional configuration definitions of the integration
     */
    configurations?: {
        [k: string]: {
            /**
             * Title of the configuration
             */
            title?: string;
            /**
             * Description of the configuration
             */
            description?: string;
            /**
             * Schema of the configuration in the `JSON schema` format. The configuration data is validated against this `JSON schema`.
             */
            schema?: {
                [k: string]: any;
            };
            identifier?: {
                linkTemplateScript?: string | null;
                required?: boolean;
            };
        } | null;
    };
    channels?: {
        [k: string]: {
            /**
             * Title of the channel
             */
            title?: string;
            /**
             * Description of the channel
             */
            description?: string;
            messages?: {
                /**
                 * Message definition
                 */
                [k: string]: {
                    schema: {
                        [k: string]: any;
                    };
                } | null;
            };
            conversation?: {
                /**
                 * The conversation creation setting determines how to create a conversation through the API directly. The integration will have to implement the `createConversation` functionality to support this setting.
                 */
                creation?: {
                    /**
                     * Enable conversation creation
                     */
                    enabled: boolean;
                    /**
                     * The list of tags that are required to be specified when calling the API directly to create a conversation.
                     */
                    requiredTags: string[];
                };
                tags?: {
                    /**
                     * Definition of a tag that can be provided on the object
                     */
                    [k: string]: {
                        /**
                         * Title of the tag
                         */
                        title?: string;
                        /**
                         * Description of the tag
                         */
                        description?: string;
                    } | null;
                };
            };
            message?: {
                tags?: {
                    /**
                     * Definition of a tag that can be provided on the object
                     */
                    [k: string]: {
                        /**
                         * Title of the tag
                         */
                        title?: string;
                        /**
                         * Description of the tag
                         */
                        description?: string;
                    } | null;
                };
            };
        } | null;
    };
    identifier?: {
        extractScript?: string | null;
        fallbackHandlerScript?: string | null;
    };
    actions?: {
        /**
         * Action definition
         */
        [k: string]: {
            /**
             * Title of the action
             */
            title?: string;
            /**
             * Description of the action
             */
            description?: string;
            billable?: boolean;
            cacheable?: boolean;
            input: {
                schema: {
                    [k: string]: any;
                };
            };
            output: {
                schema: {
                    [k: string]: any;
                };
            };
        } | null;
    };
    events?: {
        /**
         * Event Definition
         */
        [k: string]: {
            /**
             * Title of the event
             */
            title?: string;
            /**
             * Description of the event
             */
            description?: string;
            schema: {
                [k: string]: any;
            };
        } | null;
    };
    states?: {
        /**
         * State definition
         */
        [k: string]: {
            /**
             * Type of the [State](#schema_state) (`conversation`, `user` or `integration`)
             */
            type: "conversation" | "user" | "integration";
            /**
             * Schema of the [State](#schema_state) in the `JSON schema` format. This `JSON schema` is going to be used for validating the state data.
             */
            schema: {
                [k: string]: any;
            };
        } | null;
    };
    user?: {
        /**
         * The user creation setting determines how to create a user through the API directly. The integration will have to implement the `createUser` functionality to support this setting.
         */
        creation?: {
            /**
             * Enable user creation
             */
            enabled: boolean;
            /**
             * The list of tags that are required to be specified when calling the API directly to create a user.
             */
            requiredTags: string[];
        };
        tags?: {
            /**
             * Definition of a tag that can be provided on the object
             */
            [k: string]: {
                /**
                 * Title of the tag
                 */
                title?: string;
                /**
                 * Description of the tag
                 */
                description?: string;
            } | null;
        };
    };
    entities?: {
        /**
         * Entity definition
         */
        [k: string]: {
            /**
             * Title of the entity
             */
            title?: string;
            /**
             * Description of the entity
             */
            description?: string;
            schema: {
                [k: string]: any;
            };
        } | null;
    };
    interfaces?: {
        [k: string]: {
            id: string;
            entities: {
                [k: string]: {
                    name: string;
                };
            };
            actions: {
                [k: string]: {
                    name: string;
                };
            };
            events: {
                [k: string]: {
                    name: string;
                };
            };
        } | null;
    };
    /**
     * Secrets are integration-wide values available in the code via environment variables formatted with a SECRET_ prefix followed by your secret name. A secret name must respect SCREAMING_SNAKE casing.
     */
    secrets?: {
        [k: string]: string | null;
    };
    /**
     * JavaScript code of the integration
     */
    code?: string;
    /**
     * Base64 encoded svg of the integration icon. This icon is global to the integration each versions will be updated when this changes.
     */
    icon?: string;
    /**
     * Base64 encoded markdown of the integration readme. The readme is specific to each integration versions.
     */
    readme?: string;
    /**
     * Title of the integration. This is the name that will be displayed in the UI
     */
    title?: string;
    /**
     * Description of the integration. This is the description that will be displayed in the UI
     */
    description?: string;
    /**
     * URL of the integration
     */
    url?: string | null;
    /**
     * Idicates if the integration is public. Public integrations are available to all and cannot be updated without creating a new version.
     */
    public?: boolean;
}
type UpdateIntegrationInput = UpdateIntegrationRequestBody & UpdateIntegrationRequestHeaders & UpdateIntegrationRequestQuery & UpdateIntegrationRequestParams;
interface UpdateIntegrationResponse {
    integration: {
        /**
         * ID of the [Integration](#schema_integration)
         */
        id: string;
        /**
         * Creation date of the [Integration](#schema_integration) in ISO 8601 format
         */
        createdAt: string;
        /**
         * Updating date of the [Integration](#schema_integration) in ISO 8601 format
         */
        updatedAt: string;
        /**
         * Global identifier configuration of the [Integration](#schema_integration)
         */
        identifier: {
            /**
             * VRL Script of the [Integration](#schema_integration) to handle incoming requests for a request that doesn't have an identifier
             */
            fallbackHandlerScript?: string;
            /**
             * VRL Script of the [Integration](#schema_integration) to extract the identifier from an incoming webhook often use for OAuth
             */
            extractScript?: string;
        };
        /**
         * URL of the [Integration](#schema_integration)
         */
        url: string;
        /**
         * Name of the [Integration](#schema_integration)
         */
        name: string;
        /**
         * Version of the [Integration](#schema_integration)
         */
        version: string;
        interfaces: {
            [k: string]: {
                id: string;
                /**
                 * Name of the interface
                 */
                name: string;
                entities: {
                    [k: string]: {
                        name: string;
                    };
                };
                actions: {
                    [k: string]: {
                        name: string;
                    };
                };
                events: {
                    [k: string]: {
                        name: string;
                    };
                };
            };
        };
        /**
         * Configuration definition
         */
        configuration: {
            /**
             * Title of the configuration
             */
            title?: string;
            /**
             * Description of the configuration
             */
            description?: string;
            /**
             * Identifier configuration of the [Integration](#schema_integration)
             */
            identifier: {
                linkTemplateScript?: string;
                required: boolean;
            };
            /**
             * Schema of the configuration in the `JSON schema` format. The configuration data is validated against this `JSON schema`.
             */
            schema?: {
                [k: string]: any;
            };
        };
        configurations: {
            /**
             * Configuration definition
             */
            [k: string]: {
                /**
                 * Title of the configuration
                 */
                title?: string;
                /**
                 * Description of the configuration
                 */
                description?: string;
                /**
                 * Identifier configuration of the [Integration](#schema_integration)
                 */
                identifier: {
                    linkTemplateScript?: string;
                    required: boolean;
                };
                /**
                 * Schema of the configuration in the `JSON schema` format. The configuration data is validated against this `JSON schema`.
                 */
                schema?: {
                    [k: string]: any;
                };
            };
        };
        channels: {
            /**
             * Channel definition
             */
            [k: string]: {
                /**
                 * Title of the channel
                 */
                title?: string;
                /**
                 * Description of the channel
                 */
                description?: string;
                messages: {
                    /**
                     * Message definition
                     */
                    [k: string]: {
                        schema: {
                            [k: string]: any;
                        };
                    };
                };
                /**
                 * Conversation object configuration
                 */
                conversation: {
                    tags: {
                        /**
                         * Definition of a tag that can be provided on the object
                         */
                        [k: string]: {
                            /**
                             * Title of the tag
                             */
                            title?: string;
                            /**
                             * Description of the tag
                             */
                            description?: string;
                        };
                    };
                    /**
                     * The conversation creation setting determines how to create a conversation through the API directly. The integration will have to implement the `createConversation` functionality to support this setting.
                     */
                    creation: {
                        /**
                         * Enable conversation creation
                         */
                        enabled: boolean;
                        /**
                         * The list of tags that are required to be specified when calling the API directly to create a conversation.
                         */
                        requiredTags: string[];
                    };
                };
                /**
                 * Message object configuration
                 */
                message: {
                    tags: {
                        /**
                         * Definition of a tag that can be provided on the object
                         */
                        [k: string]: {
                            /**
                             * Title of the tag
                             */
                            title?: string;
                            /**
                             * Description of the tag
                             */
                            description?: string;
                        };
                    };
                };
            };
        };
        states: {
            /**
             * State definition
             */
            [k: string]: {
                /**
                 * Type of the [State](#schema_state) (`conversation`, `user` or `integration`)
                 */
                type: "conversation" | "user" | "integration";
                /**
                 * Schema of the [State](#schema_state) in the `JSON schema` format. This `JSON schema` is going to be used for validating the state data.
                 */
                schema: {
                    [k: string]: any;
                };
            };
        };
        events: {
            /**
             * Event Definition
             */
            [k: string]: {
                /**
                 * Title of the event
                 */
                title?: string;
                /**
                 * Description of the event
                 */
                description?: string;
                schema: {
                    [k: string]: any;
                };
            };
        };
        actions: {
            /**
             * Action definition
             */
            [k: string]: {
                /**
                 * Title of the action
                 */
                title?: string;
                /**
                 * Description of the action
                 */
                description?: string;
                billable?: boolean;
                cacheable?: boolean;
                input: {
                    schema: {
                        [k: string]: any;
                    };
                };
                output: {
                    schema: {
                        [k: string]: any;
                    };
                };
            };
        };
        /**
         * User object configuration
         */
        user: {
            tags: {
                /**
                 * Definition of a tag that can be provided on the object
                 */
                [k: string]: {
                    /**
                     * Title of the tag
                     */
                    title?: string;
                    /**
                     * Description of the tag
                     */
                    description?: string;
                };
            };
            /**
             * The user creation setting determines how to create a user through the API directly. The integration will have to implement the `createUser` functionality to support this setting.
             */
            creation: {
                /**
                 * Enable user creation
                 */
                enabled: boolean;
                /**
                 * The list of tags that are required to be specified when calling the API directly to create a user.
                 */
                requiredTags: string[];
            };
        };
        entities: {
            /**
             * Entity definition
             */
            [k: string]: {
                /**
                 * Title of the entity
                 */
                title?: string;
                /**
                 * Description of the entity
                 */
                description?: string;
                schema: {
                    [k: string]: any;
                };
            };
        };
        /**
         * Indicates if the integration is a development integration; Dev integrations run locally
         */
        dev: boolean;
        /**
         * Title of the integration. This is the name that will be displayed in the UI
         */
        title: string;
        /**
         * Description of the integration. This is the description that will be displayed in the UI
         */
        description: string;
        /**
         * URL of the icon of the integration. This is the icon that will be displayed in the UI
         */
        iconUrl: string;
        /**
         * URL of the readme of the integration. This is the readme that will be displayed in the UI
         */
        readmeUrl: string;
        /**
         * Idicates if the integration is public. Public integrations are available to all and cannot be updated without creating a new version.
         */
        public: boolean;
        /**
         * Status of the integration version verification
         */
        verificationStatus: "unapproved" | "pending" | "approved" | "rejected";
        /**
         * Secrets are integration-wide values available in the code via environment variables formatted with a SECRET_ prefix followed by your secret name. A secret name must respect SCREAMING_SNAKE casing.
         */
        secrets: string[];
    };
}

interface ListIntegrationsRequestHeaders {
}
interface ListIntegrationsRequestQuery {
    nextToken?: string;
    name?: string;
    version?: string;
    dev?: boolean;
}
interface ListIntegrationsRequestParams {
}
interface ListIntegrationsRequestBody {
}
type ListIntegrationsInput = ListIntegrationsRequestBody & ListIntegrationsRequestHeaders & ListIntegrationsRequestQuery & ListIntegrationsRequestParams;
interface ListIntegrationsResponse {
    integrations: {
        /**
         * ID of the [Integration](#schema_integration)
         */
        id: string;
        /**
         * Name of the [Integration](#schema_integration)
         */
        name: string;
        /**
         * Version of the [Integration](#schema_integration)
         */
        version: string;
        /**
         * Creation date of the [Integration](#schema_integration) in ISO 8601 format
         */
        createdAt: string;
        /**
         * Updating date of the [Integration](#schema_integration) in ISO 8601 format
         */
        updatedAt: string;
        /**
         * Title of the integration. This is the name that will be displayed in the UI
         */
        title: string;
        /**
         * Description of the integration. This is the description that will be displayed in the UI
         */
        description: string;
        /**
         * URL of the icon of the integration. This is the icon that will be displayed in the UI
         */
        iconUrl: string;
        /**
         * Idicates if the integration is public. Public integrations are available to all and cannot be updated without creating a new version.
         */
        public: boolean;
        /**
         * Status of the integration version verification
         */
        verificationStatus: "unapproved" | "pending" | "approved" | "rejected";
    }[];
    meta: {
        /**
         * The token to use to retrieve the next page of results, passed as a query string parameter (value should be URL-encoded) to this API endpoint.
         */
        nextToken?: string;
    };
}

interface GetIntegrationRequestHeaders {
}
interface GetIntegrationRequestQuery {
}
interface GetIntegrationRequestParams {
    id: string;
}
interface GetIntegrationRequestBody {
}
type GetIntegrationInput = GetIntegrationRequestBody & GetIntegrationRequestHeaders & GetIntegrationRequestQuery & GetIntegrationRequestParams;
interface GetIntegrationResponse {
    integration: {
        /**
         * ID of the [Integration](#schema_integration)
         */
        id: string;
        /**
         * Creation date of the [Integration](#schema_integration) in ISO 8601 format
         */
        createdAt: string;
        /**
         * Updating date of the [Integration](#schema_integration) in ISO 8601 format
         */
        updatedAt: string;
        /**
         * Global identifier configuration of the [Integration](#schema_integration)
         */
        identifier: {
            /**
             * VRL Script of the [Integration](#schema_integration) to handle incoming requests for a request that doesn't have an identifier
             */
            fallbackHandlerScript?: string;
            /**
             * VRL Script of the [Integration](#schema_integration) to extract the identifier from an incoming webhook often use for OAuth
             */
            extractScript?: string;
        };
        /**
         * URL of the [Integration](#schema_integration)
         */
        url: string;
        /**
         * Name of the [Integration](#schema_integration)
         */
        name: string;
        /**
         * Version of the [Integration](#schema_integration)
         */
        version: string;
        interfaces: {
            [k: string]: {
                id: string;
                /**
                 * Name of the interface
                 */
                name: string;
                entities: {
                    [k: string]: {
                        name: string;
                    };
                };
                actions: {
                    [k: string]: {
                        name: string;
                    };
                };
                events: {
                    [k: string]: {
                        name: string;
                    };
                };
            };
        };
        /**
         * Configuration definition
         */
        configuration: {
            /**
             * Title of the configuration
             */
            title?: string;
            /**
             * Description of the configuration
             */
            description?: string;
            /**
             * Identifier configuration of the [Integration](#schema_integration)
             */
            identifier: {
                linkTemplateScript?: string;
                required: boolean;
            };
            /**
             * Schema of the configuration in the `JSON schema` format. The configuration data is validated against this `JSON schema`.
             */
            schema?: {
                [k: string]: any;
            };
        };
        configurations: {
            /**
             * Configuration definition
             */
            [k: string]: {
                /**
                 * Title of the configuration
                 */
                title?: string;
                /**
                 * Description of the configuration
                 */
                description?: string;
                /**
                 * Identifier configuration of the [Integration](#schema_integration)
                 */
                identifier: {
                    linkTemplateScript?: string;
                    required: boolean;
                };
                /**
                 * Schema of the configuration in the `JSON schema` format. The configuration data is validated against this `JSON schema`.
                 */
                schema?: {
                    [k: string]: any;
                };
            };
        };
        channels: {
            /**
             * Channel definition
             */
            [k: string]: {
                /**
                 * Title of the channel
                 */
                title?: string;
                /**
                 * Description of the channel
                 */
                description?: string;
                messages: {
                    /**
                     * Message definition
                     */
                    [k: string]: {
                        schema: {
                            [k: string]: any;
                        };
                    };
                };
                /**
                 * Conversation object configuration
                 */
                conversation: {
                    tags: {
                        /**
                         * Definition of a tag that can be provided on the object
                         */
                        [k: string]: {
                            /**
                             * Title of the tag
                             */
                            title?: string;
                            /**
                             * Description of the tag
                             */
                            description?: string;
                        };
                    };
                    /**
                     * The conversation creation setting determines how to create a conversation through the API directly. The integration will have to implement the `createConversation` functionality to support this setting.
                     */
                    creation: {
                        /**
                         * Enable conversation creation
                         */
                        enabled: boolean;
                        /**
                         * The list of tags that are required to be specified when calling the API directly to create a conversation.
                         */
                        requiredTags: string[];
                    };
                };
                /**
                 * Message object configuration
                 */
                message: {
                    tags: {
                        /**
                         * Definition of a tag that can be provided on the object
                         */
                        [k: string]: {
                            /**
                             * Title of the tag
                             */
                            title?: string;
                            /**
                             * Description of the tag
                             */
                            description?: string;
                        };
                    };
                };
            };
        };
        states: {
            /**
             * State definition
             */
            [k: string]: {
                /**
                 * Type of the [State](#schema_state) (`conversation`, `user` or `integration`)
                 */
                type: "conversation" | "user" | "integration";
                /**
                 * Schema of the [State](#schema_state) in the `JSON schema` format. This `JSON schema` is going to be used for validating the state data.
                 */
                schema: {
                    [k: string]: any;
                };
            };
        };
        events: {
            /**
             * Event Definition
             */
            [k: string]: {
                /**
                 * Title of the event
                 */
                title?: string;
                /**
                 * Description of the event
                 */
                description?: string;
                schema: {
                    [k: string]: any;
                };
            };
        };
        actions: {
            /**
             * Action definition
             */
            [k: string]: {
                /**
                 * Title of the action
                 */
                title?: string;
                /**
                 * Description of the action
                 */
                description?: string;
                billable?: boolean;
                cacheable?: boolean;
                input: {
                    schema: {
                        [k: string]: any;
                    };
                };
                output: {
                    schema: {
                        [k: string]: any;
                    };
                };
            };
        };
        /**
         * User object configuration
         */
        user: {
            tags: {
                /**
                 * Definition of a tag that can be provided on the object
                 */
                [k: string]: {
                    /**
                     * Title of the tag
                     */
                    title?: string;
                    /**
                     * Description of the tag
                     */
                    description?: string;
                };
            };
            /**
             * The user creation setting determines how to create a user through the API directly. The integration will have to implement the `createUser` functionality to support this setting.
             */
            creation: {
                /**
                 * Enable user creation
                 */
                enabled: boolean;
                /**
                 * The list of tags that are required to be specified when calling the API directly to create a user.
                 */
                requiredTags: string[];
            };
        };
        entities: {
            /**
             * Entity definition
             */
            [k: string]: {
                /**
                 * Title of the entity
                 */
                title?: string;
                /**
                 * Description of the entity
                 */
                description?: string;
                schema: {
                    [k: string]: any;
                };
            };
        };
        /**
         * Indicates if the integration is a development integration; Dev integrations run locally
         */
        dev: boolean;
        /**
         * Title of the integration. This is the name that will be displayed in the UI
         */
        title: string;
        /**
         * Description of the integration. This is the description that will be displayed in the UI
         */
        description: string;
        /**
         * URL of the icon of the integration. This is the icon that will be displayed in the UI
         */
        iconUrl: string;
        /**
         * URL of the readme of the integration. This is the readme that will be displayed in the UI
         */
        readmeUrl: string;
        /**
         * Idicates if the integration is public. Public integrations are available to all and cannot be updated without creating a new version.
         */
        public: boolean;
        /**
         * Status of the integration version verification
         */
        verificationStatus: "unapproved" | "pending" | "approved" | "rejected";
        /**
         * Secrets are integration-wide values available in the code via environment variables formatted with a SECRET_ prefix followed by your secret name. A secret name must respect SCREAMING_SNAKE casing.
         */
        secrets: string[];
    };
}

interface GetIntegrationLogsRequestHeaders {
}
interface GetIntegrationLogsRequestQuery {
    timeStart: string;
    timeEnd: string;
    nextToken?: string;
}
interface GetIntegrationLogsRequestParams {
    id: string;
}
interface GetIntegrationLogsRequestBody {
}
type GetIntegrationLogsInput = GetIntegrationLogsRequestBody & GetIntegrationLogsRequestHeaders & GetIntegrationLogsRequestQuery & GetIntegrationLogsRequestParams;
interface GetIntegrationLogsResponse {
    logs: {
        timestamp: string;
        level: string;
        message: string;
    }[];
    nextToken?: string;
}

interface GetIntegrationByNameRequestHeaders {
}
interface GetIntegrationByNameRequestQuery {
}
interface GetIntegrationByNameRequestParams {
    name: string;
    version: string;
}
interface GetIntegrationByNameRequestBody {
}
type GetIntegrationByNameInput = GetIntegrationByNameRequestBody & GetIntegrationByNameRequestHeaders & GetIntegrationByNameRequestQuery & GetIntegrationByNameRequestParams;
interface GetIntegrationByNameResponse {
    integration: {
        /**
         * ID of the [Integration](#schema_integration)
         */
        id: string;
        /**
         * Creation date of the [Integration](#schema_integration) in ISO 8601 format
         */
        createdAt: string;
        /**
         * Updating date of the [Integration](#schema_integration) in ISO 8601 format
         */
        updatedAt: string;
        /**
         * Global identifier configuration of the [Integration](#schema_integration)
         */
        identifier: {
            /**
             * VRL Script of the [Integration](#schema_integration) to handle incoming requests for a request that doesn't have an identifier
             */
            fallbackHandlerScript?: string;
            /**
             * VRL Script of the [Integration](#schema_integration) to extract the identifier from an incoming webhook often use for OAuth
             */
            extractScript?: string;
        };
        /**
         * URL of the [Integration](#schema_integration)
         */
        url: string;
        /**
         * Name of the [Integration](#schema_integration)
         */
        name: string;
        /**
         * Version of the [Integration](#schema_integration)
         */
        version: string;
        interfaces: {
            [k: string]: {
                id: string;
                /**
                 * Name of the interface
                 */
                name: string;
                entities: {
                    [k: string]: {
                        name: string;
                    };
                };
                actions: {
                    [k: string]: {
                        name: string;
                    };
                };
                events: {
                    [k: string]: {
                        name: string;
                    };
                };
            };
        };
        /**
         * Configuration definition
         */
        configuration: {
            /**
             * Title of the configuration
             */
            title?: string;
            /**
             * Description of the configuration
             */
            description?: string;
            /**
             * Identifier configuration of the [Integration](#schema_integration)
             */
            identifier: {
                linkTemplateScript?: string;
                required: boolean;
            };
            /**
             * Schema of the configuration in the `JSON schema` format. The configuration data is validated against this `JSON schema`.
             */
            schema?: {
                [k: string]: any;
            };
        };
        configurations: {
            /**
             * Configuration definition
             */
            [k: string]: {
                /**
                 * Title of the configuration
                 */
                title?: string;
                /**
                 * Description of the configuration
                 */
                description?: string;
                /**
                 * Identifier configuration of the [Integration](#schema_integration)
                 */
                identifier: {
                    linkTemplateScript?: string;
                    required: boolean;
                };
                /**
                 * Schema of the configuration in the `JSON schema` format. The configuration data is validated against this `JSON schema`.
                 */
                schema?: {
                    [k: string]: any;
                };
            };
        };
        channels: {
            /**
             * Channel definition
             */
            [k: string]: {
                /**
                 * Title of the channel
                 */
                title?: string;
                /**
                 * Description of the channel
                 */
                description?: string;
                messages: {
                    /**
                     * Message definition
                     */
                    [k: string]: {
                        schema: {
                            [k: string]: any;
                        };
                    };
                };
                /**
                 * Conversation object configuration
                 */
                conversation: {
                    tags: {
                        /**
                         * Definition of a tag that can be provided on the object
                         */
                        [k: string]: {
                            /**
                             * Title of the tag
                             */
                            title?: string;
                            /**
                             * Description of the tag
                             */
                            description?: string;
                        };
                    };
                    /**
                     * The conversation creation setting determines how to create a conversation through the API directly. The integration will have to implement the `createConversation` functionality to support this setting.
                     */
                    creation: {
                        /**
                         * Enable conversation creation
                         */
                        enabled: boolean;
                        /**
                         * The list of tags that are required to be specified when calling the API directly to create a conversation.
                         */
                        requiredTags: string[];
                    };
                };
                /**
                 * Message object configuration
                 */
                message: {
                    tags: {
                        /**
                         * Definition of a tag that can be provided on the object
                         */
                        [k: string]: {
                            /**
                             * Title of the tag
                             */
                            title?: string;
                            /**
                             * Description of the tag
                             */
                            description?: string;
                        };
                    };
                };
            };
        };
        states: {
            /**
             * State definition
             */
            [k: string]: {
                /**
                 * Type of the [State](#schema_state) (`conversation`, `user` or `integration`)
                 */
                type: "conversation" | "user" | "integration";
                /**
                 * Schema of the [State](#schema_state) in the `JSON schema` format. This `JSON schema` is going to be used for validating the state data.
                 */
                schema: {
                    [k: string]: any;
                };
            };
        };
        events: {
            /**
             * Event Definition
             */
            [k: string]: {
                /**
                 * Title of the event
                 */
                title?: string;
                /**
                 * Description of the event
                 */
                description?: string;
                schema: {
                    [k: string]: any;
                };
            };
        };
        actions: {
            /**
             * Action definition
             */
            [k: string]: {
                /**
                 * Title of the action
                 */
                title?: string;
                /**
                 * Description of the action
                 */
                description?: string;
                billable?: boolean;
                cacheable?: boolean;
                input: {
                    schema: {
                        [k: string]: any;
                    };
                };
                output: {
                    schema: {
                        [k: string]: any;
                    };
                };
            };
        };
        /**
         * User object configuration
         */
        user: {
            tags: {
                /**
                 * Definition of a tag that can be provided on the object
                 */
                [k: string]: {
                    /**
                     * Title of the tag
                     */
                    title?: string;
                    /**
                     * Description of the tag
                     */
                    description?: string;
                };
            };
            /**
             * The user creation setting determines how to create a user through the API directly. The integration will have to implement the `createUser` functionality to support this setting.
             */
            creation: {
                /**
                 * Enable user creation
                 */
                enabled: boolean;
                /**
                 * The list of tags that are required to be specified when calling the API directly to create a user.
                 */
                requiredTags: string[];
            };
        };
        entities: {
            /**
             * Entity definition
             */
            [k: string]: {
                /**
                 * Title of the entity
                 */
                title?: string;
                /**
                 * Description of the entity
                 */
                description?: string;
                schema: {
                    [k: string]: any;
                };
            };
        };
        /**
         * Indicates if the integration is a development integration; Dev integrations run locally
         */
        dev: boolean;
        /**
         * Title of the integration. This is the name that will be displayed in the UI
         */
        title: string;
        /**
         * Description of the integration. This is the description that will be displayed in the UI
         */
        description: string;
        /**
         * URL of the icon of the integration. This is the icon that will be displayed in the UI
         */
        iconUrl: string;
        /**
         * URL of the readme of the integration. This is the readme that will be displayed in the UI
         */
        readmeUrl: string;
        /**
         * Idicates if the integration is public. Public integrations are available to all and cannot be updated without creating a new version.
         */
        public: boolean;
        /**
         * Status of the integration version verification
         */
        verificationStatus: "unapproved" | "pending" | "approved" | "rejected";
        /**
         * Secrets are integration-wide values available in the code via environment variables formatted with a SECRET_ prefix followed by your secret name. A secret name must respect SCREAMING_SNAKE casing.
         */
        secrets: string[];
    };
}

interface DeleteIntegrationRequestHeaders {
}
interface DeleteIntegrationRequestQuery {
}
interface DeleteIntegrationRequestParams {
    id: string;
}
interface DeleteIntegrationRequestBody {
}
type DeleteIntegrationInput = DeleteIntegrationRequestBody & DeleteIntegrationRequestHeaders & DeleteIntegrationRequestQuery & DeleteIntegrationRequestParams;
interface DeleteIntegrationResponse {
}

interface RequestIntegrationVerificationRequestHeaders {
}
interface RequestIntegrationVerificationRequestQuery {
}
interface RequestIntegrationVerificationRequestParams {
}
interface RequestIntegrationVerificationRequestBody {
    integrationId: string;
}
type RequestIntegrationVerificationInput = RequestIntegrationVerificationRequestBody & RequestIntegrationVerificationRequestHeaders & RequestIntegrationVerificationRequestQuery & RequestIntegrationVerificationRequestParams;
interface RequestIntegrationVerificationResponse {
}

interface CreateInterfaceRequestHeaders {
}
interface CreateInterfaceRequestQuery {
}
interface CreateInterfaceRequestParams {
}
interface CreateInterfaceRequestBody {
    /**
     * Name of the [Interface](#schema_interface)
     */
    name: string;
    /**
     * Version of the [Interface](#schema_interface)
     */
    version: string;
    events: {
        /**
         * Event Definition
         */
        [k: string]: {
            /**
             * Title of the event
             */
            title?: string;
            /**
             * Description of the event
             */
            description?: string;
            schema: {
                [k: string]: any;
            };
        };
    };
    actions: {
        /**
         * Action definition
         */
        [k: string]: {
            /**
             * Title of the action
             */
            title?: string;
            /**
             * Description of the action
             */
            description?: string;
            billable?: boolean;
            cacheable?: boolean;
            input: {
                schema: {
                    [k: string]: any;
                };
            };
            output: {
                schema: {
                    [k: string]: any;
                };
            };
        };
    };
    entities: {
        /**
         * Entity definition
         */
        [k: string]: {
            /**
             * Title of the entity
             */
            title?: string;
            /**
             * Description of the entity
             */
            description?: string;
            schema: {
                [k: string]: any;
            };
        };
    };
    /**
     * Template string optionaly used at build time by integrations implementing this interface to pick a name for actions and events.
     */
    nameTemplate?: {
        script: string;
        language: string;
    };
}
type CreateInterfaceInput = CreateInterfaceRequestBody & CreateInterfaceRequestHeaders & CreateInterfaceRequestQuery & CreateInterfaceRequestParams;
interface CreateInterfaceResponse {
    interface: {
        /**
         * ID of the [Interface](#schema_interface)
         */
        id: string;
        /**
         * Creation date of the [Interface](#schema_interface) in ISO 8601 format
         */
        createdAt: string;
        /**
         * Updating date of the [Interface](#schema_interface) in ISO 8601 format
         */
        updatedAt: string;
        /**
         * Name of the [Interface](#schema_interface)
         */
        name: string;
        /**
         * Version of the [Interface](#schema_interface)
         */
        version: string;
        events: {
            /**
             * Event Definition
             */
            [k: string]: {
                /**
                 * Title of the event
                 */
                title?: string;
                /**
                 * Description of the event
                 */
                description?: string;
                schema: {
                    [k: string]: any;
                };
            };
        };
        actions: {
            /**
             * Action definition
             */
            [k: string]: {
                /**
                 * Title of the action
                 */
                title?: string;
                /**
                 * Description of the action
                 */
                description?: string;
                billable?: boolean;
                cacheable?: boolean;
                input: {
                    schema: {
                        [k: string]: any;
                    };
                };
                output: {
                    schema: {
                        [k: string]: any;
                    };
                };
            };
        };
        entities: {
            /**
             * Entity definition
             */
            [k: string]: {
                /**
                 * Title of the entity
                 */
                title?: string;
                /**
                 * Description of the entity
                 */
                description?: string;
                schema: {
                    [k: string]: any;
                };
            };
        };
        /**
         * Template string optionaly used at build time by integrations implementing this interface to pick a name for actions and events.
         */
        nameTemplate?: {
            script: string;
            language: string;
        };
    };
}

interface GetInterfaceRequestHeaders {
}
interface GetInterfaceRequestQuery {
}
interface GetInterfaceRequestParams {
    id: string;
}
interface GetInterfaceRequestBody {
}
type GetInterfaceInput = GetInterfaceRequestBody & GetInterfaceRequestHeaders & GetInterfaceRequestQuery & GetInterfaceRequestParams;
interface GetInterfaceResponse {
    interface: {
        /**
         * ID of the [Interface](#schema_interface)
         */
        id: string;
        /**
         * Creation date of the [Interface](#schema_interface) in ISO 8601 format
         */
        createdAt: string;
        /**
         * Updating date of the [Interface](#schema_interface) in ISO 8601 format
         */
        updatedAt: string;
        /**
         * Name of the [Interface](#schema_interface)
         */
        name: string;
        /**
         * Version of the [Interface](#schema_interface)
         */
        version: string;
        events: {
            /**
             * Event Definition
             */
            [k: string]: {
                /**
                 * Title of the event
                 */
                title?: string;
                /**
                 * Description of the event
                 */
                description?: string;
                schema: {
                    [k: string]: any;
                };
            };
        };
        actions: {
            /**
             * Action definition
             */
            [k: string]: {
                /**
                 * Title of the action
                 */
                title?: string;
                /**
                 * Description of the action
                 */
                description?: string;
                billable?: boolean;
                cacheable?: boolean;
                input: {
                    schema: {
                        [k: string]: any;
                    };
                };
                output: {
                    schema: {
                        [k: string]: any;
                    };
                };
            };
        };
        entities: {
            /**
             * Entity definition
             */
            [k: string]: {
                /**
                 * Title of the entity
                 */
                title?: string;
                /**
                 * Description of the entity
                 */
                description?: string;
                schema: {
                    [k: string]: any;
                };
            };
        };
        /**
         * Template string optionaly used at build time by integrations implementing this interface to pick a name for actions and events.
         */
        nameTemplate?: {
            script: string;
            language: string;
        };
    };
}

interface GetInterfaceByNameRequestHeaders {
}
interface GetInterfaceByNameRequestQuery {
}
interface GetInterfaceByNameRequestParams {
    name: string;
    version: string;
}
interface GetInterfaceByNameRequestBody {
}
type GetInterfaceByNameInput = GetInterfaceByNameRequestBody & GetInterfaceByNameRequestHeaders & GetInterfaceByNameRequestQuery & GetInterfaceByNameRequestParams;
interface GetInterfaceByNameResponse {
    interface: {
        /**
         * ID of the [Interface](#schema_interface)
         */
        id: string;
        /**
         * Creation date of the [Interface](#schema_interface) in ISO 8601 format
         */
        createdAt: string;
        /**
         * Updating date of the [Interface](#schema_interface) in ISO 8601 format
         */
        updatedAt: string;
        /**
         * Name of the [Interface](#schema_interface)
         */
        name: string;
        /**
         * Version of the [Interface](#schema_interface)
         */
        version: string;
        events: {
            /**
             * Event Definition
             */
            [k: string]: {
                /**
                 * Title of the event
                 */
                title?: string;
                /**
                 * Description of the event
                 */
                description?: string;
                schema: {
                    [k: string]: any;
                };
            };
        };
        actions: {
            /**
             * Action definition
             */
            [k: string]: {
                /**
                 * Title of the action
                 */
                title?: string;
                /**
                 * Description of the action
                 */
                description?: string;
                billable?: boolean;
                cacheable?: boolean;
                input: {
                    schema: {
                        [k: string]: any;
                    };
                };
                output: {
                    schema: {
                        [k: string]: any;
                    };
                };
            };
        };
        entities: {
            /**
             * Entity definition
             */
            [k: string]: {
                /**
                 * Title of the entity
                 */
                title?: string;
                /**
                 * Description of the entity
                 */
                description?: string;
                schema: {
                    [k: string]: any;
                };
            };
        };
        /**
         * Template string optionaly used at build time by integrations implementing this interface to pick a name for actions and events.
         */
        nameTemplate?: {
            script: string;
            language: string;
        };
    };
}

interface UpdateInterfaceRequestHeaders {
}
interface UpdateInterfaceRequestQuery {
}
interface UpdateInterfaceRequestParams {
    id: string;
}
interface UpdateInterfaceRequestBody {
    events?: {
        /**
         * Event Definition
         */
        [k: string]: {
            /**
             * Title of the event
             */
            title?: string;
            /**
             * Description of the event
             */
            description?: string;
            schema: {
                [k: string]: any;
            };
        } | null;
    };
    actions?: {
        /**
         * Action definition
         */
        [k: string]: {
            /**
             * Title of the action
             */
            title?: string;
            /**
             * Description of the action
             */
            description?: string;
            billable?: boolean;
            cacheable?: boolean;
            input: {
                schema: {
                    [k: string]: any;
                };
            };
            output: {
                schema: {
                    [k: string]: any;
                };
            };
        } | null;
    };
    entities?: {
        /**
         * Entity definition
         */
        [k: string]: {
            /**
             * Title of the entity
             */
            title?: string;
            /**
             * Description of the entity
             */
            description?: string;
            schema: {
                [k: string]: any;
            };
        } | null;
    };
    /**
     * Template string optionaly used at build time by integrations implementing this interface to pick a name for actions and events.
     */
    nameTemplate?: {
        script: string;
        language: string;
    } | null;
}
type UpdateInterfaceInput = UpdateInterfaceRequestBody & UpdateInterfaceRequestHeaders & UpdateInterfaceRequestQuery & UpdateInterfaceRequestParams;
interface UpdateInterfaceResponse {
    interface: {
        /**
         * ID of the [Interface](#schema_interface)
         */
        id: string;
        /**
         * Creation date of the [Interface](#schema_interface) in ISO 8601 format
         */
        createdAt: string;
        /**
         * Updating date of the [Interface](#schema_interface) in ISO 8601 format
         */
        updatedAt: string;
        /**
         * Name of the [Interface](#schema_interface)
         */
        name: string;
        /**
         * Version of the [Interface](#schema_interface)
         */
        version: string;
        events: {
            /**
             * Event Definition
             */
            [k: string]: {
                /**
                 * Title of the event
                 */
                title?: string;
                /**
                 * Description of the event
                 */
                description?: string;
                schema: {
                    [k: string]: any;
                };
            };
        };
        actions: {
            /**
             * Action definition
             */
            [k: string]: {
                /**
                 * Title of the action
                 */
                title?: string;
                /**
                 * Description of the action
                 */
                description?: string;
                billable?: boolean;
                cacheable?: boolean;
                input: {
                    schema: {
                        [k: string]: any;
                    };
                };
                output: {
                    schema: {
                        [k: string]: any;
                    };
                };
            };
        };
        entities: {
            /**
             * Entity definition
             */
            [k: string]: {
                /**
                 * Title of the entity
                 */
                title?: string;
                /**
                 * Description of the entity
                 */
                description?: string;
                schema: {
                    [k: string]: any;
                };
            };
        };
        /**
         * Template string optionaly used at build time by integrations implementing this interface to pick a name for actions and events.
         */
        nameTemplate?: {
            script: string;
            language: string;
        };
    };
}

interface DeleteInterfaceRequestHeaders {
}
interface DeleteInterfaceRequestQuery {
}
interface DeleteInterfaceRequestParams {
    id: string;
}
interface DeleteInterfaceRequestBody {
}
type DeleteInterfaceInput = DeleteInterfaceRequestBody & DeleteInterfaceRequestHeaders & DeleteInterfaceRequestQuery & DeleteInterfaceRequestParams;
interface DeleteInterfaceResponse {
}

interface ListInterfacesRequestHeaders {
}
interface ListInterfacesRequestQuery {
    nextToken?: string;
}
interface ListInterfacesRequestParams {
}
interface ListInterfacesRequestBody {
}
type ListInterfacesInput = ListInterfacesRequestBody & ListInterfacesRequestHeaders & ListInterfacesRequestQuery & ListInterfacesRequestParams;
interface ListInterfacesResponse {
    interfaces: {
        /**
         * ID of the [Interface](#schema_interface)
         */
        id: string;
        /**
         * Creation date of the [Interface](#schema_interface) in ISO 8601 format
         */
        createdAt: string;
        /**
         * Updating date of the [Interface](#schema_interface) in ISO 8601 format
         */
        updatedAt: string;
        /**
         * Name of the [Interface](#schema_interface)
         */
        name: string;
        /**
         * Version of the [Interface](#schema_interface)
         */
        version: string;
    }[];
    meta: {
        /**
         * The token to use to retrieve the next page of results, passed as a query string parameter (value should be URL-encoded) to this API endpoint.
         */
        nextToken?: string;
    };
}

interface GetUsageRequestHeaders {
}
interface GetUsageRequestQuery {
    type: "invocation_timeout" | "invocation_calls" | "storage_count" | "bot_count" | "knowledgebase_vector_storage" | "workspace_ratelimit" | "table_row_count" | "workspace_member_count" | "integrations_owned_count" | "ai_spend" | "openai_spend" | "bing_search_spend" | "always_alive";
    period?: string;
}
interface GetUsageRequestParams {
    id: string;
}
interface GetUsageRequestBody {
}
type GetUsageInput = GetUsageRequestBody & GetUsageRequestHeaders & GetUsageRequestQuery & GetUsageRequestParams;
interface GetUsageResponse {
    usage: {
        /**
         * Id of the usage that it is linked to. It can either be a workspace id or a bot id
         */
        id: string;
        /**
         * Period of the quota that it is applied to
         */
        period: string;
        /**
         * Value of the current usage
         */
        value: number;
        /**
         * Quota of the current usage
         */
        quota: number;
        /**
         * Usage type that can be used
         */
        type: "invocation_timeout" | "invocation_calls" | "storage_count" | "bot_count" | "knowledgebase_vector_storage" | "workspace_ratelimit" | "table_row_count" | "workspace_member_count" | "integrations_owned_count" | "ai_spend" | "openai_spend" | "bing_search_spend" | "always_alive";
    };
}

interface GetMultipleUsagesRequestHeaders {
}
interface GetMultipleUsagesRequestQuery {
    types: string[];
    ids: string[];
    period?: string;
}
interface GetMultipleUsagesRequestParams {
}
interface GetMultipleUsagesRequestBody {
}
type GetMultipleUsagesInput = GetMultipleUsagesRequestBody & GetMultipleUsagesRequestHeaders & GetMultipleUsagesRequestQuery & GetMultipleUsagesRequestParams;
interface GetMultipleUsagesResponse {
    usages: {
        /**
         * Id of the usage that it is linked to. It can either be a workspace id or a bot id
         */
        id: string;
        /**
         * Period of the quota that it is applied to
         */
        period: string;
        /**
         * Value of the current usage
         */
        value: number;
        /**
         * Quota of the current usage
         */
        quota: number;
        /**
         * Usage type that can be used
         */
        type: "invocation_timeout" | "invocation_calls" | "storage_count" | "bot_count" | "knowledgebase_vector_storage" | "workspace_ratelimit" | "table_row_count" | "workspace_member_count" | "integrations_owned_count" | "ai_spend" | "openai_spend" | "bing_search_spend" | "always_alive";
    }[];
}

interface ListUsageHistoryRequestHeaders {
}
interface ListUsageHistoryRequestQuery {
    type: "invocation_timeout" | "invocation_calls" | "storage_count" | "bot_count" | "knowledgebase_vector_storage" | "workspace_ratelimit" | "table_row_count" | "workspace_member_count" | "integrations_owned_count" | "ai_spend" | "openai_spend" | "bing_search_spend" | "always_alive";
}
interface ListUsageHistoryRequestParams {
    id: string;
}
interface ListUsageHistoryRequestBody {
}
type ListUsageHistoryInput = ListUsageHistoryRequestBody & ListUsageHistoryRequestHeaders & ListUsageHistoryRequestQuery & ListUsageHistoryRequestParams;
interface ListUsageHistoryResponse {
    usages: {
        /**
         * Id of the usage that it is linked to. It can either be a workspace id or a bot id
         */
        id: string;
        /**
         * Period of the quota that it is applied to
         */
        period: string;
        /**
         * Value of the current usage
         */
        value: number;
        /**
         * Quota of the current usage
         */
        quota: number;
        /**
         * Usage type that can be used
         */
        type: "invocation_timeout" | "invocation_calls" | "storage_count" | "bot_count" | "knowledgebase_vector_storage" | "workspace_ratelimit" | "table_row_count" | "workspace_member_count" | "integrations_owned_count" | "ai_spend" | "openai_spend" | "bing_search_spend" | "always_alive";
    }[];
}

interface ListUsageActivityRequestHeaders {
}
interface ListUsageActivityRequestQuery {
    type: "invocation_timeout" | "invocation_calls" | "storage_count" | "bot_count" | "knowledgebase_vector_storage" | "workspace_ratelimit" | "table_row_count" | "workspace_member_count" | "integrations_owned_count" | "ai_spend" | "openai_spend" | "bing_search_spend" | "always_alive";
    nextToken?: string;
}
interface ListUsageActivityRequestParams {
    id: string;
}
interface ListUsageActivityRequestBody {
}
type ListUsageActivityInput = ListUsageActivityRequestBody & ListUsageActivityRequestHeaders & ListUsageActivityRequestQuery & ListUsageActivityRequestParams;
interface ListUsageActivityResponse {
    data: {
        timestamp: string;
        value: number;
        period: string;
        metadata: {
            [k: string]: any | null;
        };
    }[];
    meta: {
        nextToken?: string;
    };
}

interface ChangeAispendQuotaRequestHeaders {
}
interface ChangeAispendQuotaRequestQuery {
}
interface ChangeAispendQuotaRequestParams {
}
interface ChangeAispendQuotaRequestBody {
    monthlySpendingLimit: number;
}
type ChangeAispendQuotaInput = ChangeAispendQuotaRequestBody & ChangeAispendQuotaRequestHeaders & ChangeAispendQuotaRequestQuery & ChangeAispendQuotaRequestParams;
interface ChangeAispendQuotaResponse {
}

interface ListActivitiesRequestHeaders {
}
interface ListActivitiesRequestQuery {
    nextToken?: string;
    taskId: string;
    botId: string;
}
interface ListActivitiesRequestParams {
}
interface ListActivitiesRequestBody {
}
type ListActivitiesInput = ListActivitiesRequestBody & ListActivitiesRequestHeaders & ListActivitiesRequestQuery & ListActivitiesRequestParams;
interface ListActivitiesResponse {
    activities: {
        id: string;
        description: string;
        taskId: string;
        category: "unknown" | "capture" | "bot_message" | "user_message" | "agent_message" | "event" | "action" | "task_status" | "subtask_status" | "exception";
        data: {
            [k: string]: any;
        };
        /**
         * Creation date of the activity in ISO 8601 format
         */
        createdAt: string;
    }[];
    meta: {
        /**
         * The token to use to retrieve the next page of results, passed as a query string parameter (value should be URL-encoded) to this API endpoint.
         */
        nextToken?: string;
    };
}

interface IntrospectRequestHeaders {
}
interface IntrospectRequestQuery {
}
interface IntrospectRequestParams {
}
interface IntrospectRequestBody {
    botId: string;
}
type IntrospectInput = IntrospectRequestBody & IntrospectRequestHeaders & IntrospectRequestQuery & IntrospectRequestParams;
interface IntrospectResponse {
    workspaceId: string;
    botId: string;
    userId: string;
}

interface UpsertFileRequestHeaders {
}
interface UpsertFileRequestQuery {
}
interface UpsertFileRequestParams {
}
interface UpsertFileRequestBody {
    /**
     * Unique key for the file. Must be unique across the bot (and the integration, when applicable).
     */
    key: string;
    /**
     * File tags as an object of key-value pairs. Tag values should be of `string` (text) type.
     */
    tags?: {
        [k: string]: string;
    };
    /**
     * File size in bytes. This will count against your File Storage quota. If the `index` parameter is set to `true`, this will also count against your Vector DB Storage quota.
     */
    size: number;
    /**
     * Set to a value of 'true' to index the file in vector storage. Only certain file formats are currently supported for indexing. Note that if a file is indexed, it will count towards both the Vector DB Storage quota and the File Storage quota of the workspace.
     */
    index?: boolean;
    /**
     * File access policies. Add "public_content" to allow public access to the file content. Add "integrations" to allow read, search and list operations for any integration installed in the bot.
     */
    accessPolicies?: ("public_content" | "integrations")[];
    /**
     * File content type. If omitted, the content type will be inferred from the file extension (if any) specified in `key`. If a content type cannot be inferred, the default is "application/octet-stream".
     */
    contentType?: string;
    /**
     * Expiry timestamp in ISO 8601 format with UTC timezone. After expiry, the File will be deleted. Must be in the future. Cannot be more than 90 days from now. The value up to minutes is considered. Seconds and milliseconds are ignored.
     */
    expiresAt?: string;
    /**
     * Use when your file has "public_content" in its access policy and you need the file\'s content to be immediately accessible through its URL after the file has been uploaded without having to wait for the upload to be processed by our system.
     *
     * If set to `true`, the `x-amz-tagging` HTTP header with a value of `public=true` will need to be sent in the HTTP PUT request to the `uploadUrl` in order for the upload request to work.
     */
    publicContentImmediatelyAccessible?: boolean;
}
type UpsertFileInput = UpsertFileRequestBody & UpsertFileRequestHeaders & UpsertFileRequestQuery & UpsertFileRequestParams;
interface UpsertFileResponse {
    file: {
        /**
         * File ID
         */
        id: string;
        /**
         * The ID of the bot the file belongs to
         */
        botId: string;
        /**
         * Unique key for the file. Must be unique across the bot (and the integration, when applicable).
         */
        key: string;
        /**
         * URL to retrieve the file content. This URL will be ready to use once the file is uploaded.
         *
         * If the file has a `public_content` policy, this will contain the permanent public URL to retrieve the file, otherwise this will contain a temporary pre-signed URL to download the file which should be used shortly after retrieving and should not be stored long-term as the URL will expire after a short timeframe.
         */
        url: string;
        /**
         * File size in bytes. Non-null if file upload status is "COMPLETE".
         */
        size: number | null;
        /**
         * MIME type of the file's content
         */
        contentType: string;
        /**
         * The tags of the file as an object of key/value pairs
         */
        tags: {
            [k: string]: string;
        };
        /**
         * File creation timestamp in ISO 8601 format
         */
        createdAt: string;
        /**
         * File last update timestamp in ISO 8601 format
         */
        updatedAt: string;
        /**
         * Access policies configured for the file.
         */
        accessPolicies: ("integrations" | "public_content")[];
        /**
         * Whether the file was requested to be indexed for search or not.
         */
        index: boolean;
        /**
         * Status of the file. If the status is `upload_pending`, the file content has not been uploaded yet. The status will be set to `upload_completed` once the file content has been uploaded successfully.
         *
         * If the upload failed for any reason (e.g. exceeding the storage quota or the maximum file size limit) the status will be set to `upload_failed` and the reason for the failure will be available in the `failedStatusReason` field of the file.
         *
         * However, if the file has been uploaded and the `index` attribute was set to `true` on the file, the status will immediately transition to the `indexing_pending` status (the `upload_completed` status step will be skipped).
         *
         * Once the indexing is completed and the file is ready to be used for searching its status will be set to `indexing_completed`. If the indexing failed the status will be set to `indexing_failed` and the reason for the failure will be available in the `failedStatusReason` field.
         */
        status: "upload_pending" | "upload_failed" | "upload_completed" | "indexing_pending" | "indexing_failed" | "indexing_completed";
        /**
         * If the file status is `upload_failed` or `indexing_failed` this will contain the reason of the failure.
         */
        failedStatusReason?: string;
        /**
         * File expiry timestamp in ISO 8601 format
         */
        expiresAt?: string;
        /**
         * URL to upload the file content. File content needs to be sent to this URL via a PUT request.
         */
        uploadUrl: string;
    };
}

interface DeleteFileRequestHeaders {
}
interface DeleteFileRequestQuery {
}
interface DeleteFileRequestParams {
    id: string;
}
interface DeleteFileRequestBody {
}
type DeleteFileInput = DeleteFileRequestBody & DeleteFileRequestHeaders & DeleteFileRequestQuery & DeleteFileRequestParams;
interface DeleteFileResponse {
}

interface ListFilesRequestHeaders {
}
interface ListFilesRequestQuery {
    nextToken?: string;
    tags?: any;
    /**
     * @maxItems 50
     */
    ids?: string[];
}
interface ListFilesRequestParams {
}
interface ListFilesRequestBody {
}
type ListFilesInput = ListFilesRequestBody & ListFilesRequestHeaders & ListFilesRequestQuery & ListFilesRequestParams;
interface ListFilesResponse {
    files: {
        /**
         * File ID
         */
        id: string;
        /**
         * The ID of the bot the file belongs to
         */
        botId: string;
        /**
         * Unique key for the file. Must be unique across the bot (and the integration, when applicable).
         */
        key: string;
        /**
         * URL to retrieve the file content. This URL will be ready to use once the file is uploaded.
         *
         * If the file has a `public_content` policy, this will contain the permanent public URL to retrieve the file, otherwise this will contain a temporary pre-signed URL to download the file which should be used shortly after retrieving and should not be stored long-term as the URL will expire after a short timeframe.
         */
        url: string;
        /**
         * File size in bytes. Non-null if file upload status is "COMPLETE".
         */
        size: number | null;
        /**
         * MIME type of the file's content
         */
        contentType: string;
        /**
         * The tags of the file as an object of key/value pairs
         */
        tags: {
            [k: string]: string;
        };
        /**
         * File creation timestamp in ISO 8601 format
         */
        createdAt: string;
        /**
         * File last update timestamp in ISO 8601 format
         */
        updatedAt: string;
        /**
         * Access policies configured for the file.
         */
        accessPolicies: ("integrations" | "public_content")[];
        /**
         * Whether the file was requested to be indexed for search or not.
         */
        index: boolean;
        /**
         * Status of the file. If the status is `upload_pending`, the file content has not been uploaded yet. The status will be set to `upload_completed` once the file content has been uploaded successfully.
         *
         * If the upload failed for any reason (e.g. exceeding the storage quota or the maximum file size limit) the status will be set to `upload_failed` and the reason for the failure will be available in the `failedStatusReason` field of the file.
         *
         * However, if the file has been uploaded and the `index` attribute was set to `true` on the file, the status will immediately transition to the `indexing_pending` status (the `upload_completed` status step will be skipped).
         *
         * Once the indexing is completed and the file is ready to be used for searching its status will be set to `indexing_completed`. If the indexing failed the status will be set to `indexing_failed` and the reason for the failure will be available in the `failedStatusReason` field.
         */
        status: "upload_pending" | "upload_failed" | "upload_completed" | "indexing_pending" | "indexing_failed" | "indexing_completed";
        /**
         * If the file status is `upload_failed` or `indexing_failed` this will contain the reason of the failure.
         */
        failedStatusReason?: string;
        /**
         * File expiry timestamp in ISO 8601 format
         */
        expiresAt?: string;
    }[];
    meta: {
        /**
         * The token to use to retrieve the next page of results, passed as a query string parameter (value should be URL-encoded) to this API endpoint.
         */
        nextToken?: string;
    };
}

interface GetFileRequestHeaders {
}
interface GetFileRequestQuery {
}
interface GetFileRequestParams {
    id: string;
}
interface GetFileRequestBody {
}
type GetFileInput = GetFileRequestBody & GetFileRequestHeaders & GetFileRequestQuery & GetFileRequestParams;
interface GetFileResponse {
    file: {
        /**
         * File ID
         */
        id: string;
        /**
         * The ID of the bot the file belongs to
         */
        botId: string;
        /**
         * Unique key for the file. Must be unique across the bot (and the integration, when applicable).
         */
        key: string;
        /**
         * URL to retrieve the file content. This URL will be ready to use once the file is uploaded.
         *
         * If the file has a `public_content` policy, this will contain the permanent public URL to retrieve the file, otherwise this will contain a temporary pre-signed URL to download the file which should be used shortly after retrieving and should not be stored long-term as the URL will expire after a short timeframe.
         */
        url: string;
        /**
         * File size in bytes. Non-null if file upload status is "COMPLETE".
         */
        size: number | null;
        /**
         * MIME type of the file's content
         */
        contentType: string;
        /**
         * The tags of the file as an object of key/value pairs
         */
        tags: {
            [k: string]: string;
        };
        /**
         * File creation timestamp in ISO 8601 format
         */
        createdAt: string;
        /**
         * File last update timestamp in ISO 8601 format
         */
        updatedAt: string;
        /**
         * Access policies configured for the file.
         */
        accessPolicies: ("integrations" | "public_content")[];
        /**
         * Whether the file was requested to be indexed for search or not.
         */
        index: boolean;
        /**
         * Status of the file. If the status is `upload_pending`, the file content has not been uploaded yet. The status will be set to `upload_completed` once the file content has been uploaded successfully.
         *
         * If the upload failed for any reason (e.g. exceeding the storage quota or the maximum file size limit) the status will be set to `upload_failed` and the reason for the failure will be available in the `failedStatusReason` field of the file.
         *
         * However, if the file has been uploaded and the `index` attribute was set to `true` on the file, the status will immediately transition to the `indexing_pending` status (the `upload_completed` status step will be skipped).
         *
         * Once the indexing is completed and the file is ready to be used for searching its status will be set to `indexing_completed`. If the indexing failed the status will be set to `indexing_failed` and the reason for the failure will be available in the `failedStatusReason` field.
         */
        status: "upload_pending" | "upload_failed" | "upload_completed" | "indexing_pending" | "indexing_failed" | "indexing_completed";
        /**
         * If the file status is `upload_failed` or `indexing_failed` this will contain the reason of the failure.
         */
        failedStatusReason?: string;
        /**
         * File expiry timestamp in ISO 8601 format
         */
        expiresAt?: string;
    };
}

interface UpdateFileMetadataRequestHeaders {
}
interface UpdateFileMetadataRequestQuery {
}
interface UpdateFileMetadataRequestParams {
    id: string;
}
interface UpdateFileMetadataRequestBody {
    /**
     * The file tags to update as an object of key-value pairs with `string` (text) values. Omit to keep existing tags intact. Any existing tags not included will be preserved. New tags will be added. To delete a tag, set its value to `null`.
     */
    tags?: {
        [k: string]: string | null;
    };
    /**
     * New access policies to set for the file. Omit to keep existing policies intact.
     */
    accessPolicies?: ("integrations" | "public_content")[];
    /**
     * Expiry timestamp in ISO 8601 format with UTC timezone. After expiry, the File will be deleted. Must be in the future. Cannot be more than 90 days from now. The value up to minutes is considered. Seconds and milliseconds are ignored. Omit to keep the existing expiry intact. Set to `null` to remove the expiry.
     */
    expiresAt?: string | null;
}
type UpdateFileMetadataInput = UpdateFileMetadataRequestBody & UpdateFileMetadataRequestHeaders & UpdateFileMetadataRequestQuery & UpdateFileMetadataRequestParams;
interface UpdateFileMetadataResponse {
    file: {
        /**
         * File ID
         */
        id: string;
        /**
         * The ID of the bot the file belongs to
         */
        botId: string;
        /**
         * Unique key for the file. Must be unique across the bot (and the integration, when applicable).
         */
        key: string;
        /**
         * URL to retrieve the file content. This URL will be ready to use once the file is uploaded.
         *
         * If the file has a `public_content` policy, this will contain the permanent public URL to retrieve the file, otherwise this will contain a temporary pre-signed URL to download the file which should be used shortly after retrieving and should not be stored long-term as the URL will expire after a short timeframe.
         */
        url: string;
        /**
         * File size in bytes. Non-null if file upload status is "COMPLETE".
         */
        size: number | null;
        /**
         * MIME type of the file's content
         */
        contentType: string;
        /**
         * The tags of the file as an object of key/value pairs
         */
        tags: {
            [k: string]: string;
        };
        /**
         * File creation timestamp in ISO 8601 format
         */
        createdAt: string;
        /**
         * File last update timestamp in ISO 8601 format
         */
        updatedAt: string;
        /**
         * Access policies configured for the file.
         */
        accessPolicies: ("integrations" | "public_content")[];
        /**
         * Whether the file was requested to be indexed for search or not.
         */
        index: boolean;
        /**
         * Status of the file. If the status is `upload_pending`, the file content has not been uploaded yet. The status will be set to `upload_completed` once the file content has been uploaded successfully.
         *
         * If the upload failed for any reason (e.g. exceeding the storage quota or the maximum file size limit) the status will be set to `upload_failed` and the reason for the failure will be available in the `failedStatusReason` field of the file.
         *
         * However, if the file has been uploaded and the `index` attribute was set to `true` on the file, the status will immediately transition to the `indexing_pending` status (the `upload_completed` status step will be skipped).
         *
         * Once the indexing is completed and the file is ready to be used for searching its status will be set to `indexing_completed`. If the indexing failed the status will be set to `indexing_failed` and the reason for the failure will be available in the `failedStatusReason` field.
         */
        status: "upload_pending" | "upload_failed" | "upload_completed" | "indexing_pending" | "indexing_failed" | "indexing_completed";
        /**
         * If the file status is `upload_failed` or `indexing_failed` this will contain the reason of the failure.
         */
        failedStatusReason?: string;
        /**
         * File expiry timestamp in ISO 8601 format
         */
        expiresAt?: string;
    };
}

interface SearchFilesRequestHeaders {
}
interface SearchFilesRequestQuery {
    tags?: any;
    query: string;
    contextDepth?: number;
    limit?: number;
    consolidate?: boolean;
    includeBreadcrumb?: boolean;
}
interface SearchFilesRequestParams {
}
interface SearchFilesRequestBody {
}
type SearchFilesInput = SearchFilesRequestBody & SearchFilesRequestHeaders & SearchFilesRequestQuery & SearchFilesRequestParams;
interface SearchFilesResponse {
    passages: {
        /**
         * The content of the matching passage in the file including surrounding context, if any.
         */
        content: string;
        /**
         * The score indicating the similarity of the passage to the query. A higher score indicates higher similarity.
         */
        score: number;
        /**
         * The passage metadata.
         */
        meta: {
            /**
             * The type of passage
             */
            type?: "chunk" | "summary" | "consolidated";
            /**
             * The subtype of passage, if available.
             */
            subtype?: "title" | "subtitle" | "paragraph" | "list" | "blockquote" | "table" | "code";
            /**
             * Page number the passage is located on. Only applicable if the passage was extracted from a PDF file.
             */
            pageNumber?: number;
            /**
             * Position number of the passage in the file relative to the other passages, if available. Can be used to know the order of passages within a file.
             */
            position?: number;
        };
        file: {
            /**
             * File ID
             */
            id: string;
            /**
             * Unique key for the file. Must be unique across the bot (and the integration, when applicable).
             */
            key: string;
            /**
             * MIME type of the file's content
             */
            contentType: string;
            /**
             * The tags of the file as an object of key-value pairs.
             */
            tags: {
                [k: string]: string;
            };
            /**
             * File creation timestamp in ISO 8601 format
             */
            createdAt: string;
            /**
             * File last update timestamp in ISO 8601 format
             */
            updatedAt: string;
        };
    }[];
}

interface ListFilePassagesRequestHeaders {
}
interface ListFilePassagesRequestQuery {
    nextToken?: string;
    limit?: number;
}
interface ListFilePassagesRequestParams {
    fileId: string;
}
interface ListFilePassagesRequestBody {
}
type ListFilePassagesInput = ListFilePassagesRequestBody & ListFilePassagesRequestHeaders & ListFilePassagesRequestQuery & ListFilePassagesRequestParams;
interface ListFilePassagesResponse {
    passages: {
        /**
         * Passage ID
         */
        id: string;
        /**
         * The content of the passage.
         */
        content: string;
        /**
         * The passage metadata.
         */
        meta: {
            /**
             * The type of passage
             */
            type?: "chunk" | "summary" | "consolidated";
            /**
             * The subtype of passage, if available.
             */
            subtype?: "title" | "subtitle" | "paragraph" | "list" | "blockquote" | "table" | "code";
            /**
             * Page number the passage is located on. Only applicable if the passage was extracted from a PDF file.
             */
            pageNumber?: number;
            /**
             * Position number of the passage in the file relative to the other passages, if available. Can be used to know the order of passages within a file.
             */
            position?: number;
        };
    }[];
    meta: {
        /**
         * The token to use to retrieve the next page of results, passed as a query string parameter (value should be URL-encoded) to this API endpoint.
         */
        nextToken?: string;
    };
}

interface ListTablesRequestHeaders {
}
interface ListTablesRequestQuery {
    tags?: {
        [k: string]: string;
    };
}
interface ListTablesRequestParams {
}
interface ListTablesRequestBody {
}
type ListTablesInput = ListTablesRequestBody & ListTablesRequestHeaders & ListTablesRequestQuery & ListTablesRequestParams;
interface ListTablesResponse {
    tables: {
        /**
         * Unique identifier for the table
         */
        id: string;
        /**
         * Required. This name is used to identify your table.
         */
        name: string;
        /**
         * The 'factor' multiplies the row's data storage limit by 4KB and its quota count, but can only be set at table creation and not modified later. For instance, a factor of 2 increases storage to 8KB but counts as 2 rows in your quota. The default factor is 1.
         */
        factor?: number;
        /**
         * A table designated as "frozen" is immutable in terms of its name and schema structure; modifications to its schema or a renaming operation are not permitted. The only action that can be taken on such a table is deletion. The schema established at the time of creation is locked in as the final structure. To implement any changes, the table must be duplicated with the desired alterations.
         */
        frozen?: boolean;
        schema: {
            $schema: string;
            /**
             * List of keys/columns in the table.
             */
            properties: {
                [k: string]: {
                    type: "string" | "number" | "boolean" | "object" | "array" | "null";
                    format?: "date-time";
                    description?: string;
                    /**
                     * String properties must match this pattern
                     */
                    pattern?: string;
                    /**
                     * String properties must be one of these values
                     */
                    enum?: string[];
                    /**
                     * Defines the shape of items in an array
                     */
                    items?: {
                        type: "string" | "number" | "boolean" | "object" | "array" | "null";
                        [k: string]: any;
                    };
                    nullable?: boolean;
                    properties?: {
                        [k: string]: {
                            type: "string" | "number" | "boolean" | "object" | "array" | "null";
                            [k: string]: any;
                        };
                    };
                    "x-zui": {
                        index: number;
                        /**
                         * [deprecated] ID of the column.
                         */
                        id?: string;
                        /**
                         * Indicates if the column is vectorized and searchable.
                         */
                        searchable?: boolean;
                        /**
                         * Indicates if the field is hidden in the UI
                         */
                        hidden?: boolean;
                        /**
                         * Order of the column in the UI
                         */
                        order?: number;
                        /**
                         * Width of the column in the UI
                         */
                        width?: number;
                        /**
                         * ID of the schema
                         */
                        schemaId?: string;
                        computed?: {
                            action: "ai" | "code" | "workflow";
                            dependencies?: string[];
                            /**
                             * Prompt when action is "ai"
                             */
                            prompt?: string;
                            /**
                             * Code to execute when action is "code"
                             */
                            code?: string;
                            /**
                             * Model to use when action is "ai"
                             */
                            model?: string;
                            /**
                             * ID of Workflow to execute when action is "workflow"
                             */
                            workflowId?: string;
                            enabled?: boolean;
                        };
                        /**
                         * TypeScript typings for the column. Recommended if the type is "object", ex: "\{ foo: string; bar: number \}"
                         */
                        typings?: string;
                    };
                };
            };
            /**
             * Additional properties can be provided, but they will be ignored if no column matches.
             */
            additionalProperties: true;
            /**
             * Array of required properties.
             */
            required?: string[];
            type: "object";
        };
        /**
         * Optional tags to help organize your tables. These should be passed here as an object representing key/value pairs.
         */
        tags?: {
            [k: string]: string;
        };
        /**
         * Indicates if the table is enabled for computation.
         */
        isComputeEnabled?: boolean;
        /**
         * Timestamp of table creation.
         */
        createdAt?: string;
        /**
         * Timestamp of the last table update.
         */
        updatedAt?: string;
    }[];
}

interface GetTableRequestHeaders {
}
interface GetTableRequestQuery {
}
interface GetTableRequestParams {
    table: string;
}
interface GetTableRequestBody {
}
type GetTableInput = GetTableRequestBody & GetTableRequestHeaders & GetTableRequestQuery & GetTableRequestParams;
interface GetTableResponse {
    table: {
        /**
         * Unique identifier for the table
         */
        id: string;
        /**
         * Required. This name is used to identify your table.
         */
        name: string;
        /**
         * The 'factor' multiplies the row's data storage limit by 4KB and its quota count, but can only be set at table creation and not modified later. For instance, a factor of 2 increases storage to 8KB but counts as 2 rows in your quota. The default factor is 1.
         */
        factor?: number;
        /**
         * A table designated as "frozen" is immutable in terms of its name and schema structure; modifications to its schema or a renaming operation are not permitted. The only action that can be taken on such a table is deletion. The schema established at the time of creation is locked in as the final structure. To implement any changes, the table must be duplicated with the desired alterations.
         */
        frozen?: boolean;
        schema: {
            $schema: string;
            /**
             * List of keys/columns in the table.
             */
            properties: {
                [k: string]: {
                    type: "string" | "number" | "boolean" | "object" | "array" | "null";
                    format?: "date-time";
                    description?: string;
                    /**
                     * String properties must match this pattern
                     */
                    pattern?: string;
                    /**
                     * String properties must be one of these values
                     */
                    enum?: string[];
                    /**
                     * Defines the shape of items in an array
                     */
                    items?: {
                        type: "string" | "number" | "boolean" | "object" | "array" | "null";
                        [k: string]: any;
                    };
                    nullable?: boolean;
                    properties?: {
                        [k: string]: {
                            type: "string" | "number" | "boolean" | "object" | "array" | "null";
                            [k: string]: any;
                        };
                    };
                    "x-zui": {
                        index: number;
                        /**
                         * [deprecated] ID of the column.
                         */
                        id?: string;
                        /**
                         * Indicates if the column is vectorized and searchable.
                         */
                        searchable?: boolean;
                        /**
                         * Indicates if the field is hidden in the UI
                         */
                        hidden?: boolean;
                        /**
                         * Order of the column in the UI
                         */
                        order?: number;
                        /**
                         * Width of the column in the UI
                         */
                        width?: number;
                        /**
                         * ID of the schema
                         */
                        schemaId?: string;
                        computed?: {
                            action: "ai" | "code" | "workflow";
                            dependencies?: string[];
                            /**
                             * Prompt when action is "ai"
                             */
                            prompt?: string;
                            /**
                             * Code to execute when action is "code"
                             */
                            code?: string;
                            /**
                             * Model to use when action is "ai"
                             */
                            model?: string;
                            /**
                             * ID of Workflow to execute when action is "workflow"
                             */
                            workflowId?: string;
                            enabled?: boolean;
                        };
                        /**
                         * TypeScript typings for the column. Recommended if the type is "object", ex: "\{ foo: string; bar: number \}"
                         */
                        typings?: string;
                    };
                };
            };
            /**
             * Additional properties can be provided, but they will be ignored if no column matches.
             */
            additionalProperties: true;
            /**
             * Array of required properties.
             */
            required?: string[];
            type: "object";
        };
        /**
         * Optional tags to help organize your tables. These should be passed here as an object representing key/value pairs.
         */
        tags?: {
            [k: string]: string;
        };
        /**
         * Indicates if the table is enabled for computation.
         */
        isComputeEnabled?: boolean;
        /**
         * Timestamp of table creation.
         */
        createdAt?: string;
        /**
         * Timestamp of the last table update.
         */
        updatedAt?: string;
    };
    /**
     * The total number of rows present in the table.
     */
    rows: number;
    /**
     * The number of stale rows that are waiting to be processed
     */
    stale: number;
    /**
     * The number of rows that are waiting to be indexed (for search)
     */
    indexing: number;
}

interface GetOrCreateTableRequestHeaders {
}
interface GetOrCreateTableRequestQuery {
}
interface GetOrCreateTableRequestParams {
    table: string;
}
interface GetOrCreateTableRequestBody {
    /**
     * The 'factor' multiplies the row's data storage limit by 4KB and its quota count, but can only be set at table creation and not modified later. For instance, a factor of 2 increases storage to 8KB but counts as 2 rows in your quota. The default factor is 1.
     */
    factor?: number;
    /**
     * A table designated as "frozen" is immutable in terms of its name and schema structure; modifications to its schema or a renaming operation are not permitted. The only action that can be taken on such a table is deletion. The schema established at the time of creation is locked in as the final structure. To implement any changes, the table must be duplicated with the desired alterations.
     */
    frozen?: boolean;
    /**
     * Provide an object or a JSON schema to define the columns of the table. A maximum of 20 keys in the object/schema is allowed.
     */
    schema: {
        [k: string]: any;
    };
    /**
     * Optional tags to help organize your tables. These should be passed here as an object representing key/value pairs.
     */
    tags?: {
        [k: string]: string;
    };
    /**
     * Indicates if the table is enabled for computation.
     */
    isComputeEnabled?: boolean;
}
type GetOrCreateTableInput = GetOrCreateTableRequestBody & GetOrCreateTableRequestHeaders & GetOrCreateTableRequestQuery & GetOrCreateTableRequestParams;
interface GetOrCreateTableResponse {
    table: {
        /**
         * Unique identifier for the table
         */
        id: string;
        /**
         * Required. This name is used to identify your table.
         */
        name: string;
        /**
         * The 'factor' multiplies the row's data storage limit by 4KB and its quota count, but can only be set at table creation and not modified later. For instance, a factor of 2 increases storage to 8KB but counts as 2 rows in your quota. The default factor is 1.
         */
        factor?: number;
        /**
         * A table designated as "frozen" is immutable in terms of its name and schema structure; modifications to its schema or a renaming operation are not permitted. The only action that can be taken on such a table is deletion. The schema established at the time of creation is locked in as the final structure. To implement any changes, the table must be duplicated with the desired alterations.
         */
        frozen?: boolean;
        schema: {
            $schema: string;
            /**
             * List of keys/columns in the table.
             */
            properties: {
                [k: string]: {
                    type: "string" | "number" | "boolean" | "object" | "array" | "null";
                    format?: "date-time";
                    description?: string;
                    /**
                     * String properties must match this pattern
                     */
                    pattern?: string;
                    /**
                     * String properties must be one of these values
                     */
                    enum?: string[];
                    /**
                     * Defines the shape of items in an array
                     */
                    items?: {
                        type: "string" | "number" | "boolean" | "object" | "array" | "null";
                        [k: string]: any;
                    };
                    nullable?: boolean;
                    properties?: {
                        [k: string]: {
                            type: "string" | "number" | "boolean" | "object" | "array" | "null";
                            [k: string]: any;
                        };
                    };
                    "x-zui": {
                        index: number;
                        /**
                         * [deprecated] ID of the column.
                         */
                        id?: string;
                        /**
                         * Indicates if the column is vectorized and searchable.
                         */
                        searchable?: boolean;
                        /**
                         * Indicates if the field is hidden in the UI
                         */
                        hidden?: boolean;
                        /**
                         * Order of the column in the UI
                         */
                        order?: number;
                        /**
                         * Width of the column in the UI
                         */
                        width?: number;
                        /**
                         * ID of the schema
                         */
                        schemaId?: string;
                        computed?: {
                            action: "ai" | "code" | "workflow";
                            dependencies?: string[];
                            /**
                             * Prompt when action is "ai"
                             */
                            prompt?: string;
                            /**
                             * Code to execute when action is "code"
                             */
                            code?: string;
                            /**
                             * Model to use when action is "ai"
                             */
                            model?: string;
                            /**
                             * ID of Workflow to execute when action is "workflow"
                             */
                            workflowId?: string;
                            enabled?: boolean;
                        };
                        /**
                         * TypeScript typings for the column. Recommended if the type is "object", ex: "\{ foo: string; bar: number \}"
                         */
                        typings?: string;
                    };
                };
            };
            /**
             * Additional properties can be provided, but they will be ignored if no column matches.
             */
            additionalProperties: true;
            /**
             * Array of required properties.
             */
            required?: string[];
            type: "object";
        };
        /**
         * Optional tags to help organize your tables. These should be passed here as an object representing key/value pairs.
         */
        tags?: {
            [k: string]: string;
        };
        /**
         * Indicates if the table is enabled for computation.
         */
        isComputeEnabled?: boolean;
        /**
         * Timestamp of table creation.
         */
        createdAt?: string;
        /**
         * Timestamp of the last table update.
         */
        updatedAt?: string;
    };
    /**
     * Flag indicating if the table was newly created.
     */
    created: boolean;
    /**
     * The total number of rows present in the table.
     */
    rows: number;
    /**
     * The number of stale rows that are waiting to be processed
     */
    stale: number;
    /**
     * The number of rows that are waiting to be indexed (for search)
     */
    indexing: number;
}

interface CreateTableRequestHeaders {
}
interface CreateTableRequestQuery {
}
interface CreateTableRequestParams {
}
interface CreateTableRequestBody {
    /**
     * Required. This name is used to identify your table.
     */
    name: string;
    /**
     * The 'factor' multiplies the row's data storage limit by 4KB and its quota count, but can only be set at table creation and not modified later. For instance, a factor of 2 increases storage to 8KB but counts as 2 rows in your quota. The default factor is 1.
     */
    factor?: number;
    /**
     * A table designated as "frozen" is immutable in terms of its name and schema structure; modifications to its schema or a renaming operation are not permitted. The only action that can be taken on such a table is deletion. The schema established at the time of creation is locked in as the final structure. To implement any changes, the table must be duplicated with the desired alterations.
     */
    frozen?: boolean;
    /**
     * Provide an object or a JSON schema to define the columns of the table. A maximum of 20 keys in the object/schema is allowed.
     */
    schema: {
        [k: string]: any;
    };
    /**
     * Optional tags to help organize your tables. These should be passed here as an object representing key/value pairs.
     */
    tags?: {
        [k: string]: string;
    };
    /**
     * Indicates if the table is enabled for computation.
     */
    isComputeEnabled?: boolean;
}
type CreateTableInput = CreateTableRequestBody & CreateTableRequestHeaders & CreateTableRequestQuery & CreateTableRequestParams;
interface CreateTableResponse {
    table: {
        /**
         * Unique identifier for the table
         */
        id: string;
        /**
         * Required. This name is used to identify your table.
         */
        name: string;
        /**
         * The 'factor' multiplies the row's data storage limit by 4KB and its quota count, but can only be set at table creation and not modified later. For instance, a factor of 2 increases storage to 8KB but counts as 2 rows in your quota. The default factor is 1.
         */
        factor?: number;
        /**
         * A table designated as "frozen" is immutable in terms of its name and schema structure; modifications to its schema or a renaming operation are not permitted. The only action that can be taken on such a table is deletion. The schema established at the time of creation is locked in as the final structure. To implement any changes, the table must be duplicated with the desired alterations.
         */
        frozen?: boolean;
        schema: {
            $schema: string;
            /**
             * List of keys/columns in the table.
             */
            properties: {
                [k: string]: {
                    type: "string" | "number" | "boolean" | "object" | "array" | "null";
                    format?: "date-time";
                    description?: string;
                    /**
                     * String properties must match this pattern
                     */
                    pattern?: string;
                    /**
                     * String properties must be one of these values
                     */
                    enum?: string[];
                    /**
                     * Defines the shape of items in an array
                     */
                    items?: {
                        type: "string" | "number" | "boolean" | "object" | "array" | "null";
                        [k: string]: any;
                    };
                    nullable?: boolean;
                    properties?: {
                        [k: string]: {
                            type: "string" | "number" | "boolean" | "object" | "array" | "null";
                            [k: string]: any;
                        };
                    };
                    "x-zui": {
                        index: number;
                        /**
                         * [deprecated] ID of the column.
                         */
                        id?: string;
                        /**
                         * Indicates if the column is vectorized and searchable.
                         */
                        searchable?: boolean;
                        /**
                         * Indicates if the field is hidden in the UI
                         */
                        hidden?: boolean;
                        /**
                         * Order of the column in the UI
                         */
                        order?: number;
                        /**
                         * Width of the column in the UI
                         */
                        width?: number;
                        /**
                         * ID of the schema
                         */
                        schemaId?: string;
                        computed?: {
                            action: "ai" | "code" | "workflow";
                            dependencies?: string[];
                            /**
                             * Prompt when action is "ai"
                             */
                            prompt?: string;
                            /**
                             * Code to execute when action is "code"
                             */
                            code?: string;
                            /**
                             * Model to use when action is "ai"
                             */
                            model?: string;
                            /**
                             * ID of Workflow to execute when action is "workflow"
                             */
                            workflowId?: string;
                            enabled?: boolean;
                        };
                        /**
                         * TypeScript typings for the column. Recommended if the type is "object", ex: "\{ foo: string; bar: number \}"
                         */
                        typings?: string;
                    };
                };
            };
            /**
             * Additional properties can be provided, but they will be ignored if no column matches.
             */
            additionalProperties: true;
            /**
             * Array of required properties.
             */
            required?: string[];
            type: "object";
        };
        /**
         * Optional tags to help organize your tables. These should be passed here as an object representing key/value pairs.
         */
        tags?: {
            [k: string]: string;
        };
        /**
         * Indicates if the table is enabled for computation.
         */
        isComputeEnabled?: boolean;
        /**
         * Timestamp of table creation.
         */
        createdAt?: string;
        /**
         * Timestamp of the last table update.
         */
        updatedAt?: string;
    };
}

interface DuplicateTableRequestHeaders {
}
interface DuplicateTableRequestQuery {
}
interface DuplicateTableRequestParams {
    sourceTableId: string;
}
interface DuplicateTableRequestBody {
    tableName?: string;
    /**
     * Only duplicate the schema, not the content
     */
    schemaOnly?: boolean;
    /**
     * Use a different factor for the table. Leave empty to use the same as the duplicated table.
     */
    factor?: number;
}
type DuplicateTableInput = DuplicateTableRequestBody & DuplicateTableRequestHeaders & DuplicateTableRequestQuery & DuplicateTableRequestParams;
interface DuplicateTableResponse {
    table: {
        /**
         * Unique identifier for the table
         */
        id: string;
        /**
         * Required. This name is used to identify your table.
         */
        name: string;
        /**
         * The 'factor' multiplies the row's data storage limit by 4KB and its quota count, but can only be set at table creation and not modified later. For instance, a factor of 2 increases storage to 8KB but counts as 2 rows in your quota. The default factor is 1.
         */
        factor?: number;
        /**
         * A table designated as "frozen" is immutable in terms of its name and schema structure; modifications to its schema or a renaming operation are not permitted. The only action that can be taken on such a table is deletion. The schema established at the time of creation is locked in as the final structure. To implement any changes, the table must be duplicated with the desired alterations.
         */
        frozen?: boolean;
        schema: {
            $schema: string;
            /**
             * List of keys/columns in the table.
             */
            properties: {
                [k: string]: {
                    type: "string" | "number" | "boolean" | "object" | "array" | "null";
                    format?: "date-time";
                    description?: string;
                    /**
                     * String properties must match this pattern
                     */
                    pattern?: string;
                    /**
                     * String properties must be one of these values
                     */
                    enum?: string[];
                    /**
                     * Defines the shape of items in an array
                     */
                    items?: {
                        type: "string" | "number" | "boolean" | "object" | "array" | "null";
                        [k: string]: any;
                    };
                    nullable?: boolean;
                    properties?: {
                        [k: string]: {
                            type: "string" | "number" | "boolean" | "object" | "array" | "null";
                            [k: string]: any;
                        };
                    };
                    "x-zui": {
                        index: number;
                        /**
                         * [deprecated] ID of the column.
                         */
                        id?: string;
                        /**
                         * Indicates if the column is vectorized and searchable.
                         */
                        searchable?: boolean;
                        /**
                         * Indicates if the field is hidden in the UI
                         */
                        hidden?: boolean;
                        /**
                         * Order of the column in the UI
                         */
                        order?: number;
                        /**
                         * Width of the column in the UI
                         */
                        width?: number;
                        /**
                         * ID of the schema
                         */
                        schemaId?: string;
                        computed?: {
                            action: "ai" | "code" | "workflow";
                            dependencies?: string[];
                            /**
                             * Prompt when action is "ai"
                             */
                            prompt?: string;
                            /**
                             * Code to execute when action is "code"
                             */
                            code?: string;
                            /**
                             * Model to use when action is "ai"
                             */
                            model?: string;
                            /**
                             * ID of Workflow to execute when action is "workflow"
                             */
                            workflowId?: string;
                            enabled?: boolean;
                        };
                        /**
                         * TypeScript typings for the column. Recommended if the type is "object", ex: "\{ foo: string; bar: number \}"
                         */
                        typings?: string;
                    };
                };
            };
            /**
             * Additional properties can be provided, but they will be ignored if no column matches.
             */
            additionalProperties: true;
            /**
             * Array of required properties.
             */
            required?: string[];
            type: "object";
        };
        /**
         * Optional tags to help organize your tables. These should be passed here as an object representing key/value pairs.
         */
        tags?: {
            [k: string]: string;
        };
        /**
         * Indicates if the table is enabled for computation.
         */
        isComputeEnabled?: boolean;
        /**
         * Timestamp of table creation.
         */
        createdAt?: string;
        /**
         * Timestamp of the last table update.
         */
        updatedAt?: string;
    };
    /**
     * The total number of rows present in the table.
     */
    rows: number;
}

interface UpdateTableRequestHeaders {
}
interface UpdateTableRequestQuery {
}
interface UpdateTableRequestParams {
    table: string;
}
interface UpdateTableRequestBody {
    /**
     * Required. This name is used to identify your table.
     */
    name?: string;
    /**
     * A table designated as "frozen" is immutable in terms of its name and schema structure; modifications to its schema or a renaming operation are not permitted. The only action that can be taken on such a table is deletion. The schema established at the time of creation is locked in as the final structure. To implement any changes, the table must be duplicated with the desired alterations.
     */
    frozen?: boolean;
    /**
     * Provide an object or a JSON schema to define the columns of the table. A maximum of 20 keys in the object/schema is allowed.
     */
    schema?: {
        [k: string]: any;
    };
    /**
     * Optional tags to help organize your tables. These should be passed here as an object representing key/value pairs.
     */
    tags?: {
        [k: string]: string;
    };
    /**
     * Indicates if the table is enabled for computation.
     */
    isComputeEnabled?: boolean;
}
type UpdateTableInput = UpdateTableRequestBody & UpdateTableRequestHeaders & UpdateTableRequestQuery & UpdateTableRequestParams;
interface UpdateTableResponse {
    table: {
        /**
         * Unique identifier for the table
         */
        id: string;
        /**
         * Required. This name is used to identify your table.
         */
        name: string;
        /**
         * The 'factor' multiplies the row's data storage limit by 4KB and its quota count, but can only be set at table creation and not modified later. For instance, a factor of 2 increases storage to 8KB but counts as 2 rows in your quota. The default factor is 1.
         */
        factor?: number;
        /**
         * A table designated as "frozen" is immutable in terms of its name and schema structure; modifications to its schema or a renaming operation are not permitted. The only action that can be taken on such a table is deletion. The schema established at the time of creation is locked in as the final structure. To implement any changes, the table must be duplicated with the desired alterations.
         */
        frozen?: boolean;
        schema: {
            $schema: string;
            /**
             * List of keys/columns in the table.
             */
            properties: {
                [k: string]: {
                    type: "string" | "number" | "boolean" | "object" | "array" | "null";
                    format?: "date-time";
                    description?: string;
                    /**
                     * String properties must match this pattern
                     */
                    pattern?: string;
                    /**
                     * String properties must be one of these values
                     */
                    enum?: string[];
                    /**
                     * Defines the shape of items in an array
                     */
                    items?: {
                        type: "string" | "number" | "boolean" | "object" | "array" | "null";
                        [k: string]: any;
                    };
                    nullable?: boolean;
                    properties?: {
                        [k: string]: {
                            type: "string" | "number" | "boolean" | "object" | "array" | "null";
                            [k: string]: any;
                        };
                    };
                    "x-zui": {
                        index: number;
                        /**
                         * [deprecated] ID of the column.
                         */
                        id?: string;
                        /**
                         * Indicates if the column is vectorized and searchable.
                         */
                        searchable?: boolean;
                        /**
                         * Indicates if the field is hidden in the UI
                         */
                        hidden?: boolean;
                        /**
                         * Order of the column in the UI
                         */
                        order?: number;
                        /**
                         * Width of the column in the UI
                         */
                        width?: number;
                        /**
                         * ID of the schema
                         */
                        schemaId?: string;
                        computed?: {
                            action: "ai" | "code" | "workflow";
                            dependencies?: string[];
                            /**
                             * Prompt when action is "ai"
                             */
                            prompt?: string;
                            /**
                             * Code to execute when action is "code"
                             */
                            code?: string;
                            /**
                             * Model to use when action is "ai"
                             */
                            model?: string;
                            /**
                             * ID of Workflow to execute when action is "workflow"
                             */
                            workflowId?: string;
                            enabled?: boolean;
                        };
                        /**
                         * TypeScript typings for the column. Recommended if the type is "object", ex: "\{ foo: string; bar: number \}"
                         */
                        typings?: string;
                    };
                };
            };
            /**
             * Additional properties can be provided, but they will be ignored if no column matches.
             */
            additionalProperties: true;
            /**
             * Array of required properties.
             */
            required?: string[];
            type: "object";
        };
        /**
         * Optional tags to help organize your tables. These should be passed here as an object representing key/value pairs.
         */
        tags?: {
            [k: string]: string;
        };
        /**
         * Indicates if the table is enabled for computation.
         */
        isComputeEnabled?: boolean;
        /**
         * Timestamp of table creation.
         */
        createdAt?: string;
        /**
         * Timestamp of the last table update.
         */
        updatedAt?: string;
    };
    /**
     * List of columns that have become stale following the modification.
     */
    staleColumns?: string[];
}

interface RenameTableColumnRequestHeaders {
}
interface RenameTableColumnRequestQuery {
}
interface RenameTableColumnRequestParams {
    table: string;
}
interface RenameTableColumnRequestBody {
    /**
     * The existing name of the column.
     */
    name: string;
    /**
     * The new name to assign to the column.
     */
    newName: string;
}
type RenameTableColumnInput = RenameTableColumnRequestBody & RenameTableColumnRequestHeaders & RenameTableColumnRequestQuery & RenameTableColumnRequestParams;
interface RenameTableColumnResponse {
    table: {
        /**
         * Unique identifier for the table
         */
        id: string;
        /**
         * Required. This name is used to identify your table.
         */
        name: string;
        /**
         * The 'factor' multiplies the row's data storage limit by 4KB and its quota count, but can only be set at table creation and not modified later. For instance, a factor of 2 increases storage to 8KB but counts as 2 rows in your quota. The default factor is 1.
         */
        factor?: number;
        /**
         * A table designated as "frozen" is immutable in terms of its name and schema structure; modifications to its schema or a renaming operation are not permitted. The only action that can be taken on such a table is deletion. The schema established at the time of creation is locked in as the final structure. To implement any changes, the table must be duplicated with the desired alterations.
         */
        frozen?: boolean;
        schema: {
            $schema: string;
            /**
             * List of keys/columns in the table.
             */
            properties: {
                [k: string]: {
                    type: "string" | "number" | "boolean" | "object" | "array" | "null";
                    format?: "date-time";
                    description?: string;
                    /**
                     * String properties must match this pattern
                     */
                    pattern?: string;
                    /**
                     * String properties must be one of these values
                     */
                    enum?: string[];
                    /**
                     * Defines the shape of items in an array
                     */
                    items?: {
                        type: "string" | "number" | "boolean" | "object" | "array" | "null";
                        [k: string]: any;
                    };
                    nullable?: boolean;
                    properties?: {
                        [k: string]: {
                            type: "string" | "number" | "boolean" | "object" | "array" | "null";
                            [k: string]: any;
                        };
                    };
                    "x-zui": {
                        index: number;
                        /**
                         * [deprecated] ID of the column.
                         */
                        id?: string;
                        /**
                         * Indicates if the column is vectorized and searchable.
                         */
                        searchable?: boolean;
                        /**
                         * Indicates if the field is hidden in the UI
                         */
                        hidden?: boolean;
                        /**
                         * Order of the column in the UI
                         */
                        order?: number;
                        /**
                         * Width of the column in the UI
                         */
                        width?: number;
                        /**
                         * ID of the schema
                         */
                        schemaId?: string;
                        computed?: {
                            action: "ai" | "code" | "workflow";
                            dependencies?: string[];
                            /**
                             * Prompt when action is "ai"
                             */
                            prompt?: string;
                            /**
                             * Code to execute when action is "code"
                             */
                            code?: string;
                            /**
                             * Model to use when action is "ai"
                             */
                            model?: string;
                            /**
                             * ID of Workflow to execute when action is "workflow"
                             */
                            workflowId?: string;
                            enabled?: boolean;
                        };
                        /**
                         * TypeScript typings for the column. Recommended if the type is "object", ex: "\{ foo: string; bar: number \}"
                         */
                        typings?: string;
                    };
                };
            };
            /**
             * Additional properties can be provided, but they will be ignored if no column matches.
             */
            additionalProperties: true;
            /**
             * Array of required properties.
             */
            required?: string[];
            type: "object";
        };
        /**
         * Optional tags to help organize your tables. These should be passed here as an object representing key/value pairs.
         */
        tags?: {
            [k: string]: string;
        };
        /**
         * Indicates if the table is enabled for computation.
         */
        isComputeEnabled?: boolean;
        /**
         * Timestamp of table creation.
         */
        createdAt?: string;
        /**
         * Timestamp of the last table update.
         */
        updatedAt?: string;
    };
}

interface DeleteTableRequestHeaders {
}
interface DeleteTableRequestQuery {
}
interface DeleteTableRequestParams {
    table: string;
}
interface DeleteTableRequestBody {
}
type DeleteTableInput = DeleteTableRequestBody & DeleteTableRequestHeaders & DeleteTableRequestQuery & DeleteTableRequestParams;
interface DeleteTableResponse {
}

interface GetTableRowRequestHeaders {
}
interface GetTableRowRequestQuery {
    id: number;
}
interface GetTableRowRequestParams {
    table: string;
}
interface GetTableRowRequestBody {
}
type GetTableRowInput = GetTableRowRequestBody & GetTableRowRequestHeaders & GetTableRowRequestQuery & GetTableRowRequestParams;
interface GetTableRowResponse {
    row: {
        /**
         * Unique identifier for the row.
         */
        id: number;
        /**
         * Timestamp of row creation.
         */
        createdAt?: string;
        /**
         * Timestamp of the last row update.
         */
        updatedAt?: string;
        computed: {
            [k: string]: {
                status: string;
                error?: string;
                updatedBy?: string;
                updatedAt?: string;
            };
        };
        /**
         * [Read-only] List of stale values that are waiting to be recomputed.
         */
        stale?: string[];
        /**
         * Optional numeric value indicating similarity, when using findTableRows.
         */
        similarity?: number;
        [k: string]: any;
    };
}

interface FindTableRowsRequestHeaders {
}
interface FindTableRowsRequestQuery {
}
interface FindTableRowsRequestParams {
    table: string;
}
interface FindTableRowsRequestBody {
    /**
     * Limit for pagination, specifying the maximum number of rows to return.
     */
    limit?: number;
    /**
     * Offset for pagination, specifying where to start returning rows from.
     */
    offset?: number;
    /**
     * Provide a mongodb-like filter to apply to the query. Example: \{ "name": \{ "$eq": "John" \} \}
     */
    filter?: {
        [k: string]: any;
    };
    /**
     * Group the rows by a specific column and apply aggregations to them. Allowed values: key, avg, max, min, sum, count. Example: \{ "someId": "key", "orders": ["sum", "avg"] \}
     */
    group?: {
        [k: string]: any;
    };
    /**
     * Search term to apply to the row search. When using this parameter, some rows which doesn't match the search term will be returned, use the similarity field to know how much the row matches the search term.
     */
    search?: string;
    /**
     * Specifies the column by which to order the results. By default it is ordered by id. Build-in columns: id, createdAt, updatedAt
     */
    orderBy?: string;
    /**
     * Specifies the direction of sorting, either ascending or descending.
     */
    orderDirection?: "asc" | "desc";
}
type FindTableRowsInput = FindTableRowsRequestBody & FindTableRowsRequestHeaders & FindTableRowsRequestQuery & FindTableRowsRequestParams;
interface FindTableRowsResponse {
    rows: {
        /**
         * Unique identifier for the row.
         */
        id: number;
        /**
         * Timestamp of row creation.
         */
        createdAt?: string;
        /**
         * Timestamp of the last row update.
         */
        updatedAt?: string;
        computed: {
            [k: string]: {
                status: string;
                error?: string;
                updatedBy?: string;
                updatedAt?: string;
            };
        };
        /**
         * [Read-only] List of stale values that are waiting to be recomputed.
         */
        stale?: string[];
        /**
         * Optional numeric value indicating similarity, when using findTableRows.
         */
        similarity?: number;
        [k: string]: any;
    }[];
    /**
     * Flag indicating if there are more rows to fetch.
     */
    hasMore: boolean;
    offset: number;
    limit: number;
    /**
     * Alerts for minor issues that don't block the operation but suggest possible improvements.
     */
    warnings?: string[];
}

interface CreateTableRowsRequestHeaders {
}
interface CreateTableRowsRequestQuery {
}
interface CreateTableRowsRequestParams {
    table: string;
}
interface CreateTableRowsRequestBody {
    /**
     * @minItems 1
     * @maxItems 1000
     */
    rows: {
        [k: string]: any;
    }[];
    /**
     * Ensure computed columns are fully processed before returning the result. This is applicable only when the number of rows involved is fewer than 1.
     */
    waitComputed?: boolean;
}
type CreateTableRowsInput = CreateTableRowsRequestBody & CreateTableRowsRequestHeaders & CreateTableRowsRequestQuery & CreateTableRowsRequestParams;
interface CreateTableRowsResponse {
    rows: {
        /**
         * Unique identifier for the row.
         */
        id: number;
        /**
         * Timestamp of row creation.
         */
        createdAt?: string;
        /**
         * Timestamp of the last row update.
         */
        updatedAt?: string;
        computed: {
            [k: string]: {
                status: string;
                error?: string;
                updatedBy?: string;
                updatedAt?: string;
            };
        };
        /**
         * [Read-only] List of stale values that are waiting to be recomputed.
         */
        stale?: string[];
        /**
         * Optional numeric value indicating similarity, when using findTableRows.
         */
        similarity?: number;
        [k: string]: any;
    }[];
    /**
     * Alerts for minor issues that don't block the operation but suggest possible improvements.
     */
    warnings?: string[];
    /**
     * Critical issues in specific elements that prevent their successful processing, allowing partial operation success.
     */
    errors?: string[];
}

interface DeleteTableRowsRequestHeaders {
}
interface DeleteTableRowsRequestQuery {
}
interface DeleteTableRowsRequestParams {
    table: string;
}
interface DeleteTableRowsRequestBody {
    /**
     * @maxItems 1000
     */
    ids?: number[];
    /**
     * Filter to apply when deleting rows. Example: \{ "name": \{ "$eq": "John" \} \}
     */
    filter?: {
        [k: string]: any;
    };
    /**
     * Flag to delete all rows. Use with caution as this action is irreversible.
     */
    deleteAllRows?: boolean;
}
type DeleteTableRowsInput = DeleteTableRowsRequestBody & DeleteTableRowsRequestHeaders & DeleteTableRowsRequestQuery & DeleteTableRowsRequestParams;
interface DeleteTableRowsResponse {
    deletedRows: number;
}

interface UpdateTableRowsRequestHeaders {
}
interface UpdateTableRowsRequestQuery {
}
interface UpdateTableRowsRequestParams {
    table: string;
}
interface UpdateTableRowsRequestBody {
    /**
     * Rows with updated data, identified by ID.
     *
     * @minItems 1
     * @maxItems 1000
     */
    rows: {
        id: number;
        [k: string]: any;
    }[];
    /**
     * Ensure computed columns are fully processed before returning the result. This is applicable only when the number of rows involved is fewer than 1.
     */
    waitComputed?: boolean;
}
type UpdateTableRowsInput = UpdateTableRowsRequestBody & UpdateTableRowsRequestHeaders & UpdateTableRowsRequestQuery & UpdateTableRowsRequestParams;
interface UpdateTableRowsResponse {
    rows: {
        /**
         * Unique identifier for the row.
         */
        id: number;
        /**
         * Timestamp of row creation.
         */
        createdAt?: string;
        /**
         * Timestamp of the last row update.
         */
        updatedAt?: string;
        computed: {
            [k: string]: {
                status: string;
                error?: string;
                updatedBy?: string;
                updatedAt?: string;
            };
        };
        /**
         * [Read-only] List of stale values that are waiting to be recomputed.
         */
        stale?: string[];
        /**
         * Optional numeric value indicating similarity, when using findTableRows.
         */
        similarity?: number;
        [k: string]: any;
    }[];
    /**
     * Alerts for minor issues that don't block the operation but suggest possible improvements.
     */
    warnings?: string[];
    /**
     * Critical issues in specific elements that prevent their successful processing, allowing partial operation success.
     */
    errors?: string[];
}

interface UpsertTableRowsRequestHeaders {
}
interface UpsertTableRowsRequestQuery {
}
interface UpsertTableRowsRequestParams {
    table: string;
}
interface UpsertTableRowsRequestBody {
    /**
     * @minItems 1
     * @maxItems 1000
     */
    rows: {
        id?: number;
        [k: string]: any;
    }[];
    /**
     * Determines if a row is inserted or updated. Defaults to "id".
     */
    keyColumn?: string;
    /**
     * Ensure computed columns are fully processed before returning the result. This is applicable only when the number of rows involved is fewer than 1.
     */
    waitComputed?: boolean;
}
type UpsertTableRowsInput = UpsertTableRowsRequestBody & UpsertTableRowsRequestHeaders & UpsertTableRowsRequestQuery & UpsertTableRowsRequestParams;
interface UpsertTableRowsResponse {
    inserted: {
        /**
         * Unique identifier for the row.
         */
        id: number;
        /**
         * Timestamp of row creation.
         */
        createdAt?: string;
        /**
         * Timestamp of the last row update.
         */
        updatedAt?: string;
        computed: {
            [k: string]: {
                status: string;
                error?: string;
                updatedBy?: string;
                updatedAt?: string;
            };
        };
        /**
         * [Read-only] List of stale values that are waiting to be recomputed.
         */
        stale?: string[];
        /**
         * Optional numeric value indicating similarity, when using findTableRows.
         */
        similarity?: number;
        [k: string]: any;
    }[];
    updated: {
        /**
         * Unique identifier for the row.
         */
        id: number;
        /**
         * Timestamp of row creation.
         */
        createdAt?: string;
        /**
         * Timestamp of the last row update.
         */
        updatedAt?: string;
        computed: {
            [k: string]: {
                status: string;
                error?: string;
                updatedBy?: string;
                updatedAt?: string;
            };
        };
        /**
         * [Read-only] List of stale values that are waiting to be recomputed.
         */
        stale?: string[];
        /**
         * Optional numeric value indicating similarity, when using findTableRows.
         */
        similarity?: number;
        [k: string]: any;
    }[];
    /**
     * Alerts for minor issues that don't block the operation but suggest possible improvements.
     */
    warnings?: string[];
    /**
     * Critical issues in specific elements that prevent their successful processing, allowing partial operation success.
     */
    errors?: string[];
}

interface Bot {
    /**
     * Id of the [Bot](#schema_bot)
     */
    id: string;
    /**
     * Creation date of the [Bot](#schema_bot) in ISO 8601 format
     */
    createdAt: string;
    /**
     * Updating date of the [Bot](#schema_bot) in ISO 8601 format
     */
    updatedAt: string;
    /**
     * Signing secret of the [Bot](#schema_bot)
     */
    signingSecret: string;
    /**
     * A mapping of integrations to their configuration
     */
    integrations: {
        [k: string]: {
            enabled: boolean;
            /**
             * Name of the [Integration](#schema_integration)
             */
            name: string;
            /**
             * Version of the [Integration](#schema_integration)
             */
            version: string;
            webhookUrl: string;
            webhookId: string;
            identifier?: string;
            configurationType: string | null;
            configuration: {
                [k: string]: any;
            };
            status: "registration_pending" | "registered" | "registration_failed" | "unregistration_pending" | "unregistered" | "unregistration_failed";
            statusReason: string | null;
            /**
             * ID of the [Integration](#schema_integration)
             */
            id: string;
            /**
             * Creation date of the [Integration](#schema_integration) in ISO 8601 format
             */
            createdAt: string;
            /**
             * Updating date of the [Integration](#schema_integration) in ISO 8601 format
             */
            updatedAt: string;
            /**
             * Title of the integration. This is the name that will be displayed in the UI
             */
            title: string;
            /**
             * Description of the integration. This is the description that will be displayed in the UI
             */
            description: string;
            /**
             * URL of the icon of the integration. This is the icon that will be displayed in the UI
             */
            iconUrl: string;
            /**
             * Idicates if the integration is public. Public integrations are available to all and cannot be updated without creating a new version.
             */
            public: boolean;
            /**
             * Status of the integration version verification
             */
            verificationStatus: "unapproved" | "pending" | "approved" | "rejected";
        };
    };
    /**
     * User object configuration
     */
    user: {
        tags: {
            /**
             * Definition of a tag that can be provided on the object
             */
            [k: string]: {
                /**
                 * Title of the tag
                 */
                title?: string;
                /**
                 * Description of the tag
                 */
                description?: string;
            };
        };
    };
    /**
     * Conversation object configuration
     */
    conversation: {
        tags: {
            /**
             * Definition of a tag that can be provided on the object
             */
            [k: string]: {
                /**
                 * Title of the tag
                 */
                title?: string;
                /**
                 * Description of the tag
                 */
                description?: string;
            };
        };
    };
    /**
     * Message object configuration
     */
    message: {
        tags: {
            /**
             * Definition of a tag that can be provided on the object
             */
            [k: string]: {
                /**
                 * Title of the tag
                 */
                title?: string;
                /**
                 * Description of the tag
                 */
                description?: string;
            };
        };
    };
    /**
     * A mapping of states to their definition
     */
    states: {
        [k: string]: {
            /**
             * Type of the [State](#schema_state) (`conversation`, `user`, `bot` or `task`)
             */
            type: "conversation" | "user" | "bot" | "task";
            /**
             * Schema of the [State](#schema_state) in the `JSON schema` format. This `JSON schema` is going to be used for validating the state data.
             */
            schema: {
                [k: string]: any;
            };
            /**
             * Expiry of the [State](#schema_state) in milliseconds. The state will expire if it is idle for the configured value. By default, a state doesn't expire.
             */
            expiry?: number;
        };
    };
    /**
     * Configuration of the bot
     */
    configuration: {
        /**
         * Configuration data
         */
        data: {
            [k: string]: any;
        };
        /**
         * Schema of the configuration in the `JSON schema` format. The configuration data is validated against this `JSON schema`.
         */
        schema: {
            [k: string]: any;
        };
    };
    /**
     * Events definition
     */
    events: {
        /**
         * Event Definition
         */
        [k: string]: {
            /**
             * Title of the event
             */
            title?: string;
            /**
             * Description of the event
             */
            description?: string;
            schema: {
                [k: string]: any;
            };
        };
    };
    /**
     * Recurring events
     */
    recurringEvents: {
        [k: string]: {
            schedule: {
                cron: string;
            };
            type: string;
            payload: {
                [k: string]: any;
            };
            /**
             * The number of times the recurring event failed to run. This counter resets once the recurring event runs successfully.
             */
            failedAttempts: number;
            /**
             * The reason why the recurring event failed to run in the last attempt.
             */
            lastFailureReason: string | null;
        };
    };
    /**
     * Subscriptions of the bot
     */
    subscriptions: {
        /**
         * Events that the bot is currently subscribed on (ex: "slack:reactionAdded"). If null, the bot is subscribed to all events.
         */
        events: {
            [k: string]: {};
        } | null;
    };
    /**
     * Actions definition
     */
    actions: {
        /**
         * Action definition
         */
        [k: string]: {
            /**
             * Title of the action
             */
            title?: string;
            /**
             * Description of the action
             */
            description?: string;
            billable?: boolean;
            cacheable?: boolean;
            input: {
                schema: {
                    [k: string]: any;
                };
            };
            output: {
                schema: {
                    [k: string]: any;
                };
            };
        };
    };
    /**
     * Name of the [Bot](#schema_bot)
     */
    name: string;
    /**
     * Last deployment date of the [Bot](#schema_bot) in the ISO 8601 format
     */
    deployedAt?: string;
    /**
     * Indicates if the [Bot](#schema_bot) is a development bot; Development bots run locally and can install dev integrations
     */
    dev: boolean;
    /**
     * Id of the user that created the bot
     */
    createdBy?: string;
    /**
     * Indicates if the [Bot](#schema_bot) should be in always alive mode
     */
    alwaysAlive: boolean;
    /**
     * Status of the bot
     */
    status: "active" | "deploying";
    /**
     * Media files associated with the [Bot](#schema_bot)
     */
    medias: {
        /**
         * URL of the media file
         */
        url: string;
        /**
         * Name of the media file
         */
        name: string;
    }[];
}
interface Integration {
    /**
     * ID of the [Integration](#schema_integration)
     */
    id: string;
    /**
     * Creation date of the [Integration](#schema_integration) in ISO 8601 format
     */
    createdAt: string;
    /**
     * Updating date of the [Integration](#schema_integration) in ISO 8601 format
     */
    updatedAt: string;
    /**
     * Global identifier configuration of the [Integration](#schema_integration)
     */
    identifier: {
        /**
         * VRL Script of the [Integration](#schema_integration) to handle incoming requests for a request that doesn't have an identifier
         */
        fallbackHandlerScript?: string;
        /**
         * VRL Script of the [Integration](#schema_integration) to extract the identifier from an incoming webhook often use for OAuth
         */
        extractScript?: string;
    };
    /**
     * URL of the [Integration](#schema_integration)
     */
    url: string;
    /**
     * Name of the [Integration](#schema_integration)
     */
    name: string;
    /**
     * Version of the [Integration](#schema_integration)
     */
    version: string;
    interfaces: {
        [k: string]: {
            id: string;
            /**
             * Name of the interface
             */
            name: string;
            entities: {
                [k: string]: {
                    name: string;
                };
            };
            actions: {
                [k: string]: {
                    name: string;
                };
            };
            events: {
                [k: string]: {
                    name: string;
                };
            };
        };
    };
    /**
     * Configuration definition
     */
    configuration: {
        /**
         * Title of the configuration
         */
        title?: string;
        /**
         * Description of the configuration
         */
        description?: string;
        /**
         * Identifier configuration of the [Integration](#schema_integration)
         */
        identifier: {
            linkTemplateScript?: string;
            required: boolean;
        };
        /**
         * Schema of the configuration in the `JSON schema` format. The configuration data is validated against this `JSON schema`.
         */
        schema?: {
            [k: string]: any;
        };
    };
    configurations: {
        /**
         * Configuration definition
         */
        [k: string]: {
            /**
             * Title of the configuration
             */
            title?: string;
            /**
             * Description of the configuration
             */
            description?: string;
            /**
             * Identifier configuration of the [Integration](#schema_integration)
             */
            identifier: {
                linkTemplateScript?: string;
                required: boolean;
            };
            /**
             * Schema of the configuration in the `JSON schema` format. The configuration data is validated against this `JSON schema`.
             */
            schema?: {
                [k: string]: any;
            };
        };
    };
    channels: {
        /**
         * Channel definition
         */
        [k: string]: {
            /**
             * Title of the channel
             */
            title?: string;
            /**
             * Description of the channel
             */
            description?: string;
            messages: {
                /**
                 * Message definition
                 */
                [k: string]: {
                    schema: {
                        [k: string]: any;
                    };
                };
            };
            /**
             * Conversation object configuration
             */
            conversation: {
                tags: {
                    /**
                     * Definition of a tag that can be provided on the object
                     */
                    [k: string]: {
                        /**
                         * Title of the tag
                         */
                        title?: string;
                        /**
                         * Description of the tag
                         */
                        description?: string;
                    };
                };
                /**
                 * The conversation creation setting determines how to create a conversation through the API directly. The integration will have to implement the `createConversation` functionality to support this setting.
                 */
                creation: {
                    /**
                     * Enable conversation creation
                     */
                    enabled: boolean;
                    /**
                     * The list of tags that are required to be specified when calling the API directly to create a conversation.
                     */
                    requiredTags: string[];
                };
            };
            /**
             * Message object configuration
             */
            message: {
                tags: {
                    /**
                     * Definition of a tag that can be provided on the object
                     */
                    [k: string]: {
                        /**
                         * Title of the tag
                         */
                        title?: string;
                        /**
                         * Description of the tag
                         */
                        description?: string;
                    };
                };
            };
        };
    };
    states: {
        /**
         * State definition
         */
        [k: string]: {
            /**
             * Type of the [State](#schema_state) (`conversation`, `user` or `integration`)
             */
            type: "conversation" | "user" | "integration";
            /**
             * Schema of the [State](#schema_state) in the `JSON schema` format. This `JSON schema` is going to be used for validating the state data.
             */
            schema: {
                [k: string]: any;
            };
        };
    };
    events: {
        /**
         * Event Definition
         */
        [k: string]: {
            /**
             * Title of the event
             */
            title?: string;
            /**
             * Description of the event
             */
            description?: string;
            schema: {
                [k: string]: any;
            };
        };
    };
    actions: {
        /**
         * Action definition
         */
        [k: string]: {
            /**
             * Title of the action
             */
            title?: string;
            /**
             * Description of the action
             */
            description?: string;
            billable?: boolean;
            cacheable?: boolean;
            input: {
                schema: {
                    [k: string]: any;
                };
            };
            output: {
                schema: {
                    [k: string]: any;
                };
            };
        };
    };
    /**
     * User object configuration
     */
    user: {
        tags: {
            /**
             * Definition of a tag that can be provided on the object
             */
            [k: string]: {
                /**
                 * Title of the tag
                 */
                title?: string;
                /**
                 * Description of the tag
                 */
                description?: string;
            };
        };
        /**
         * The user creation setting determines how to create a user through the API directly. The integration will have to implement the `createUser` functionality to support this setting.
         */
        creation: {
            /**
             * Enable user creation
             */
            enabled: boolean;
            /**
             * The list of tags that are required to be specified when calling the API directly to create a user.
             */
            requiredTags: string[];
        };
    };
    entities: {
        /**
         * Entity definition
         */
        [k: string]: {
            /**
             * Title of the entity
             */
            title?: string;
            /**
             * Description of the entity
             */
            description?: string;
            schema: {
                [k: string]: any;
            };
        };
    };
    /**
     * Indicates if the integration is a development integration; Dev integrations run locally
     */
    dev: boolean;
    /**
     * Title of the integration. This is the name that will be displayed in the UI
     */
    title: string;
    /**
     * Description of the integration. This is the description that will be displayed in the UI
     */
    description: string;
    /**
     * URL of the icon of the integration. This is the icon that will be displayed in the UI
     */
    iconUrl: string;
    /**
     * URL of the readme of the integration. This is the readme that will be displayed in the UI
     */
    readmeUrl: string;
    /**
     * Idicates if the integration is public. Public integrations are available to all and cannot be updated without creating a new version.
     */
    public: boolean;
    /**
     * Status of the integration version verification
     */
    verificationStatus: "unapproved" | "pending" | "approved" | "rejected";
    /**
     * Secrets are integration-wide values available in the code via environment variables formatted with a SECRET_ prefix followed by your secret name. A secret name must respect SCREAMING_SNAKE casing.
     */
    secrets: string[];
}
interface Interface {
    /**
     * ID of the [Interface](#schema_interface)
     */
    id: string;
    /**
     * Creation date of the [Interface](#schema_interface) in ISO 8601 format
     */
    createdAt: string;
    /**
     * Updating date of the [Interface](#schema_interface) in ISO 8601 format
     */
    updatedAt: string;
    /**
     * Name of the [Interface](#schema_interface)
     */
    name: string;
    /**
     * Version of the [Interface](#schema_interface)
     */
    version: string;
    events: {
        /**
         * Event Definition
         */
        [k: string]: {
            /**
             * Title of the event
             */
            title?: string;
            /**
             * Description of the event
             */
            description?: string;
            schema: {
                [k: string]: any;
            };
        };
    };
    actions: {
        /**
         * Action definition
         */
        [k: string]: {
            /**
             * Title of the action
             */
            title?: string;
            /**
             * Description of the action
             */
            description?: string;
            billable?: boolean;
            cacheable?: boolean;
            input: {
                schema: {
                    [k: string]: any;
                };
            };
            output: {
                schema: {
                    [k: string]: any;
                };
            };
        };
    };
    entities: {
        /**
         * Entity definition
         */
        [k: string]: {
            /**
             * Title of the entity
             */
            title?: string;
            /**
             * Description of the entity
             */
            description?: string;
            schema: {
                [k: string]: any;
            };
        };
    };
    /**
     * Template string optionaly used at build time by integrations implementing this interface to pick a name for actions and events.
     */
    nameTemplate?: {
        script: string;
        language: string;
    };
}
interface Workspace {
    id: string;
    name: string;
    ownerId: string;
    createdAt: string;
    updatedAt: string;
    botCount: number;
    billingVersion: "v1" | "v2";
    plan: "community" | "team" | "enterprise";
    blocked: boolean;
    spendingLimit: number;
    about?: string;
    profilePicture?: string;
    contactEmail?: string;
    website?: string;
    socialAccounts?: string[];
    isPublic?: boolean;
    handle?: string;
}
interface WorkspaceMember {
    id: string;
    userId?: string;
    email: string;
    createdAt: string;
    role: "viewer" | "billing" | "developer" | "manager" | "administrator" | "owner";
    profilePicture?: string;
    displayName?: string;
}
interface Account {
    id: string;
    email: string;
    displayName?: string;
    emailVerified: boolean;
    profilePicture?: string;
    /**
     * Creation date of the [Account](#schema_account) in ISO 8601 format
     */
    createdAt: string;
}
interface Usage {
    /**
     * Id of the usage that it is linked to. It can either be a workspace id or a bot id
     */
    id: string;
    /**
     * Period of the quota that it is applied to
     */
    period: string;
    /**
     * Value of the current usage
     */
    value: number;
    /**
     * Quota of the current usage
     */
    quota: number;
    /**
     * Usage type that can be used
     */
    type: "invocation_timeout" | "invocation_calls" | "storage_count" | "bot_count" | "knowledgebase_vector_storage" | "workspace_ratelimit" | "table_row_count" | "workspace_member_count" | "integrations_owned_count" | "ai_spend" | "openai_spend" | "bing_search_spend" | "always_alive";
}
interface Issue {
    id: string;
    code: string;
    createdAt: string;
    lastSeenAt: string;
    title: string;
    description: string;
    groupedData: {
        [k: string]: {
            raw: string;
            pretty?: string;
        };
    };
    eventsCount: number;
    category: "user_code" | "limits" | "configuration" | "other";
    resolutionLink: string | null;
}
interface IssueEvent {
    id: string;
    createdAt: string;
    data: {
        [k: string]: {
            raw: string;
            pretty?: string;
        };
    };
}
/**
 * The user object represents someone interacting with the bot within a specific integration. The same person interacting with a bot in slack and messenger will be represented with two different users.
 */
interface User {
    /**
     * Id of the [User](#schema_user)
     */
    id: string;
    /**
     * Creation date of the [User](#schema_user) in ISO 8601 format
     */
    createdAt: string;
    /**
     * Updating date of the [User](#schema_user) in ISO 8601 format
     */
    updatedAt: string;
    /**
     * Set of [Tags](/docs/developers/concepts/tags) that you can attach to a [User](#schema_user). The set of [Tags](/docs/developers/concepts/tags) available on a [User](#schema_user) is restricted by the list of [Tags](/docs/developers/concepts/tags) defined previously by the [Bot](#schema_bot). Individual keys can be unset by posting an empty value to them.
     */
    tags: {
        [k: string]: string;
    };
    /**
     * Name of the [User](#schema_user)
     */
    name?: string;
    /**
     * Picture URL of the [User](#schema_user)
     */
    pictureUrl?: string;
}
/**
 * The [Conversation](#schema_conversation) object represents an exchange of messages between one or more users. A [Conversation](#schema_conversation) is always linked to an integration's channels. For example, a Slack channel represents a conversation.
 */
interface Conversation {
    /**
     * Id of the [Conversation](#schema_conversation)
     */
    id: string;
    /**
     * Id of the current [Task](#schema_task)
     */
    currentTaskId?: string;
    /**
     * Id of the current [Workflow](#schema_workflow)
     */
    currentWorkflowId?: string;
    /**
     * Creation date of the [Conversation](#schema_conversation) in ISO 8601 format
     */
    createdAt: string;
    /**
     * Updating date of the [Conversation](#schema_conversation) in ISO 8601 format
     */
    updatedAt: string;
    /**
     * Name of the channel where the [Conversation](#schema_conversation) is happening
     */
    channel: string;
    /**
     * Name of the integration that created the [Conversation](#schema_conversation)
     */
    integration: string;
    /**
     * Set of [Tags](/docs/developers/concepts/tags) that you can attach to a [Conversation](#schema_conversation). The set of [Tags](/docs/developers/concepts/tags) available on a [Conversation](#schema_conversation) is restricted by the list of [Tags](/docs/developers/concepts/tags) defined previously by the [Bot](#schema_bot). Individual keys can be unset by posting an empty value to them.
     */
    tags: {
        [k: string]: string;
    };
}
/**
 * The event object represents an action or an occurrence.
 */
interface Event {
    /**
     * Id of the [Event](#schema_event)
     */
    id: string;
    /**
     * Creation date of the [Event](#schema_event) in ISO 8601 format
     */
    createdAt: string;
    /**
     * Type of the [Event](#schema_event).
     */
    type: string;
    /**
     * Payload is the content of the event defined by the integration installed on your bot or one of the default events created by our api.
     */
    payload: {
        [k: string]: any;
    };
    /**
     * ID of the [Conversation](#schema_conversation) to link the event to.
     */
    conversationId?: string;
    /**
     * ID of the [User](#schema_user) to link the event to.
     */
    userId?: string;
    /**
     * ID of the [Message](#schema_message) to link the event to.
     */
    messageId?: string;
    status: "pending" | "processed" | "ignored" | "failed" | "scheduled";
    /**
     * Reason why the event failed to be processed
     */
    failureReason: string | null;
}
/**
 * The Message object represents a message in a [Conversation](#schema_conversation) for a specific [User](#schema_user).
 */
interface Message {
    /**
     * Id of the [Message](#schema_message)
     */
    id: string;
    /**
     * Creation date of the [Message](#schema_message) in ISO 8601 format
     */
    createdAt: string;
    /**
     * Type of the [Message](#schema_message) represents the resource type that the message is related to
     */
    type: string;
    /**
     * Payload is the content type of the message. Accepted payload options: Text, Image, Choice, Dropdown, Card, Carousel, File, Audio, Video, Location
     */
    payload: {
        [k: string]: any;
    };
    /**
     * Direction of the message (`incoming` or `outgoing`).
     */
    direction: "incoming" | "outgoing";
    /**
     * ID of the [User](#schema_user)
     */
    userId: string;
    /**
     * ID of the [Conversation](#schema_conversation)
     */
    conversationId: string;
    /**
     * Set of [Tags](/docs/developers/concepts/tags) that you can attach to a [Conversation](#schema_conversation). The set of [Tags](/docs/developers/concepts/tags) available on a [Conversation](#schema_conversation) is restricted by the list of [Tags](/docs/developers/concepts/tags) defined previously by the [Bot](#schema_bot). Individual keys can be unset by posting an empty value to them.
     */
    tags: {
        [k: string]: string;
    };
}
/**
 * The state object represents the current payload. A state is always linked to either a bot, a conversation or a user.
 */
interface State {
    /**
     * Id of the [State](#schema_state)
     */
    id: string;
    /**
     * Creation date of the [State](#schema_state) in ISO 8601 format
     */
    createdAt: string;
    /**
     * Updating date of the [State](#schema_state) in ISO 8601 format
     */
    updatedAt: string;
    /**
     * Id of the [Bot](#schema_bot)
     */
    botId: string;
    /**
     * Id of the [Conversation](#schema_conversation)
     */
    conversationId?: string;
    /**
     * Id of the [User](#schema_user)
     */
    userId?: string;
    /**
     * Name of the [State](#schema_state) which is declared inside the bot definition
     */
    name: string;
    /**
     * Type of the [State](#schema_state) represents the resource type (`conversation`, `user`, `bot`, `task`, `integration` or `workflow`) that the state is related to
     */
    type: "conversation" | "user" | "bot" | "task" | "integration" | "workflow";
    /**
     * Payload is the content of the state defined by your bot.
     */
    payload: {
        [k: string]: any;
    };
}
interface Table {
    /**
     * Unique identifier for the table
     */
    id: string;
    /**
     * Required. This name is used to identify your table.
     */
    name: string;
    /**
     * The 'factor' multiplies the row's data storage limit by 4KB and its quota count, but can only be set at table creation and not modified later. For instance, a factor of 2 increases storage to 8KB but counts as 2 rows in your quota. The default factor is 1.
     */
    factor?: number;
    /**
     * A table designated as "frozen" is immutable in terms of its name and schema structure; modifications to its schema or a renaming operation are not permitted. The only action that can be taken on such a table is deletion. The schema established at the time of creation is locked in as the final structure. To implement any changes, the table must be duplicated with the desired alterations.
     */
    frozen?: boolean;
    schema: {
        $schema: string;
        /**
         * List of keys/columns in the table.
         */
        properties: {
            [k: string]: {
                type: "string" | "number" | "boolean" | "object" | "array" | "null";
                format?: "date-time";
                description?: string;
                /**
                 * String properties must match this pattern
                 */
                pattern?: string;
                /**
                 * String properties must be one of these values
                 */
                enum?: string[];
                /**
                 * Defines the shape of items in an array
                 */
                items?: {
                    type: "string" | "number" | "boolean" | "object" | "array" | "null";
                    [k: string]: any;
                };
                nullable?: boolean;
                properties?: {
                    [k: string]: {
                        type: "string" | "number" | "boolean" | "object" | "array" | "null";
                        [k: string]: any;
                    };
                };
                "x-zui": {
                    index: number;
                    /**
                     * [deprecated] ID of the column.
                     */
                    id?: string;
                    /**
                     * Indicates if the column is vectorized and searchable.
                     */
                    searchable?: boolean;
                    /**
                     * Indicates if the field is hidden in the UI
                     */
                    hidden?: boolean;
                    /**
                     * Order of the column in the UI
                     */
                    order?: number;
                    /**
                     * Width of the column in the UI
                     */
                    width?: number;
                    /**
                     * ID of the schema
                     */
                    schemaId?: string;
                    computed?: {
                        action: "ai" | "code" | "workflow";
                        dependencies?: string[];
                        /**
                         * Prompt when action is "ai"
                         */
                        prompt?: string;
                        /**
                         * Code to execute when action is "code"
                         */
                        code?: string;
                        /**
                         * Model to use when action is "ai"
                         */
                        model?: string;
                        /**
                         * ID of Workflow to execute when action is "workflow"
                         */
                        workflowId?: string;
                        enabled?: boolean;
                    };
                    /**
                     * TypeScript typings for the column. Recommended if the type is "object", ex: "\{ foo: string; bar: number \}"
                     */
                    typings?: string;
                };
            };
        };
        /**
         * Additional properties can be provided, but they will be ignored if no column matches.
         */
        additionalProperties: true;
        /**
         * Array of required properties.
         */
        required?: string[];
        type: "object";
    };
    /**
     * Optional tags to help organize your tables. These should be passed here as an object representing key/value pairs.
     */
    tags?: {
        [k: string]: string;
    };
    /**
     * Indicates if the table is enabled for computation.
     */
    isComputeEnabled?: boolean;
    /**
     * Timestamp of table creation.
     */
    createdAt?: string;
    /**
     * Timestamp of the last table update.
     */
    updatedAt?: string;
}
interface Column {
    /**
     * Unique identifier for the column.
     */
    id?: string;
    /**
     * Name of the column, must be within length limits.
     */
    name: string;
    /**
     * Optional descriptive text about the column.
     */
    description?: string;
    /**
     * Indicates if the column is vectorized and searchable.
     */
    searchable?: boolean;
    /**
     * Specifies the data type of the column. Use "object" for complex data structures.
     */
    type: "string" | "number" | "boolean" | "date" | "object";
    /**
     * TypeScript typings for the column. Recommended if the type is "object", ex: "\{ foo: string; bar: number \}"
     */
    typings?: string;
    computed?: {
        action: "ai" | "code" | "workflow";
        dependencies?: string[];
        /**
         * Prompt when action is "ai"
         */
        prompt?: string;
        /**
         * Code to execute when action is "code"
         */
        code?: string;
        /**
         * Model to use when action is "ai"
         */
        model?: string;
        /**
         * ID of Workflow to execute when action is "workflow"
         */
        workflowId?: string;
        enabled?: boolean;
    };
    schema?: {
        [k: string]: any;
    };
}
interface Row {
    /**
     * Unique identifier for the row.
     */
    id: number;
    /**
     * Timestamp of row creation.
     */
    createdAt?: string;
    /**
     * Timestamp of the last row update.
     */
    updatedAt?: string;
    computed: {
        [k: string]: {
            status: string;
            error?: string;
            updatedBy?: string;
            updatedAt?: string;
        };
    };
    /**
     * [Read-only] List of stale values that are waiting to be recomputed.
     */
    stale?: string[];
    /**
     * Optional numeric value indicating similarity, when using findTableRows.
     */
    similarity?: number;
    [k: string]: any;
}
interface File {
    /**
     * File ID
     */
    id: string;
    /**
     * The ID of the bot the file belongs to
     */
    botId: string;
    /**
     * Unique key for the file. Must be unique across the bot (and the integration, when applicable).
     */
    key: string;
    /**
     * URL to retrieve the file content. This URL will be ready to use once the file is uploaded.
     *
     * If the file has a `public_content` policy, this will contain the permanent public URL to retrieve the file, otherwise this will contain a temporary pre-signed URL to download the file which should be used shortly after retrieving and should not be stored long-term as the URL will expire after a short timeframe.
     */
    url: string;
    /**
     * File size in bytes. Non-null if file upload status is "COMPLETE".
     */
    size: number | null;
    /**
     * MIME type of the file's content
     */
    contentType: string;
    /**
     * The tags of the file as an object of key/value pairs
     */
    tags: {
        [k: string]: string;
    };
    /**
     * File creation timestamp in ISO 8601 format
     */
    createdAt: string;
    /**
     * File last update timestamp in ISO 8601 format
     */
    updatedAt: string;
    /**
     * Access policies configured for the file.
     */
    accessPolicies: ("integrations" | "public_content")[];
    /**
     * Whether the file was requested to be indexed for search or not.
     */
    index: boolean;
    /**
     * Status of the file. If the status is `upload_pending`, the file content has not been uploaded yet. The status will be set to `upload_completed` once the file content has been uploaded successfully.
     *
     * If the upload failed for any reason (e.g. exceeding the storage quota or the maximum file size limit) the status will be set to `upload_failed` and the reason for the failure will be available in the `failedStatusReason` field of the file.
     *
     * However, if the file has been uploaded and the `index` attribute was set to `true` on the file, the status will immediately transition to the `indexing_pending` status (the `upload_completed` status step will be skipped).
     *
     * Once the indexing is completed and the file is ready to be used for searching its status will be set to `indexing_completed`. If the indexing failed the status will be set to `indexing_failed` and the reason for the failure will be available in the `failedStatusReason` field.
     */
    status: "upload_pending" | "upload_failed" | "upload_completed" | "indexing_pending" | "indexing_failed" | "indexing_completed";
    /**
     * If the file status is `upload_failed` or `indexing_failed` this will contain the reason of the failure.
     */
    failedStatusReason?: string;
    /**
     * File expiry timestamp in ISO 8601 format
     */
    expiresAt?: string;
}

type ClientProps$1 = {
    toAxiosRequest: typeof toAxiosRequest;
};
declare class Client$1 {
    private axiosInstance;
    private props;
    constructor(axiosInstance: AxiosInstance, props?: Partial<ClientProps$1>);
    readonly createConversation: (input: CreateConversationInput) => Promise<CreateConversationResponse>;
    readonly getConversation: (input: GetConversationInput) => Promise<GetConversationResponse>;
    readonly listConversations: (input: ListConversationsInput) => Promise<ListConversationsResponse>;
    readonly getOrCreateConversation: (input: GetOrCreateConversationInput) => Promise<GetOrCreateConversationResponse>;
    readonly updateConversation: (input: UpdateConversationInput) => Promise<UpdateConversationResponse>;
    readonly deleteConversation: (input: DeleteConversationInput) => Promise<DeleteConversationResponse>;
    readonly listParticipants: (input: ListParticipantsInput) => Promise<ListParticipantsResponse>;
    readonly addParticipant: (input: AddParticipantInput) => Promise<AddParticipantResponse>;
    readonly getParticipant: (input: GetParticipantInput) => Promise<GetParticipantResponse>;
    readonly removeParticipant: (input: RemoveParticipantInput) => Promise<RemoveParticipantResponse>;
    readonly createEvent: (input: CreateEventInput) => Promise<CreateEventResponse>;
    readonly getEvent: (input: GetEventInput) => Promise<GetEventResponse>;
    readonly listEvents: (input: ListEventsInput) => Promise<ListEventsResponse>;
    readonly createMessage: (input: CreateMessageInput) => Promise<CreateMessageResponse>;
    readonly getOrCreateMessage: (input: GetOrCreateMessageInput) => Promise<GetOrCreateMessageResponse>;
    readonly getMessage: (input: GetMessageInput) => Promise<GetMessageResponse>;
    readonly updateMessage: (input: UpdateMessageInput) => Promise<UpdateMessageResponse>;
    readonly listMessages: (input: ListMessagesInput) => Promise<ListMessagesResponse>;
    readonly deleteMessage: (input: DeleteMessageInput) => Promise<DeleteMessageResponse>;
    readonly createUser: (input: CreateUserInput) => Promise<CreateUserResponse>;
    readonly getUser: (input: GetUserInput) => Promise<GetUserResponse>;
    readonly listUsers: (input: ListUsersInput) => Promise<ListUsersResponse>;
    readonly getOrCreateUser: (input: GetOrCreateUserInput) => Promise<GetOrCreateUserResponse>;
    readonly updateUser: (input: UpdateUserInput) => Promise<UpdateUserResponse>;
    readonly deleteUser: (input: DeleteUserInput) => Promise<DeleteUserResponse>;
    readonly setStateExpiry: (input: SetStateExpiryInput) => Promise<SetStateExpiryResponse>;
    readonly getState: (input: GetStateInput) => Promise<GetStateResponse>;
    readonly setState: (input: SetStateInput) => Promise<SetStateResponse>;
    readonly getOrSetState: (input: GetOrSetStateInput) => Promise<GetOrSetStateResponse>;
    readonly patchState: (input: PatchStateInput) => Promise<PatchStateResponse>;
    readonly callAction: (input: CallActionInput) => Promise<CallActionResponse>;
    readonly configureIntegration: (input: ConfigureIntegrationInput) => Promise<ConfigureIntegrationResponse>;
    readonly getTask: (input: GetTaskInput) => Promise<GetTaskResponse>;
    readonly createTask: (input: CreateTaskInput) => Promise<CreateTaskResponse>;
    readonly updateTask: (input: UpdateTaskInput) => Promise<UpdateTaskResponse>;
    readonly deleteTask: (input: DeleteTaskInput) => Promise<DeleteTaskResponse>;
    readonly listTasks: (input: ListTasksInput) => Promise<ListTasksResponse>;
    readonly createWorkflow: (input: CreateWorkflowInput) => Promise<CreateWorkflowResponse>;
    readonly getWorkflow: (input: GetWorkflowInput) => Promise<GetWorkflowResponse>;
    readonly updateWorkflow: (input: UpdateWorkflowInput) => Promise<UpdateWorkflowResponse>;
    readonly deleteWorkflow: (input: DeleteWorkflowInput) => Promise<DeleteWorkflowResponse>;
    readonly listWorkflows: (input: ListWorkflowsInput) => Promise<ListWorkflowsResponse>;
    readonly getOrCreateWorkflow: (input: GetOrCreateWorkflowInput) => Promise<GetOrCreateWorkflowResponse>;
    readonly trackAnalytics: (input: TrackAnalyticsInput) => Promise<TrackAnalyticsResponse>;
    readonly runVrl: (input: RunVrlInput) => Promise<RunVrlResponse>;
    readonly getAccount: (input: GetAccountInput) => Promise<GetAccountResponse>;
    readonly updateAccount: (input: UpdateAccountInput) => Promise<UpdateAccountResponse>;
    readonly listPersonalAccessTokens: (input: ListPersonalAccessTokensInput) => Promise<ListPersonalAccessTokensResponse>;
    readonly createPersonalAccessToken: (input: CreatePersonalAccessTokenInput) => Promise<CreatePersonalAccessTokenResponse>;
    readonly deletePersonalAccessToken: (input: DeletePersonalAccessTokenInput) => Promise<DeletePersonalAccessTokenResponse>;
    readonly setAccountPreference: (input: SetAccountPreferenceInput) => Promise<SetAccountPreferenceResponse>;
    readonly getAccountPreference: (input: GetAccountPreferenceInput) => Promise<GetAccountPreferenceResponse>;
    readonly listPublicIntegrations: (input: ListPublicIntegrationsInput) => Promise<ListPublicIntegrationsResponse>;
    readonly getPublicIntegrationById: (input: GetPublicIntegrationByIdInput) => Promise<GetPublicIntegrationByIdResponse>;
    readonly getPublicIntegration: (input: GetPublicIntegrationInput) => Promise<GetPublicIntegrationResponse>;
    readonly createBot: (input: CreateBotInput) => Promise<CreateBotResponse>;
    readonly updateBot: (input: UpdateBotInput) => Promise<UpdateBotResponse>;
    readonly transferBot: (input: TransferBotInput) => Promise<TransferBotResponse>;
    readonly listBots: (input: ListBotsInput) => Promise<ListBotsResponse>;
    readonly getBot: (input: GetBotInput) => Promise<GetBotResponse>;
    readonly deleteBot: (input: DeleteBotInput) => Promise<DeleteBotResponse>;
    readonly getBotLogs: (input: GetBotLogsInput) => Promise<GetBotLogsResponse>;
    readonly getBotWebchat: (input: GetBotWebchatInput) => Promise<GetBotWebchatResponse>;
    readonly getBotAnalytics: (input: GetBotAnalyticsInput) => Promise<GetBotAnalyticsResponse>;
    readonly getBotIssue: (input: GetBotIssueInput) => Promise<GetBotIssueResponse>;
    readonly listBotIssues: (input: ListBotIssuesInput) => Promise<ListBotIssuesResponse>;
    readonly deleteBotIssue: (input: DeleteBotIssueInput) => Promise<DeleteBotIssueResponse>;
    readonly listBotIssueEvents: (input: ListBotIssueEventsInput) => Promise<ListBotIssueEventsResponse>;
    readonly listBotVersions: (input: ListBotVersionsInput) => Promise<ListBotVersionsResponse>;
    readonly getBotVersion: (input: GetBotVersionInput) => Promise<GetBotVersionResponse>;
    readonly createBotVersion: (input: CreateBotVersionInput) => Promise<CreateBotVersionResponse>;
    readonly deployBotVersion: (input: DeployBotVersionInput) => Promise<DeployBotVersionResponse>;
    readonly setWorkspacePaymentMethod: (input: SetWorkspacePaymentMethodInput) => Promise<SetWorkspacePaymentMethodResponse>;
    readonly listWorkspaceInvoices: (input: ListWorkspaceInvoicesInput) => Promise<ListWorkspaceInvoicesResponse>;
    readonly getUpcomingInvoice: (input: GetUpcomingInvoiceInput) => Promise<GetUpcomingInvoiceResponse>;
    readonly chargeWorkspaceUnpaidInvoices: (input: ChargeWorkspaceUnpaidInvoicesInput) => Promise<ChargeWorkspaceUnpaidInvoicesResponse>;
    readonly createWorkspace: (input: CreateWorkspaceInput) => Promise<CreateWorkspaceResponse>;
    readonly getPublicWorkspace: (input: GetPublicWorkspaceInput) => Promise<GetPublicWorkspaceResponse$1>;
    readonly getWorkspace: (input: GetWorkspaceInput) => Promise<GetWorkspaceResponse>;
    readonly listWorkspaceUsages: (input: ListWorkspaceUsagesInput) => Promise<ListWorkspaceUsagesResponse>;
    readonly breakDownWorkspaceUsageByBot: (input: BreakDownWorkspaceUsageByBotInput) => Promise<BreakDownWorkspaceUsageByBotResponse>;
    readonly getAllWorkspaceQuotaCompletion: (input: GetAllWorkspaceQuotaCompletionInput) => Promise<GetAllWorkspaceQuotaCompletionResponse>;
    readonly getWorkspaceQuota: (input: GetWorkspaceQuotaInput) => Promise<GetWorkspaceQuotaResponse>;
    readonly listWorkspaceQuotas: (input: ListWorkspaceQuotasInput) => Promise<ListWorkspaceQuotasResponse>;
    readonly updateWorkspace: (input: UpdateWorkspaceInput) => Promise<UpdateWorkspaceResponse$1>;
    readonly checkHandleAvailability: (input: CheckHandleAvailabilityInput) => Promise<CheckHandleAvailabilityResponse>;
    readonly listWorkspaces: (input: ListWorkspacesInput) => Promise<ListWorkspacesResponse>;
    readonly listPublicWorkspaces: (input: ListPublicWorkspacesInput) => Promise<ListPublicWorkspacesResponse>;
    readonly deleteWorkspace: (input: DeleteWorkspaceInput) => Promise<DeleteWorkspaceResponse>;
    readonly getAuditRecords: (input: GetAuditRecordsInput) => Promise<GetAuditRecordsResponse>;
    readonly listWorkspaceMembers: (input: ListWorkspaceMembersInput) => Promise<ListWorkspaceMembersResponse>;
    readonly getWorkspaceMember: (input: GetWorkspaceMemberInput) => Promise<GetWorkspaceMemberResponse>;
    readonly deleteWorkspaceMember: (input: DeleteWorkspaceMemberInput) => Promise<DeleteWorkspaceMemberResponse>;
    readonly createWorkspaceMember: (input: CreateWorkspaceMemberInput) => Promise<CreateWorkspaceMemberResponse>;
    readonly updateWorkspaceMember: (input: UpdateWorkspaceMemberInput) => Promise<UpdateWorkspaceMemberResponse>;
    readonly listIntegrationApiKeys: (input: ListIntegrationApiKeysInput) => Promise<ListIntegrationApiKeysResponse>;
    readonly createIntegrationApiKey: (input: CreateIntegrationApiKeyInput) => Promise<CreateIntegrationApiKeyResponse>;
    readonly deleteIntegrationApiKey: (input: DeleteIntegrationApiKeyInput) => Promise<DeleteIntegrationApiKeyResponse>;
    readonly createIntegration: (input: CreateIntegrationInput) => Promise<CreateIntegrationResponse>;
    readonly updateIntegration: (input: UpdateIntegrationInput) => Promise<UpdateIntegrationResponse>;
    readonly listIntegrations: (input: ListIntegrationsInput) => Promise<ListIntegrationsResponse>;
    readonly getIntegration: (input: GetIntegrationInput) => Promise<GetIntegrationResponse>;
    readonly getIntegrationLogs: (input: GetIntegrationLogsInput) => Promise<GetIntegrationLogsResponse>;
    readonly getIntegrationByName: (input: GetIntegrationByNameInput) => Promise<GetIntegrationByNameResponse>;
    readonly deleteIntegration: (input: DeleteIntegrationInput) => Promise<DeleteIntegrationResponse>;
    readonly requestIntegrationVerification: (input: RequestIntegrationVerificationInput) => Promise<RequestIntegrationVerificationResponse>;
    readonly createInterface: (input: CreateInterfaceInput) => Promise<CreateInterfaceResponse>;
    readonly getInterface: (input: GetInterfaceInput) => Promise<GetInterfaceResponse>;
    readonly getInterfaceByName: (input: GetInterfaceByNameInput) => Promise<GetInterfaceByNameResponse>;
    readonly updateInterface: (input: UpdateInterfaceInput) => Promise<UpdateInterfaceResponse>;
    readonly deleteInterface: (input: DeleteInterfaceInput) => Promise<DeleteInterfaceResponse>;
    readonly listInterfaces: (input: ListInterfacesInput) => Promise<ListInterfacesResponse>;
    readonly getUsage: (input: GetUsageInput) => Promise<GetUsageResponse>;
    readonly getMultipleUsages: (input: GetMultipleUsagesInput) => Promise<GetMultipleUsagesResponse>;
    readonly listUsageHistory: (input: ListUsageHistoryInput) => Promise<ListUsageHistoryResponse>;
    readonly listUsageActivity: (input: ListUsageActivityInput) => Promise<ListUsageActivityResponse>;
    readonly changeAISpendQuota: (input: ChangeAispendQuotaInput) => Promise<ChangeAispendQuotaResponse>;
    readonly listActivities: (input: ListActivitiesInput) => Promise<ListActivitiesResponse>;
    readonly introspect: (input: IntrospectInput) => Promise<IntrospectResponse>;
    readonly upsertFile: (input: UpsertFileInput) => Promise<UpsertFileResponse>;
    readonly deleteFile: (input: DeleteFileInput) => Promise<DeleteFileResponse>;
    readonly listFiles: (input: ListFilesInput) => Promise<ListFilesResponse>;
    readonly getFile: (input: GetFileInput) => Promise<GetFileResponse>;
    readonly updateFileMetadata: (input: UpdateFileMetadataInput) => Promise<UpdateFileMetadataResponse>;
    readonly searchFiles: (input: SearchFilesInput) => Promise<SearchFilesResponse>;
    readonly listFilePassages: (input: ListFilePassagesInput) => Promise<ListFilePassagesResponse>;
    readonly listTables: (input: ListTablesInput) => Promise<ListTablesResponse>;
    readonly getTable: (input: GetTableInput) => Promise<GetTableResponse>;
    readonly getOrCreateTable: (input: GetOrCreateTableInput) => Promise<GetOrCreateTableResponse>;
    readonly createTable: (input: CreateTableInput) => Promise<CreateTableResponse>;
    readonly duplicateTable: (input: DuplicateTableInput) => Promise<DuplicateTableResponse>;
    readonly updateTable: (input: UpdateTableInput) => Promise<UpdateTableResponse>;
    readonly renameTableColumn: (input: RenameTableColumnInput) => Promise<RenameTableColumnResponse>;
    readonly deleteTable: (input: DeleteTableInput) => Promise<DeleteTableResponse>;
    readonly getTableRow: (input: GetTableRowInput) => Promise<GetTableRowResponse>;
    readonly findTableRows: (input: FindTableRowsInput) => Promise<FindTableRowsResponse>;
    readonly createTableRows: (input: CreateTableRowsInput) => Promise<CreateTableRowsResponse>;
    readonly deleteTableRows: (input: DeleteTableRowsInput) => Promise<DeleteTableRowsResponse>;
    readonly updateTableRows: (input: UpdateTableRowsInput) => Promise<UpdateTableRowsResponse>;
    readonly upsertTableRows: (input: UpsertTableRowsInput) => Promise<UpsertTableRowsResponse>;
}

type UploadFileInput = Omit<UpsertFileInput, 'size'> & {
    content?: ArrayBuffer | Buffer | Blob | Uint8Array | string;
    url?: string;
};
type UploadFileOutput = UpsertFileResponse;
type Simplify<T> = T extends (...args: infer A) => infer R ? (...args: Simplify<A>) => Simplify<R> : T extends Promise<infer R> ? Promise<Simplify<R>> : T extends Buffer ? Buffer : T extends object ? T extends infer O ? {
    [K in keyof O]: Simplify<O[K]>;
} : never : T;
type AsyncFunc = (...args: any[]) => Promise<any>;
type IClient = Simplify<Client$1 & {
    uploadFile: (input: UploadFileInput) => Promise<UploadFileOutput>;
}>;
type Operation = Simplify<keyof {
    [K in keyof IClient as IClient[K] extends AsyncFunc ? K : never]: IClient[K];
}>;
/**
 * @deprecated Use ClientInputs instead
 */
type ClientParams<T extends Operation> = Simplify<Parameters<IClient[T]>[0]>;
/**
 * @deprecated Use ClientOutputs instead
 */
type ClientReturn<T extends Operation> = Simplify<Awaited<ReturnType<IClient[T]>>>;
type ClientInputs = Simplify<{
    [T in Operation]: Parameters<IClient[T]>[0];
}>;
type ClientOutputs = Simplify<{
    [T in Operation]: Awaited<ReturnType<IClient[T]>>;
}>;
type Headers = Record<string, string | string[]>;
type RetryConfig = IAxiosRetryConfig;
type ClientProps = {
    integrationId?: string;
    workspaceId?: string;
    botId?: string;
    token?: string;
    apiUrl?: string;
    timeout?: number;
    headers?: Headers;
    retry?: RetryConfig;
};
type ClientConfig = {
    apiUrl: string;
    headers: Headers;
    withCredentials: boolean;
    timeout: number;
};

declare const codes: {
    readonly HTTP_STATUS_BAD_REQUEST: 400;
    readonly HTTP_STATUS_UNAUTHORIZED: 401;
    readonly HTTP_STATUS_PAYMENT_REQUIRED: 402;
    readonly HTTP_STATUS_FORBIDDEN: 403;
    readonly HTTP_STATUS_NOT_FOUND: 404;
    readonly HTTP_STATUS_METHOD_NOT_ALLOWED: 405;
    readonly HTTP_STATUS_REQUEST_TIMEOUT: 408;
    readonly HTTP_STATUS_CONFLICT: 409;
    readonly HTTP_STATUS_PAYLOAD_TOO_LARGE: 413;
    readonly HTTP_STATUS_UNSUPPORTED_MEDIA_TYPE: 415;
    readonly HTTP_STATUS_TOO_MANY_REQUESTS: 429;
    readonly HTTP_STATUS_INTERNAL_SERVER_ERROR: 500;
    readonly HTTP_STATUS_NOT_IMPLEMENTED: 501;
    readonly HTTP_STATUS_BAD_GATEWAY: 502;
    readonly HTTP_STATUS_SERVICE_UNAVAILABLE: 503;
    readonly HTTP_STATUS_GATEWAY_TIMEOUT: 504;
};
type ErrorCode = typeof codes[keyof typeof codes];
declare abstract class BaseApiError<Code extends ErrorCode, Type extends string, Description extends string> extends Error {
    readonly code: Code;
    readonly description: Description;
    readonly type: Type;
    readonly message: string;
    readonly error?: Error | undefined;
    readonly id?: string | undefined;
    readonly isApiError = true;
    constructor(code: Code, description: Description, type: Type, message: string, error?: Error | undefined, id?: string | undefined);
    format(): string;
    toJSON(): {
        id: string | undefined;
        code: Code;
        type: Type;
        message: string;
    };
    static generateId(): string;
    private static getPrefix;
}
declare const isApiError: (thrown: unknown) => thrown is ApiError;
type UnknownType = 'Unknown';
/**
 *  An unknown error occurred
 */
declare class UnknownError extends BaseApiError<500, UnknownType, 'An unknown error occurred'> {
    constructor(message: string, error?: Error, id?: string);
}
type InternalType = 'Internal';
/**
 *  An internal error occurred
 */
declare class InternalError extends BaseApiError<500, InternalType, 'An internal error occurred'> {
    constructor(message: string, error?: Error, id?: string);
}
type UnauthorizedType = 'Unauthorized';
/**
 *  The request requires to be authenticated.
 */
declare class UnauthorizedError extends BaseApiError<401, UnauthorizedType, 'The request requires to be authenticated.'> {
    constructor(message: string, error?: Error, id?: string);
}
type ForbiddenType = 'Forbidden';
/**
 *  The requested action can\'t be peform by this resource.
 */
declare class ForbiddenError extends BaseApiError<403, ForbiddenType, 'The requested action can\'t be peform by this resource.'> {
    constructor(message: string, error?: Error, id?: string);
}
type PayloadTooLargeType = 'PayloadTooLarge';
/**
 *  The request payload is too large.
 */
declare class PayloadTooLargeError extends BaseApiError<413, PayloadTooLargeType, 'The request payload is too large.'> {
    constructor(message: string, error?: Error, id?: string);
}
type InvalidPayloadType = 'InvalidPayload';
/**
 *  The request payload is invalid.
 */
declare class InvalidPayloadError extends BaseApiError<400, InvalidPayloadType, 'The request payload is invalid.'> {
    constructor(message: string, error?: Error, id?: string);
}
type UnsupportedMediaTypeType = 'UnsupportedMediaType';
/**
 *  The request is invalid because the content-type is not supported.
 */
declare class UnsupportedMediaTypeError extends BaseApiError<415, UnsupportedMediaTypeType, 'The request is invalid because the content-type is not supported.'> {
    constructor(message: string, error?: Error, id?: string);
}
type MethodNotFoundType = 'MethodNotFound';
/**
 *  The requested method does not exist.
 */
declare class MethodNotFoundError extends BaseApiError<405, MethodNotFoundType, 'The requested method does not exist.'> {
    constructor(message: string, error?: Error, id?: string);
}
type ResourceNotFoundType = 'ResourceNotFound';
/**
 *  The requested resource does not exist.
 */
declare class ResourceNotFoundError extends BaseApiError<404, ResourceNotFoundType, 'The requested resource does not exist.'> {
    constructor(message: string, error?: Error, id?: string);
}
type InvalidJsonSchemaType = 'InvalidJsonSchema';
/**
 *  The provided JSON schema is invalid.
 */
declare class InvalidJsonSchemaError extends BaseApiError<400, InvalidJsonSchemaType, 'The provided JSON schema is invalid.'> {
    constructor(message: string, error?: Error, id?: string);
}
type InvalidDataFormatType = 'InvalidDataFormat';
/**
 *  The provided data doesn\'t respect the provided JSON schema.
 */
declare class InvalidDataFormatError extends BaseApiError<400, InvalidDataFormatType, 'The provided data doesn\'t respect the provided JSON schema.'> {
    constructor(message: string, error?: Error, id?: string);
}
type InvalidIdentifierType = 'InvalidIdentifier';
/**
 *  The provided identifier is not valid. An identifier must start with a lowercase letter, be between 2 and 100 characters long and use only alphanumeric characters.
 */
declare class InvalidIdentifierError extends BaseApiError<400, InvalidIdentifierType, 'The provided identifier is not valid. An identifier must start with a lowercase letter, be between 2 and 100 characters long and use only alphanumeric characters.'> {
    constructor(message: string, error?: Error, id?: string);
}
type RelationConflictType = 'RelationConflict';
/**
 *  The resource is related with a different resource that the one referenced in the request. This is usually caused when providing two resource identifiers that aren\'t linked together.
 */
declare class RelationConflictError extends BaseApiError<409, RelationConflictType, 'The resource is related with a different resource that the one referenced in the request. This is usually caused when providing two resource identifiers that aren\'t linked together.'> {
    constructor(message: string, error?: Error, id?: string);
}
type ReferenceConstraintType = 'ReferenceConstraint';
/**
 *  The resource cannot be deleted because it\'s referenced by another resource
 */
declare class ReferenceConstraintError extends BaseApiError<409, ReferenceConstraintType, 'The resource cannot be deleted because it\'s referenced by another resource'> {
    constructor(message: string, error?: Error, id?: string);
}
type ResourceLockedConflictType = 'ResourceLockedConflict';
/**
 *  The resource is current locked and cannot be operated on until the lock is released.
 */
declare class ResourceLockedConflictError extends BaseApiError<409, ResourceLockedConflictType, 'The resource is current locked and cannot be operated on until the lock is released.'> {
    constructor(message: string, error?: Error, id?: string);
}
type ReferenceNotFoundType = 'ReferenceNotFound';
/**
 *  The provided resource reference is missing. This is usually caused when providing an invalid id inside the payload of a request.
 */
declare class ReferenceNotFoundError extends BaseApiError<400, ReferenceNotFoundType, 'The provided resource reference is missing. This is usually caused when providing an invalid id inside the payload of a request.'> {
    constructor(message: string, error?: Error, id?: string);
}
type InvalidQueryType = 'InvalidQuery';
/**
 *  The provided query is invalid. This is usually caused when providing an invalid parameter for querying a resource.
 */
declare class InvalidQueryError extends BaseApiError<400, InvalidQueryType, 'The provided query is invalid. This is usually caused when providing an invalid parameter for querying a resource.'> {
    constructor(message: string, error?: Error, id?: string);
}
type RuntimeType = 'Runtime';
/**
 *  An error happened during the execution of a runtime (bot or integration).
 */
declare class RuntimeError extends BaseApiError<400, RuntimeType, 'An error happened during the execution of a runtime (bot or integration).'> {
    constructor(message: string, error?: Error, id?: string);
}
type AlreadyExistsType = 'AlreadyExists';
/**
 *  The record attempted to be created already exists.
 */
declare class AlreadyExistsError extends BaseApiError<409, AlreadyExistsType, 'The record attempted to be created already exists.'> {
    constructor(message: string, error?: Error, id?: string);
}
type RateLimitedType = 'RateLimited';
/**
 *  The request has been rate limited.
 */
declare class RateLimitedError extends BaseApiError<429, RateLimitedType, 'The request has been rate limited.'> {
    constructor(message: string, error?: Error, id?: string);
}
type PaymentRequiredType = 'PaymentRequired';
/**
 *  A payment is required to perform this request.
 */
declare class PaymentRequiredError extends BaseApiError<402, PaymentRequiredType, 'A payment is required to perform this request.'> {
    constructor(message: string, error?: Error, id?: string);
}
type QuotaExceededType = 'QuotaExceeded';
/**
 *  The request exceeds the allowed quota. Quotas are a soft limit that can be increased.
 */
declare class QuotaExceededError extends BaseApiError<403, QuotaExceededType, 'The request exceeds the allowed quota. Quotas are a soft limit that can be increased.'> {
    constructor(message: string, error?: Error, id?: string);
}
type LimitExceededType = 'LimitExceeded';
/**
 *  The request exceeds the allowed limit. Limits are a hard limit that cannot be increased.
 */
declare class LimitExceededError extends BaseApiError<413, LimitExceededType, 'The request exceeds the allowed limit. Limits are a hard limit that cannot be increased.'> {
    constructor(message: string, error?: Error, id?: string);
}
type BreakingChangesType = 'BreakingChanges';
/**
 *  Request payload contains breaking changes which is not allowed for this resource without a version increment.
 */
declare class BreakingChangesError extends BaseApiError<400, BreakingChangesType, 'Request payload contains breaking changes which is not allowed for this resource without a version increment.'> {
    constructor(message: string, error?: Error, id?: string);
}
type ErrorType = 'Unknown' | 'Internal' | 'Unauthorized' | 'Forbidden' | 'PayloadTooLarge' | 'InvalidPayload' | 'UnsupportedMediaType' | 'MethodNotFound' | 'ResourceNotFound' | 'InvalidJsonSchema' | 'InvalidDataFormat' | 'InvalidIdentifier' | 'RelationConflict' | 'ReferenceConstraint' | 'ResourceLockedConflict' | 'ReferenceNotFound' | 'InvalidQuery' | 'Runtime' | 'AlreadyExists' | 'RateLimited' | 'PaymentRequired' | 'QuotaExceeded' | 'LimitExceeded' | 'BreakingChanges';
type ApiError = UnknownError | InternalError | UnauthorizedError | ForbiddenError | PayloadTooLargeError | InvalidPayloadError | UnsupportedMediaTypeError | MethodNotFoundError | ResourceNotFoundError | InvalidJsonSchemaError | InvalidDataFormatError | InvalidIdentifierError | RelationConflictError | ReferenceConstraintError | ResourceLockedConflictError | ReferenceNotFoundError | InvalidQueryError | RuntimeError | AlreadyExistsError | RateLimitedError | PaymentRequiredError | QuotaExceededError | LimitExceededError | BreakingChangesError;
declare const errorFrom: (err: unknown) => ApiError;

declare class UploadFileError extends Error {
    readonly innerError?: AxiosError<unknown, any> | undefined;
    readonly file?: {
        id: string;
        botId: string;
        key: string;
        url: string;
        size: number | null;
        contentType: string;
        tags: {
            [k: string]: string;
        };
        createdAt: string;
        updatedAt: string;
        accessPolicies: ("integrations" | "public_content")[];
        index: boolean;
        status: "upload_pending" | "upload_failed" | "upload_completed" | "indexing_pending" | "indexing_failed" | "indexing_completed";
        failedStatusReason?: string | undefined;
        expiresAt?: string | undefined;
        uploadUrl: string;
    } | undefined;
    constructor(message: string, innerError?: AxiosError<unknown, any> | undefined, file?: {
        id: string;
        botId: string;
        key: string;
        url: string;
        size: number | null;
        contentType: string;
        tags: {
            [k: string]: string;
        };
        createdAt: string;
        updatedAt: string;
        accessPolicies: ("integrations" | "public_content")[];
        index: boolean;
        status: "upload_pending" | "upload_failed" | "upload_completed" | "indexing_pending" | "indexing_failed" | "indexing_completed";
        failedStatusReason?: string | undefined;
        expiresAt?: string | undefined;
        uploadUrl: string;
    } | undefined);
}

type ListOperation = keyof {
    [K in Operation as ClientInputs[K] extends {
        nextToken?: string | undefined;
    } ? K : never]: null;
};
type ListInputs = {
    [K in ListOperation]: Omit<ClientInputs[K], 'nextToken'>;
};
type PageLister<R> = (t: {
    nextToken?: string;
}) => Promise<{
    items: R[];
    meta: {
        nextToken?: string;
    };
}>;
declare class AsyncCollection<T> {
    private _list;
    constructor(_list: PageLister<T>);
    [Symbol.asyncIterator](): AsyncGenerator<Awaited<T>, void, unknown>;
    collect(props?: {
        limit?: number;
    }): Promise<T[]>;
}
declare class Lister {
    private _client;
    constructor(_client: Client$1);
    readonly conversations: (props: ListInputs['listConversations']) => AsyncCollection<{
        id: string;
        currentTaskId?: string | undefined;
        currentWorkflowId?: string | undefined;
        createdAt: string;
        updatedAt: string;
        channel: string;
        integration: string;
        tags: {
            [k: string]: string;
        };
    }>;
    readonly participants: (props: ListInputs['listParticipants']) => AsyncCollection<{
        id: string;
        createdAt: string;
        updatedAt: string;
        tags: {
            [k: string]: string;
        };
        name?: string | undefined;
        pictureUrl?: string | undefined;
    }>;
    readonly events: (props: ListInputs['listEvents']) => AsyncCollection<{
        id: string;
        createdAt: string;
        type: string;
        payload: {
            [k: string]: any;
        };
        conversationId?: string | undefined;
        userId?: string | undefined;
        messageId?: string | undefined;
        status: "pending" | "processed" | "ignored" | "failed" | "scheduled";
        failureReason: string | null;
    }>;
    readonly messages: (props: ListInputs['listMessages']) => AsyncCollection<{
        id: string;
        createdAt: string;
        type: string;
        payload: {
            [k: string]: any;
        };
        direction: "incoming" | "outgoing";
        userId: string;
        conversationId: string;
        tags: {
            [k: string]: string;
        };
    }>;
    readonly users: (props: ListInputs['listUsers']) => AsyncCollection<{
        id: string;
        createdAt: string;
        updatedAt: string;
        tags: {
            [k: string]: string;
        };
        name?: string | undefined;
        pictureUrl?: string | undefined;
    }>;
    readonly tasks: (props: ListInputs['listTasks']) => AsyncCollection<{
        id: string;
        title: string;
        description: string;
        type: string;
        data: {
            [k: string]: any;
        };
        status: "pending" | "failed" | "in_progress" | "completed" | "blocked" | "paused" | "timeout" | "cancelled";
        parentTaskId?: string | undefined;
        conversationId?: string | undefined;
        userId?: string | undefined;
        timeoutAt: string;
        createdAt: string;
        updatedAt: string;
        failureReason?: string | undefined;
        tags: {
            [k: string]: string;
        };
    }>;
    readonly publicIntegrations: (props: ListInputs['listPublicIntegrations']) => AsyncCollection<{
        id: string;
        name: string;
        version: string;
        createdAt: string;
        updatedAt: string;
        title: string;
        description: string;
        iconUrl: string;
        public: boolean;
        verificationStatus: "pending" | "unapproved" | "approved" | "rejected";
        ownerWorkspace: {
            id: string;
            handle: string | null;
            name: string;
        };
    }>;
    readonly bots: (props: ListInputs['listBots']) => AsyncCollection<{
        id: string;
        createdAt: string;
        updatedAt: string;
        name: string;
        deployedAt?: string | undefined;
    }>;
    readonly botIssues: (props: ListInputs['listBotIssues']) => AsyncCollection<{
        id: string;
        code: string;
        createdAt: string;
        lastSeenAt: string;
        title: string;
        description: string;
        groupedData: {
            [k: string]: {
                raw: string;
                pretty?: string | undefined;
            };
        };
        eventsCount: number;
        category: "configuration" | "user_code" | "limits" | "other";
        resolutionLink: string | null;
    }>;
    readonly workspaces: (props: ListInputs['listWorkspaces']) => AsyncCollection<UpdateWorkspaceResponse>;
    readonly publicWorkspaces: (props: ListInputs['listPublicWorkspaces']) => AsyncCollection<GetPublicWorkspaceResponse>;
    readonly workspaceMembers: (props: ListInputs['listWorkspaceMembers']) => AsyncCollection<{
        id: string;
        userId?: string | undefined;
        email: string;
        createdAt: string;
        role: "viewer" | "billing" | "developer" | "manager" | "administrator" | "owner";
        profilePicture?: string | undefined;
        displayName?: string | undefined;
    }>;
    readonly integrations: (props: ListInputs['listIntegrations']) => AsyncCollection<{
        id: string;
        name: string;
        version: string;
        createdAt: string;
        updatedAt: string;
        title: string;
        description: string;
        iconUrl: string;
        public: boolean;
        verificationStatus: "pending" | "unapproved" | "approved" | "rejected";
    }>;
    readonly interfaces: (props: ListInputs['listInterfaces']) => AsyncCollection<{
        id: string;
        createdAt: string;
        updatedAt: string;
        name: string;
        version: string;
    }>;
    readonly activities: (props: ListInputs['listActivities']) => AsyncCollection<{
        id: string;
        description: string;
        taskId: string;
        category: "unknown" | "capture" | "bot_message" | "user_message" | "agent_message" | "event" | "action" | "task_status" | "subtask_status" | "exception";
        data: {
            [k: string]: any;
        };
        createdAt: string;
    }>;
    readonly files: (props: ListInputs['listFiles']) => AsyncCollection<{
        id: string;
        botId: string;
        key: string;
        url: string;
        size: number | null;
        contentType: string;
        tags: {
            [k: string]: string;
        };
        createdAt: string;
        updatedAt: string;
        accessPolicies: ("integrations" | "public_content")[];
        index: boolean;
        status: "upload_pending" | "upload_failed" | "upload_completed" | "indexing_pending" | "indexing_failed" | "indexing_completed";
        failedStatusReason?: string | undefined;
        expiresAt?: string | undefined;
    }>;
    readonly filePassages: (props: ListInputs['listFilePassages']) => AsyncCollection<{
        id: string;
        content: string;
        meta: {
            type?: "chunk" | "summary" | "consolidated" | undefined;
            subtype?: "code" | "title" | "subtitle" | "paragraph" | "list" | "blockquote" | "table" | undefined;
            pageNumber?: number | undefined;
            position?: number | undefined;
        };
    }>;
}

declare class Client extends Client$1 implements IClient {
    readonly config: Readonly<ClientConfig>;
    constructor(clientProps?: ClientProps);
    get list(): Lister;
    /**
     * Create/update and upload a file in a single step. Returns an object containing the file metadata and the URL to retrieve the file.
     */
    readonly uploadFile: ({ key, index, tags, contentType, accessPolicies, content, url, expiresAt, publicContentImmediatelyAccessible, }: ClientInputs['uploadFile']) => Promise<ClientOutputs['uploadFile']>;
}

export { type Account, AlreadyExistsError, type ApiError, type Bot, BreakingChangesError, Client, type ClientConfig, type ClientInputs, type ClientOutputs, type ClientParams, type ClientProps, type ClientReturn, type Column, type Conversation, type ErrorType, type Event, type File, ForbiddenError, type IClient, type Integration, type Interface, InternalError, InvalidDataFormatError, InvalidIdentifierError, InvalidJsonSchemaError, InvalidPayloadError, InvalidQueryError, type Issue, type IssueEvent, LimitExceededError, type Message, MethodNotFoundError, type Operation, PayloadTooLargeError, PaymentRequiredError, QuotaExceededError, RateLimitedError, ReferenceConstraintError, ReferenceNotFoundError, RelationConflictError, ResourceLockedConflictError, ResourceNotFoundError, type RetryConfig, type Row, RuntimeError, type State, type Table, UnauthorizedError, UnknownError, UnsupportedMediaTypeError, UploadFileError, type Usage, type User, type Workspace, type WorkspaceMember, errorFrom, isApiError };
